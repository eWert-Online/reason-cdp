module Accessibility = struct
  (* Disables the accessibility domain. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Accessibility.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
     This turns on accessibility for the page, which can impact performance until accessibility is disabled. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Accessibility.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists. *)
  module GetPartialAXTree = struct
    module Response : sig
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"]
            [@ocaml.doc
              "The `Accessibility.AXNode` for this DOM node, if it exists, \
               plus its ancestors, siblings and\n\
               children, if requested."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"]
            [@ocaml.doc
              "The `Accessibility.AXNode` for this DOM node, if it exists, \
               plus its ancestors, siblings and\n\
               children, if requested."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Identifier of the node to get the partial accessibility tree \
               for."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Identifier of the backend node to get the partial accessibility \
               tree for."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc
              "JavaScript object id of the node wrapper to get the partial \
               accessibility tree for."]
        fetchRelatives : bool option;
            [@key "fetchRelatives"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to fetch this node's ancestors, siblings and children. \
               Defaults to true."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId ?fetchRelatives () =
        { nodeId; backendNodeId; objectId; fetchRelatives }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Accessibility.getPartialAXTree"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Fetches the entire accessibility tree for the root Document *)
  module GetFullAXTree = struct
    module Response : sig
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        depth : Types.number option;
            [@key "depth"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum depth at which descendants of the root node should \
               be retrieved.\n\
               If omitted, the full tree is returned."]
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc
              "The frame for whose document the AX tree should be retrieved.\n\
               If omited, the root frame is used."]
      }
      [@@deriving yojson]

      let make ?depth ?frameId () = { depth; frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Accessibility.getFullAXTree"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Fetches the root node.
     Requires `enable()` to have been called previously. *)
  module GetRootAXNode = struct
    module Response : sig
      type result = {
        node : Types.Accessibility.AXNode.t;
            [@key "node"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        node : Types.Accessibility.AXNode.t;
            [@key "node"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc
              "The frame in whose document the node resides.\n\
               If omitted, the root frame is used."]
      }
      [@@deriving yojson]

      let make ?frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Accessibility.getRootAXNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Fetches a node and all ancestors up to and including the root.
     Requires `enable()` to have been called previously. *)
  module GetAXNodeAndAncestors = struct
    module Response : sig
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node to get."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node to get."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper to get."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId () =
        { nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Accessibility.getAXNodeAndAncestors";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Fetches a particular accessibility node by AXNodeId.
     Requires `enable()` to have been called previously. *)
  module GetChildAXNodes = struct
    module Response : sig
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        id : Types.Accessibility.AXNodeId.t;
            [@key "id"] [@ocaml.doc "No description provided"]
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc
              "The frame in whose document the node resides.\n\
               If omitted, the root frame is used."]
      }
      [@@deriving yojson]

      let make ~id ?frameId () = { id; frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Accessibility.getChildAXNodes"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Query a DOM node's accessibility subtree for accessible name and role.
     This command computes the name and role for all nodes in the subtree, including those that are
     ignored for accessibility, and returns those that mactch the specified name and role. If no DOM
     node is specified, or the DOM node does not exist, the command returns an error. If neither
     `accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree. *)
  module QueryAXTree = struct
    module Response : sig
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"]
            [@ocaml.doc
              "A list of `Accessibility.AXNode` matching the specified \
               attributes,\n\
               including nodes that are ignored for accessibility."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"]
            [@ocaml.doc
              "A list of `Accessibility.AXNode` matching the specified \
               attributes,\n\
               including nodes that are ignored for accessibility."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node for the root to query."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node for the root to query."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc
              "JavaScript object id of the node wrapper for the root to query."]
        accessibleName : string option;
            [@key "accessibleName"]
            [@yojson.option]
            [@ocaml.doc "Find nodes with this computed name."]
        role : string option;
            [@key "role"]
            [@yojson.option]
            [@ocaml.doc "Find nodes with this computed role."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId ?accessibleName ?role () =
        { nodeId; backendNodeId; objectId; accessibleName; role }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Accessibility.queryAXTree"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Animation = struct
  (* Disables animation domain notifications. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Animation.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables animation domain notifications. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Animation.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the current time of the an animation. *)
  module GetCurrentTime = struct
    module Response : sig
      type result = {
        currentTime : Types.number;
            [@key "currentTime"] [@ocaml.doc "Current time of the page."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        currentTime : Types.number;
            [@key "currentTime"] [@ocaml.doc "Current time of the page."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = { id : string [@key "id"] [@ocaml.doc "Id of animation."] }
      [@@deriving yojson]

      let make ~id () = { id }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.getCurrentTime"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Gets the playback rate of the document timeline. *)
  module GetPlaybackRate = struct
    module Response : sig
      type result = {
        playbackRate : Types.number;
            [@key "playbackRate"]
            [@ocaml.doc "Playback rate for animations on page."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        playbackRate : Types.number;
            [@key "playbackRate"]
            [@ocaml.doc "Playback rate for animations on page."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Animation.getPlaybackRate"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Releases a set of animations to no longer be manipulated. *)
  module ReleaseAnimations = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        animations : string list;
            [@key "animations"] [@ocaml.doc "List of animation ids to seek."]
      }
      [@@deriving yojson]

      let make ~animations () = { animations }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.releaseAnimations"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Gets the remote object of the Animation. *)
  module ResolveAnimation = struct
    module Response : sig
      type result = {
        remoteObject : Types.Runtime.RemoteObject.t;
            [@key "remoteObject"] [@ocaml.doc "Corresponding remote object."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        remoteObject : Types.Runtime.RemoteObject.t;
            [@key "remoteObject"] [@ocaml.doc "Corresponding remote object."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        animationId : string; [@key "animationId"] [@ocaml.doc "Animation id."]
      }
      [@@deriving yojson]

      let make ~animationId () = { animationId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.resolveAnimation"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Seek a set of animations to a particular time within each animation. *)
  module SeekAnimations = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        animations : string list;
            [@key "animations"] [@ocaml.doc "List of animation ids to seek."]
        currentTime : Types.number;
            [@key "currentTime"]
            [@ocaml.doc "Set the current time of each animation."]
      }
      [@@deriving yojson]

      let make ~animations ~currentTime () = { animations; currentTime }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.seekAnimations"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets the paused state of a set of animations. *)
  module SetPaused = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        animations : string list;
            [@key "animations"]
            [@ocaml.doc "Animations to set the pause state of."]
        paused : bool; [@key "paused"] [@ocaml.doc "Paused state to set to."]
      }
      [@@deriving yojson]

      let make ~animations ~paused () = { animations; paused }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.setPaused"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets the playback rate of the document timeline. *)
  module SetPlaybackRate = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        playbackRate : Types.number;
            [@key "playbackRate"]
            [@ocaml.doc "Playback rate for animations on page"]
      }
      [@@deriving yojson]

      let make ~playbackRate () = { playbackRate }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.setPlaybackRate"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets the timing of an animation node. *)
  module SetTiming = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        animationId : string; [@key "animationId"] [@ocaml.doc "Animation id."]
        duration : Types.number;
            [@key "duration"] [@ocaml.doc "Duration of the animation."]
        delay : Types.number;
            [@key "delay"] [@ocaml.doc "Delay of the animation."]
      }
      [@@deriving yojson]

      let make ~animationId ~duration ~delay () =
        { animationId; duration; delay }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.setTiming"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Audits = struct
  (* Returns the response body and size if it were re-encoded with the specified settings. Only
     applies to images. *)
  module GetEncodedResponse = struct
    module Response : sig
      type result = {
        body : string option;
            [@key "body"]
            [@yojson.option]
            [@ocaml.doc
              "The encoded body as a base64 string. Omitted if sizeOnly is \
               true. (Encoded as a base64 string when passed over JSON)"]
        originalSize : Types.number;
            [@key "originalSize"] [@ocaml.doc "Size before re-encoding."]
        encodedSize : Types.number;
            [@key "encodedSize"] [@ocaml.doc "Size after re-encoding."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        body : string option;
            [@key "body"]
            [@yojson.option]
            [@ocaml.doc
              "The encoded body as a base64 string. Omitted if sizeOnly is \
               true. (Encoded as a base64 string when passed over JSON)"]
        originalSize : Types.number;
            [@key "originalSize"] [@ocaml.doc "Size before re-encoding."]
        encodedSize : Types.number;
            [@key "encodedSize"] [@ocaml.doc "Size after re-encoding."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type getencodedresponse_encoding = [ `webp | `jpeg | `png ]

      let getencodedresponse_encoding_of_yojson = function
        | `String "webp" -> `webp
        | `String "jpeg" -> `jpeg
        | `String "png" -> `png
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_getencodedresponse_encoding = function
        | `webp -> `String "webp"
        | `jpeg -> `String "jpeg"
        | `png -> `String "png"

      type t = {
        requestId : Types.Network.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "Identifier of the network request to get content for."]
        encoding : getencodedresponse_encoding;
            [@key "encoding"] [@ocaml.doc "The encoding to use."]
        quality : Types.number option;
            [@key "quality"]
            [@yojson.option]
            [@ocaml.doc "The quality of the encoding (0-1). (defaults to 1)"]
        sizeOnly : bool option;
            [@key "sizeOnly"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to only return the size information (defaults to false)."]
      }
      [@@deriving yojson]

      let make ~requestId ~encoding ?quality ?sizeOnly () =
        { requestId; encoding; quality; sizeOnly }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Audits.getEncodedResponse"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables issues domain, prevents further issues from being reported to the client. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Audits.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables issues domain, sends the issues collected so far to the client by means of the
     `issueAdded` event. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Audits.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Runs the contrast check for the target page. Found issues are reported
     using Audits.issueAdded event. *)
  module CheckContrast = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        reportAAA : bool option;
            [@key "reportAAA"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to report WCAG AAA level issues. Default is false."]
      }
      [@@deriving yojson]

      let make ?reportAAA () = { reportAAA }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Audits.checkContrast"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module BackgroundService = struct
  (* Enables event updates for the service. *)
  module StartObserving = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        service : Types.BackgroundService.ServiceName.t;
            [@key "service"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~service () = { service }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "BackgroundService.startObserving"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables event updates for the service. *)
  module StopObserving = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        service : Types.BackgroundService.ServiceName.t;
            [@key "service"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~service () = { service }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "BackgroundService.stopObserving"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Set the recording state for the service. *)
  module SetRecording = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        shouldRecord : bool;
            [@key "shouldRecord"] [@ocaml.doc "No description provided"]
        service : Types.BackgroundService.ServiceName.t;
            [@key "service"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~shouldRecord ~service () = { shouldRecord; service }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "BackgroundService.setRecording"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears all stored data for the service. *)
  module ClearEvents = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        service : Types.BackgroundService.ServiceName.t;
            [@key "service"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~service () = { service }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "BackgroundService.clearEvents"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Browser = struct
  (* Set permission settings for given origin. *)
  module SetPermission = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        permission : Types.Browser.PermissionDescriptor.t;
            [@key "permission"]
            [@ocaml.doc "Descriptor of permission to override."]
        setting : Types.Browser.PermissionSetting.t;
            [@key "setting"] [@ocaml.doc "Setting of the permission."]
        origin : string option;
            [@key "origin"]
            [@yojson.option]
            [@ocaml.doc
              "Origin the permission applies to, all origins if not specified."]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Context to override. When omitted, default browser context is \
               used."]
      }
      [@@deriving yojson]

      let make ~permission ~setting ?origin ?browserContextId () =
        { permission; setting; origin; browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.setPermission"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Grant specific permissions to the given origin and reject all others. *)
  module GrantPermissions = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        permissions : Types.Browser.PermissionType.t list;
            [@key "permissions"] [@ocaml.doc "No description provided"]
        origin : string option;
            [@key "origin"]
            [@yojson.option]
            [@ocaml.doc
              "Origin the permission applies to, all origins if not specified."]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "BrowserContext to override permissions. When omitted, default \
               browser context is used."]
      }
      [@@deriving yojson]

      let make ~permissions ?origin ?browserContextId () =
        { permissions; origin; browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.grantPermissions"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Reset all permission management for all origins. *)
  module ResetPermissions = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "BrowserContext to reset permissions. When omitted, default \
               browser context is used."]
      }
      [@@deriving yojson]

      let make ?browserContextId () = { browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.resetPermissions"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Set the behavior when downloading a file. *)
  module SetDownloadBehavior = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setdownloadbehavior_behavior =
        [ `deny | `allow | `allowAndName | `default ]

      let setdownloadbehavior_behavior_of_yojson = function
        | `String "deny" -> `deny
        | `String "allow" -> `allow
        | `String "allowAndName" -> `allowAndName
        | `String "default" -> `default
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setdownloadbehavior_behavior = function
        | `deny -> `String "deny"
        | `allow -> `String "allow"
        | `allowAndName -> `String "allowAndName"
        | `default -> `String "default"

      type t = {
        behavior : setdownloadbehavior_behavior;
            [@key "behavior"]
            [@ocaml.doc
              "Whether to allow all or deny all download requests, or use \
               default Chrome behavior if\n\
               available (otherwise deny). |allowAndName| allows download and \
               names files according to\n\
               their dowmload guids."]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "BrowserContext to set download behavior. When omitted, default \
               browser context is used."]
        downloadPath : string option;
            [@key "downloadPath"]
            [@yojson.option]
            [@ocaml.doc
              "The default path to save downloaded files to. This is required \
               if behavior is set to 'allow'\n\
               or 'allowAndName'."]
        eventsEnabled : bool option;
            [@key "eventsEnabled"]
            [@yojson.option]
            [@ocaml.doc "Whether to emit download events (defaults to false)."]
      }
      [@@deriving yojson]

      let make ~behavior ?browserContextId ?downloadPath ?eventsEnabled () =
        { behavior; browserContextId; downloadPath; eventsEnabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.setDownloadBehavior"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Cancel a download if in progress *)
  module CancelDownload = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        guid : string;
            [@key "guid"]
            [@ocaml.doc "Global unique identifier of the download."]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "BrowserContext to perform the action in. When omitted, default \
               browser context is used."]
      }
      [@@deriving yojson]

      let make ~guid ?browserContextId () = { guid; browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.cancelDownload"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Close browser gracefully. *)
  module Close = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Browser.close"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Crashes browser on the main thread. *)
  module Crash = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Browser.crash"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Crashes GPU process. *)
  module CrashGpuProcess = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Browser.crashGpuProcess"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns version information. *)
  module GetVersion = struct
    module Response : sig
      type result = {
        protocolVersion : string;
            [@key "protocolVersion"] [@ocaml.doc "Protocol version."]
        product : string; [@key "product"] [@ocaml.doc "Product name."]
        revision : string; [@key "revision"] [@ocaml.doc "Product revision."]
        userAgent : string; [@key "userAgent"] [@ocaml.doc "User-Agent."]
        jsVersion : string; [@key "jsVersion"] [@ocaml.doc "V8 version."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        protocolVersion : string;
            [@key "protocolVersion"] [@ocaml.doc "Protocol version."]
        product : string; [@key "product"] [@ocaml.doc "Product name."]
        revision : string; [@key "revision"] [@ocaml.doc "Product revision."]
        userAgent : string; [@key "userAgent"] [@ocaml.doc "User-Agent."]
        jsVersion : string; [@key "jsVersion"] [@ocaml.doc "V8 version."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Browser.getVersion"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the command line switches for the browser process if, and only if
     --enable-automation is on the commandline. *)
  module GetBrowserCommandLine = struct
    module Response : sig
      type result = {
        arguments : string list;
            [@key "arguments"] [@ocaml.doc "Commandline parameters"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        arguments : string list;
            [@key "arguments"] [@ocaml.doc "Commandline parameters"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Browser.getBrowserCommandLine"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Get Chrome histograms. *)
  module GetHistograms = struct
    module Response : sig
      type result = {
        histograms : Types.Browser.Histogram.t list;
            [@key "histograms"] [@ocaml.doc "Histograms."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        histograms : Types.Browser.Histogram.t list;
            [@key "histograms"] [@ocaml.doc "Histograms."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        query : string option;
            [@key "query"]
            [@yojson.option]
            [@ocaml.doc
              "Requested substring in name. Only histograms which have query \
               as a\n\
               substring in their name are extracted. An empty or absent query \
               returns\n\
               all histograms."]
        delta : bool option;
            [@key "delta"]
            [@yojson.option]
            [@ocaml.doc "If true, retrieve delta since last delta call."]
      }
      [@@deriving yojson]

      let make ?query ?delta () = { query; delta }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.getHistograms"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Get a Chrome histogram by name. *)
  module GetHistogram = struct
    module Response : sig
      type result = {
        histogram : Types.Browser.Histogram.t;
            [@key "histogram"] [@ocaml.doc "Histogram."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        histogram : Types.Browser.Histogram.t;
            [@key "histogram"] [@ocaml.doc "Histogram."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        name : string; [@key "name"] [@ocaml.doc "Requested histogram name."]
        delta : bool option;
            [@key "delta"]
            [@yojson.option]
            [@ocaml.doc "If true, retrieve delta since last delta call."]
      }
      [@@deriving yojson]

      let make ~name ?delta () = { name; delta }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.getHistogram"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Get position and size of the browser window. *)
  module GetWindowBounds = struct
    module Response : sig
      type result = {
        bounds : Types.Browser.Bounds.t;
            [@key "bounds"]
            [@ocaml.doc
              "Bounds information of the window. When window state is \
               'minimized', the restored window\n\
               position and size are returned."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        bounds : Types.Browser.Bounds.t;
            [@key "bounds"]
            [@ocaml.doc
              "Bounds information of the window. When window state is \
               'minimized', the restored window\n\
               position and size are returned."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        windowId : Types.Browser.WindowID.t;
            [@key "windowId"] [@ocaml.doc "Browser window id."]
      }
      [@@deriving yojson]

      let make ~windowId () = { windowId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.getWindowBounds"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Get the browser window that contains the devtools target. *)
  module GetWindowForTarget = struct
    module Response : sig
      type result = {
        windowId : Types.Browser.WindowID.t;
            [@key "windowId"] [@ocaml.doc "Browser window id."]
        bounds : Types.Browser.Bounds.t;
            [@key "bounds"]
            [@ocaml.doc
              "Bounds information of the window. When window state is \
               'minimized', the restored window\n\
               position and size are returned."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        windowId : Types.Browser.WindowID.t;
            [@key "windowId"] [@ocaml.doc "Browser window id."]
        bounds : Types.Browser.Bounds.t;
            [@key "bounds"]
            [@ocaml.doc
              "Bounds information of the window. When window state is \
               'minimized', the restored window\n\
               position and size are returned."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t option;
            [@key "targetId"]
            [@yojson.option]
            [@ocaml.doc
              "Devtools agent host id. If called as a part of the session, \
               associated targetId is used."]
      }
      [@@deriving yojson]

      let make ?targetId () = { targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.getWindowForTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Set position and/or size of the browser window. *)
  module SetWindowBounds = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        windowId : Types.Browser.WindowID.t;
            [@key "windowId"] [@ocaml.doc "Browser window id."]
        bounds : Types.Browser.Bounds.t;
            [@key "bounds"]
            [@ocaml.doc
              "New window bounds. The 'minimized', 'maximized' and \
               'fullscreen' states cannot be combined\n\
               with 'left', 'top', 'width' or 'height'. Leaves unspecified \
               fields unchanged."]
      }
      [@@deriving yojson]

      let make ~windowId ~bounds () = { windowId; bounds }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.setWindowBounds"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Set dock tile details, platform-specific. *)
  module SetDockTile = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        badgeLabel : string option;
            [@key "badgeLabel"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        image : string option;
            [@key "image"]
            [@yojson.option]
            [@ocaml.doc
              "Png encoded image. (Encoded as a base64 string when passed over \
               JSON)"]
      }
      [@@deriving yojson]

      let make ?badgeLabel ?image () = { badgeLabel; image }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.setDockTile"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Invoke custom browser commands used by telemetry. *)
  module ExecuteBrowserCommand = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        commandId : Types.Browser.BrowserCommandId.t;
            [@key "commandId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~commandId () = { commandId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.executeBrowserCommand"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module CSS = struct
  (* Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
     position specified by `location`. *)
  module AddRule = struct
    module Response : sig
      type result = {
        rule : Types.CSS.CSSRule.t;
            [@key "rule"] [@ocaml.doc "The newly created rule."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        rule : Types.CSS.CSSRule.t;
            [@key "rule"] [@ocaml.doc "The newly created rule."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.CSS.StyleSheetId.t;
            [@key "styleSheetId"]
            [@ocaml.doc
              "The css style sheet identifier where a new rule should be \
               inserted."]
        ruleText : string;
            [@key "ruleText"] [@ocaml.doc "The text of a new rule."]
        location : Types.CSS.SourceRange.t;
            [@key "location"]
            [@ocaml.doc
              "Text position of a new rule in the target style sheet."]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~ruleText ~location () =
        { styleSheetId; ruleText; location }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.addRule"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns all class names from specified stylesheet. *)
  module CollectClassNames = struct
    module Response : sig
      type result = {
        classNames : string list;
            [@key "classNames"] [@ocaml.doc "Class name list."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        classNames : string list;
            [@key "classNames"] [@ocaml.doc "Class name list."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.CSS.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId () = { styleSheetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.collectClassNames"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Creates a new special "via-inspector" stylesheet in the frame with given `frameId`. *)
  module CreateStyleSheet = struct
    module Response : sig
      type result = {
        styleSheetId : Types.CSS.StyleSheetId.t;
            [@key "styleSheetId"]
            [@ocaml.doc
              "Identifier of the created \"via-inspector\" stylesheet."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        styleSheetId : Types.CSS.StyleSheetId.t;
            [@key "styleSheetId"]
            [@ocaml.doc
              "Identifier of the created \"via-inspector\" stylesheet."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"]
            [@ocaml.doc
              "Identifier of the frame where \"via-inspector\" stylesheet \
               should be created."]
      }
      [@@deriving yojson]

      let make ~frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.createStyleSheet"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables the CSS agent for the given page. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
     enabled until the result of this command is received. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Ensures that the given node will have specified pseudo-classes whenever its style is computed by
     the browser. *)
  module ForcePseudoState = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "The element id for which to force the pseudo state."]
        forcedPseudoClasses : string list;
            [@key "forcedPseudoClasses"]
            [@ocaml.doc
              "Element pseudo classes to force when computing the element's \
               style."]
      }
      [@@deriving yojson]

      let make ~nodeId ~forcedPseudoClasses () = { nodeId; forcedPseudoClasses }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.forcePseudoState"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module GetBackgroundColors = struct
    module Response : sig
      type result = {
        backgroundColors : string list option;
            [@key "backgroundColors"]
            [@yojson.option]
            [@ocaml.doc
              "The range of background colors behind this element, if it \
               contains any visible text. If no\n\
               visible text is present, this will be undefined. In the case of \
               a flat background color,\n\
               this will consist of simply that color. In the case of a \
               gradient, this will consist of each\n\
               of the color stops. For anything more complicated, this will be \
               an empty array. Images will\n\
               be ignored (as if the image had failed to load)."]
        computedFontSize : string option;
            [@key "computedFontSize"]
            [@yojson.option]
            [@ocaml.doc
              "The computed font size for this node, as a CSS computed value \
               string (e.g. '12px')."]
        computedFontWeight : string option;
            [@key "computedFontWeight"]
            [@yojson.option]
            [@ocaml.doc
              "The computed font weight for this node, as a CSS computed value \
               string (e.g. 'normal' or\n\
               '100')."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        backgroundColors : string list option;
            [@key "backgroundColors"]
            [@yojson.option]
            [@ocaml.doc
              "The range of background colors behind this element, if it \
               contains any visible text. If no\n\
               visible text is present, this will be undefined. In the case of \
               a flat background color,\n\
               this will consist of simply that color. In the case of a \
               gradient, this will consist of each\n\
               of the color stops. For anything more complicated, this will be \
               an empty array. Images will\n\
               be ignored (as if the image had failed to load)."]
        computedFontSize : string option;
            [@key "computedFontSize"]
            [@yojson.option]
            [@ocaml.doc
              "The computed font size for this node, as a CSS computed value \
               string (e.g. '12px')."]
        computedFontWeight : string option;
            [@key "computedFontWeight"]
            [@yojson.option]
            [@ocaml.doc
              "The computed font weight for this node, as a CSS computed value \
               string (e.g. 'normal' or\n\
               '100')."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the node to get background colors for."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getBackgroundColors"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the computed style for a DOM node identified by `nodeId`. *)
  module GetComputedStyleForNode = struct
    module Response : sig
      type result = {
        computedStyle : Types.CSS.CSSComputedStyleProperty.t list;
            [@key "computedStyle"]
            [@ocaml.doc "Computed style for the specified DOM node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        computedStyle : Types.CSS.CSSComputedStyleProperty.t list;
            [@key "computedStyle"]
            [@ocaml.doc "Computed style for the specified DOM node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getComputedStyleForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
     attributes) for a DOM node identified by `nodeId`. *)
  module GetInlineStylesForNode = struct
    module Response : sig
      type result = {
        inlineStyle : Types.CSS.CSSStyle.t option;
            [@key "inlineStyle"]
            [@yojson.option]
            [@ocaml.doc "Inline style for the specified DOM node."]
        attributesStyle : Types.CSS.CSSStyle.t option;
            [@key "attributesStyle"]
            [@yojson.option]
            [@ocaml.doc
              "Attribute-defined element style (e.g. resulting from \"width=20 \
               height=100%\")."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        inlineStyle : Types.CSS.CSSStyle.t option;
            [@key "inlineStyle"]
            [@yojson.option]
            [@ocaml.doc "Inline style for the specified DOM node."]
        attributesStyle : Types.CSS.CSSStyle.t option;
            [@key "attributesStyle"]
            [@yojson.option]
            [@ocaml.doc
              "Attribute-defined element style (e.g. resulting from \"width=20 \
               height=100%\")."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getInlineStylesForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns requested styles for a DOM node identified by `nodeId`. *)
  module GetMatchedStylesForNode = struct
    module Response : sig
      type result = {
        inlineStyle : Types.CSS.CSSStyle.t option;
            [@key "inlineStyle"]
            [@yojson.option]
            [@ocaml.doc "Inline style for the specified DOM node."]
        attributesStyle : Types.CSS.CSSStyle.t option;
            [@key "attributesStyle"]
            [@yojson.option]
            [@ocaml.doc
              "Attribute-defined element style (e.g. resulting from \"width=20 \
               height=100%\")."]
        matchedCSSRules : Types.CSS.RuleMatch.t list option;
            [@key "matchedCSSRules"]
            [@yojson.option]
            [@ocaml.doc
              "CSS rules matching this node, from all applicable stylesheets."]
        pseudoElements : Types.CSS.PseudoElementMatches.t list option;
            [@key "pseudoElements"]
            [@yojson.option]
            [@ocaml.doc "Pseudo style matches for this node."]
        inherited : Types.CSS.InheritedStyleEntry.t list option;
            [@key "inherited"]
            [@yojson.option]
            [@ocaml.doc
              "A chain of inherited styles (from the immediate node parent up \
               to the DOM tree root)."]
        inheritedPseudoElements :
          Types.CSS.InheritedPseudoElementMatches.t list option;
            [@key "inheritedPseudoElements"]
            [@yojson.option]
            [@ocaml.doc
              "A chain of inherited pseudo element styles (from the immediate \
               node parent up to the DOM tree root)."]
        cssKeyframesRules : Types.CSS.CSSKeyframesRule.t list option;
            [@key "cssKeyframesRules"]
            [@yojson.option]
            [@ocaml.doc
              "A list of CSS keyframed animations matching this node."]
        parentLayoutNodeId : Types.DOM.NodeId.t option;
            [@key "parentLayoutNodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Id of the first parent element that does not have display: \
               contents."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        inlineStyle : Types.CSS.CSSStyle.t option;
            [@key "inlineStyle"]
            [@yojson.option]
            [@ocaml.doc "Inline style for the specified DOM node."]
        attributesStyle : Types.CSS.CSSStyle.t option;
            [@key "attributesStyle"]
            [@yojson.option]
            [@ocaml.doc
              "Attribute-defined element style (e.g. resulting from \"width=20 \
               height=100%\")."]
        matchedCSSRules : Types.CSS.RuleMatch.t list option;
            [@key "matchedCSSRules"]
            [@yojson.option]
            [@ocaml.doc
              "CSS rules matching this node, from all applicable stylesheets."]
        pseudoElements : Types.CSS.PseudoElementMatches.t list option;
            [@key "pseudoElements"]
            [@yojson.option]
            [@ocaml.doc "Pseudo style matches for this node."]
        inherited : Types.CSS.InheritedStyleEntry.t list option;
            [@key "inherited"]
            [@yojson.option]
            [@ocaml.doc
              "A chain of inherited styles (from the immediate node parent up \
               to the DOM tree root)."]
        inheritedPseudoElements :
          Types.CSS.InheritedPseudoElementMatches.t list option;
            [@key "inheritedPseudoElements"]
            [@yojson.option]
            [@ocaml.doc
              "A chain of inherited pseudo element styles (from the immediate \
               node parent up to the DOM tree root)."]
        cssKeyframesRules : Types.CSS.CSSKeyframesRule.t list option;
            [@key "cssKeyframesRules"]
            [@yojson.option]
            [@ocaml.doc
              "A list of CSS keyframed animations matching this node."]
        parentLayoutNodeId : Types.DOM.NodeId.t option;
            [@key "parentLayoutNodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Id of the first parent element that does not have display: \
               contents."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getMatchedStylesForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns all media queries parsed by the rendering engine. *)
  module GetMediaQueries = struct
    module Response : sig
      type result = {
        medias : Types.CSS.CSSMedia.t list;
            [@key "medias"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        medias : Types.CSS.CSSMedia.t list;
            [@key "medias"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.getMediaQueries"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests information about platform fonts which we used to render child TextNodes in the given
     node. *)
  module GetPlatformFontsForNode = struct
    module Response : sig
      type result = {
        fonts : Types.CSS.PlatformFontUsage.t list;
            [@key "fonts"]
            [@ocaml.doc "Usage statistics for every employed platform font."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        fonts : Types.CSS.PlatformFontUsage.t list;
            [@key "fonts"]
            [@ocaml.doc "Usage statistics for every employed platform font."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getPlatformFontsForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the current textual content for a stylesheet. *)
  module GetStyleSheetText = struct
    module Response : sig
      type result = {
        text : string; [@key "text"] [@ocaml.doc "The stylesheet text."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        text : string; [@key "text"] [@ocaml.doc "The stylesheet text."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.CSS.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId () = { styleSheetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getStyleSheetText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns all layers parsed by the rendering engine for the tree scope of a node.
     Given a DOM element identified by nodeId, getLayersForNode returns the root
     layer for the nearest ancestor document or shadow root. The layer root contains
     the full layer tree for the tree scope and their ordering. *)
  module GetLayersForNode = struct
    module Response : sig
      type result = {
        rootLayer : Types.CSS.CSSLayerData.t;
            [@key "rootLayer"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        rootLayer : Types.CSS.CSSLayerData.t;
            [@key "rootLayer"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getLayersForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Starts tracking the given computed styles for updates. The specified array of properties
     replaces the one previously specified. Pass empty array to disable tracking.
     Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
     The changes to computed style properties are only tracked for nodes pushed to the front-end
     by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
     to the front-end, no updates will be issued for the node. *)
  module TrackComputedStyleUpdates = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        propertiesToTrack : Types.CSS.CSSComputedStyleProperty.t list;
            [@key "propertiesToTrack"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~propertiesToTrack () = { propertiesToTrack }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.trackComputedStyleUpdates"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Polls the next batch of computed style updates. *)
  module TakeComputedStyleUpdates = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "The list of node Ids that have their tracked computed styles \
               updated."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "The list of node Ids that have their tracked computed styles \
               updated."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.takeComputedStyleUpdates"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Find a rule with the given active property for the given node and set the new value for this
     property *)
  module SetEffectivePropertyValueForNode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "The element id for which to set property."]
        propertyName : string;
            [@key "propertyName"] [@ocaml.doc "No description provided"]
        value : string; [@key "value"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId ~propertyName ~value () = { nodeId; propertyName; value }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "CSS.setEffectivePropertyValueForNode";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Modifies the keyframe rule key text. *)
  module SetKeyframeKey = struct
    module Response : sig
      type result = {
        keyText : Types.CSS.Value.t;
            [@key "keyText"]
            [@ocaml.doc "The resulting key text after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        keyText : Types.CSS.Value.t;
            [@key "keyText"]
            [@ocaml.doc "The resulting key text after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.CSS.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        keyText : string; [@key "keyText"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~keyText () =
        { styleSheetId; range; keyText }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setKeyframeKey"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Modifies the rule selector. *)
  module SetMediaText = struct
    module Response : sig
      type result = {
        media : Types.CSS.CSSMedia.t;
            [@key "media"]
            [@ocaml.doc "The resulting CSS media rule after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        media : Types.CSS.CSSMedia.t;
            [@key "media"]
            [@ocaml.doc "The resulting CSS media rule after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.CSS.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        text : string; [@key "text"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~text () = { styleSheetId; range; text }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setMediaText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Modifies the expression of a container query. *)
  module SetContainerQueryText = struct
    module Response : sig
      type result = {
        containerQuery : Types.CSS.CSSContainerQuery.t;
            [@key "containerQuery"]
            [@ocaml.doc
              "The resulting CSS container query rule after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        containerQuery : Types.CSS.CSSContainerQuery.t;
            [@key "containerQuery"]
            [@ocaml.doc
              "The resulting CSS container query rule after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.CSS.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        text : string; [@key "text"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~text () = { styleSheetId; range; text }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setContainerQueryText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Modifies the expression of a supports at-rule. *)
  module SetSupportsText = struct
    module Response : sig
      type result = {
        supports : Types.CSS.CSSSupports.t;
            [@key "supports"]
            [@ocaml.doc "The resulting CSS Supports rule after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        supports : Types.CSS.CSSSupports.t;
            [@key "supports"]
            [@ocaml.doc "The resulting CSS Supports rule after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.CSS.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        text : string; [@key "text"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~text () = { styleSheetId; range; text }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setSupportsText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Modifies the expression of a scope at-rule. *)
  module SetScopeText = struct
    module Response : sig
      type result = {
        scope : Types.CSS.CSSScope.t;
            [@key "scope"]
            [@ocaml.doc "The resulting CSS Scope rule after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        scope : Types.CSS.CSSScope.t;
            [@key "scope"]
            [@ocaml.doc "The resulting CSS Scope rule after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.CSS.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        text : string; [@key "text"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~text () = { styleSheetId; range; text }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setScopeText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Modifies the rule selector. *)
  module SetRuleSelector = struct
    module Response : sig
      type result = {
        selectorList : Types.CSS.SelectorList.t;
            [@key "selectorList"]
            [@ocaml.doc "The resulting selector list after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        selectorList : Types.CSS.SelectorList.t;
            [@key "selectorList"]
            [@ocaml.doc "The resulting selector list after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.CSS.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        selector : string;
            [@key "selector"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~selector () =
        { styleSheetId; range; selector }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setRuleSelector"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets the new stylesheet text. *)
  module SetStyleSheetText = struct
    module Response : sig
      type result = {
        sourceMapURL : string option;
            [@key "sourceMapURL"]
            [@yojson.option]
            [@ocaml.doc "URL of source map associated with script (if any)."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        sourceMapURL : string option;
            [@key "sourceMapURL"]
            [@yojson.option]
            [@ocaml.doc "URL of source map associated with script (if any)."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.CSS.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        text : string; [@key "text"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~text () = { styleSheetId; text }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setStyleSheetText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Applies specified style edits one after another in the given order. *)
  module SetStyleTexts = struct
    module Response : sig
      type result = {
        styles : Types.CSS.CSSStyle.t list;
            [@key "styles"]
            [@ocaml.doc "The resulting styles after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        styles : Types.CSS.CSSStyle.t list;
            [@key "styles"]
            [@ocaml.doc "The resulting styles after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        edits : Types.CSS.StyleDeclarationEdit.t list;
            [@key "edits"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~edits () = { edits }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setStyleTexts"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables the selector recording. *)
  module StartRuleUsageTracking = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.startRuleUsageTracking"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Stop tracking rule usage and return the list of rules that were used since last call to
     `takeCoverageDelta` (or since start of coverage instrumentation). *)
  module StopRuleUsageTracking = struct
    module Response : sig
      type result = {
        ruleUsage : Types.CSS.RuleUsage.t list;
            [@key "ruleUsage"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        ruleUsage : Types.CSS.RuleUsage.t list;
            [@key "ruleUsage"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.stopRuleUsageTracking"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Obtain list of rules that became used since last call to this method (or since start of coverage
     instrumentation). *)
  module TakeCoverageDelta = struct
    module Response : sig
      type result = {
        coverage : Types.CSS.RuleUsage.t list;
            [@key "coverage"] [@ocaml.doc "No description provided"]
        timestamp : Types.number;
            [@key "timestamp"]
            [@ocaml.doc "Monotonically increasing time, in seconds."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        coverage : Types.CSS.RuleUsage.t list;
            [@key "coverage"] [@ocaml.doc "No description provided"]
        timestamp : Types.number;
            [@key "timestamp"]
            [@ocaml.doc "Monotonically increasing time, in seconds."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.takeCoverageDelta"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables/disables rendering of local CSS fonts (enabled by default). *)
  module SetLocalFontsEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc "Whether rendering of local fonts is enabled."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setLocalFontsEnabled"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module CacheStorage = struct
  (* Deletes a cache. *)
  module DeleteCache = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cacheId : Types.CacheStorage.CacheId.t;
            [@key "cacheId"] [@ocaml.doc "Id of cache for deletion."]
      }
      [@@deriving yojson]

      let make ~cacheId () = { cacheId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CacheStorage.deleteCache"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Deletes a cache entry. *)
  module DeleteEntry = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cacheId : Types.CacheStorage.CacheId.t;
            [@key "cacheId"]
            [@ocaml.doc "Id of cache where the entry will be deleted."]
        request : string;
            [@key "request"] [@ocaml.doc "URL spec of the request."]
      }
      [@@deriving yojson]

      let make ~cacheId ~request () = { cacheId; request }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CacheStorage.deleteEntry"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests cache names. *)
  module RequestCacheNames = struct
    module Response : sig
      type result = {
        caches : Types.CacheStorage.Cache.t list;
            [@key "caches"] [@ocaml.doc "Caches for the security origin."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        caches : Types.CacheStorage.Cache.t list;
            [@key "caches"] [@ocaml.doc "Caches for the security origin."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey must be \
               specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey () = { securityOrigin; storageKey }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CacheStorage.requestCacheNames"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Fetches cache entry. *)
  module RequestCachedResponse = struct
    module Response : sig
      type result = {
        response : Types.CacheStorage.CachedResponse.t;
            [@key "response"] [@ocaml.doc "Response read from the cache."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        response : Types.CacheStorage.CachedResponse.t;
            [@key "response"] [@ocaml.doc "Response read from the cache."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cacheId : Types.CacheStorage.CacheId.t;
            [@key "cacheId"] [@ocaml.doc "Id of cache that contains the entry."]
        requestURL : string;
            [@key "requestURL"] [@ocaml.doc "URL spec of the request."]
        requestHeaders : Types.CacheStorage.Header.t list;
            [@key "requestHeaders"] [@ocaml.doc "headers of the request."]
      }
      [@@deriving yojson]

      let make ~cacheId ~requestURL ~requestHeaders () =
        { cacheId; requestURL; requestHeaders }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "CacheStorage.requestCachedResponse";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests data from cache. *)
  module RequestEntries = struct
    module Response : sig
      type result = {
        cacheDataEntries : Types.CacheStorage.DataEntry.t list;
            [@key "cacheDataEntries"]
            [@ocaml.doc "Array of object store data entries."]
        returnCount : Types.number;
            [@key "returnCount"]
            [@ocaml.doc
              "Count of returned entries from this storage. If pathFilter is \
               empty, it\n\
               is the count of all entries from this storage."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        cacheDataEntries : Types.CacheStorage.DataEntry.t list;
            [@key "cacheDataEntries"]
            [@ocaml.doc "Array of object store data entries."]
        returnCount : Types.number;
            [@key "returnCount"]
            [@ocaml.doc
              "Count of returned entries from this storage. If pathFilter is \
               empty, it\n\
               is the count of all entries from this storage."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cacheId : Types.CacheStorage.CacheId.t;
            [@key "cacheId"] [@ocaml.doc "ID of cache to get entries from."]
        skipCount : Types.number option;
            [@key "skipCount"]
            [@yojson.option]
            [@ocaml.doc "Number of records to skip."]
        pageSize : Types.number option;
            [@key "pageSize"]
            [@yojson.option]
            [@ocaml.doc "Number of records to fetch."]
        pathFilter : string option;
            [@key "pathFilter"]
            [@yojson.option]
            [@ocaml.doc
              "If present, only return the entries containing this substring \
               in the path"]
      }
      [@@deriving yojson]

      let make ~cacheId ?skipCount ?pageSize ?pathFilter () =
        { cacheId; skipCount; pageSize; pathFilter }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CacheStorage.requestEntries"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Cast = struct
  (* Starts observing for sinks that can be used for tab mirroring, and if set,
     sinks compatible with |presentationUrl| as well. When sinks are found, a
     |sinksUpdated| event is fired.
     Also starts observing for issue messages. When an issue is added or removed,
     an |issueUpdated| event is fired. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        presentationUrl : string option;
            [@key "presentationUrl"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ?presentationUrl () = { presentationUrl }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Cast.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Stops observing for sinks and issues. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Cast.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets a sink to be used when the web page requests the browser to choose a
     sink via Presentation API, Remote Playback API, or Cast SDK. *)
  module SetSinkToUse = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sinkName : string;
            [@key "sinkName"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~sinkName () = { sinkName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Cast.setSinkToUse"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Starts mirroring the desktop to the sink. *)
  module StartDesktopMirroring = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sinkName : string;
            [@key "sinkName"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~sinkName () = { sinkName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Cast.startDesktopMirroring"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Starts mirroring the tab to the sink. *)
  module StartTabMirroring = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sinkName : string;
            [@key "sinkName"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~sinkName () = { sinkName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Cast.startTabMirroring"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Stops the active Cast session on the sink. *)
  module StopCasting = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sinkName : string;
            [@key "sinkName"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~sinkName () = { sinkName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Cast.stopCasting"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module DOM = struct
  (* Collects class names for the node with given id and all of it's child nodes. *)
  module CollectClassNamesFromSubtree = struct
    module Response : sig
      type result = {
        classNames : string list;
            [@key "classNames"] [@ocaml.doc "Class name list."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        classNames : string list;
            [@key "classNames"] [@ocaml.doc "Class name list."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the node to collect class names."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.collectClassNamesFromSubtree"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Creates a deep copy of the specified node and places it into the target container before the
     given anchor. *)
  module CopyTo = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node clone."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node clone."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to copy."]
        targetNodeId : Types.DOM.NodeId.t;
            [@key "targetNodeId"]
            [@ocaml.doc "Id of the element to drop the copy into."]
        insertBeforeNodeId : Types.DOM.NodeId.t option;
            [@key "insertBeforeNodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Drop the copy before this node (if absent, the copy becomes the \
               last child of\n\
               `targetNodeId`)."]
      }
      [@@deriving yojson]

      let make ~nodeId ~targetNodeId ?insertBeforeNodeId () =
        { nodeId; targetNodeId; insertBeforeNodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.copyTo"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Describes node given its id, does not require domain to be enabled. Does not start tracking any
     objects, can be used for automation. *)
  module DescribeNode = struct
    module Response : sig
      type result = {
        node : Types.DOM.Node.t; [@key "node"] [@ocaml.doc "Node description."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        node : Types.DOM.Node.t; [@key "node"] [@ocaml.doc "Node description."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
        depth : Types.number option;
            [@key "depth"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum depth at which children should be retrieved, \
               defaults to 1. Use -1 for the\n\
               entire subtree or provide an integer larger than 0."]
        pierce : bool option;
            [@key "pierce"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not iframes and shadow roots should be traversed \
               when returning the subtree\n\
               (default is false)."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId ?depth ?pierce () =
        { nodeId; backendNodeId; objectId; depth; pierce }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.describeNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Scrolls the specified rect of the given node into view if not already visible.
     Note: exactly one between nodeId, backendNodeId and objectId should be passed
     to identify the node. *)
  module ScrollIntoViewIfNeeded = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
        rect : Types.DOM.Rect.t option;
            [@key "rect"]
            [@yojson.option]
            [@ocaml.doc
              "The rect to be scrolled into view, relative to the node's \
               border box, in CSS pixels.\n\
               When omitted, center of the node will be used, similar to \
               Element.scrollIntoView."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId ?rect () =
        { nodeId; backendNodeId; objectId; rect }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.scrollIntoViewIfNeeded"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables DOM agent for the given page. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Discards search results from the session with the given id. `getSearchResults` should no longer
     be called for that search. *)
  module DiscardSearchResults = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        searchId : string;
            [@key "searchId"] [@ocaml.doc "Unique search session identifier."]
      }
      [@@deriving yojson]

      let make ~searchId () = { searchId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.discardSearchResults"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables DOM agent for the given page. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type enable_includewhitespace = [ `none | `all ]

      let enable_includewhitespace_of_yojson = function
        | `String "none" -> `none
        | `String "all" -> `all
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_enable_includewhitespace = function
        | `none -> `String "none"
        | `all -> `String "all"

      type t = {
        includeWhitespace : enable_includewhitespace option;
            [@key "includeWhitespace"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include whitespaces in the children array of \
               returned Nodes."]
      }
      [@@deriving yojson]

      let make ?includeWhitespace () = { includeWhitespace }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Focuses the given element. *)
  module Focus = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId () =
        { nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.focus"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns attributes for the specified node. *)
  module GetAttributes = struct
    module Response : sig
      type result = {
        attributes : string list;
            [@key "attributes"]
            [@ocaml.doc
              "An interleaved array of node attribute names and values."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        attributes : string list;
            [@key "attributes"]
            [@ocaml.doc
              "An interleaved array of node attribute names and values."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the node to retrieve attibutes for."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getAttributes"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns boxes for the given node. *)
  module GetBoxModel = struct
    module Response : sig
      type result = {
        model : Types.DOM.BoxModel.t;
            [@key "model"] [@ocaml.doc "Box model for the node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        model : Types.DOM.BoxModel.t;
            [@key "model"] [@ocaml.doc "Box model for the node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId () =
        { nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getBoxModel"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns quads that describe node position on the page. This method
     might return multiple quads for inline nodes. *)
  module GetContentQuads = struct
    module Response : sig
      type result = {
        quads : Types.DOM.Quad.t list;
            [@key "quads"]
            [@ocaml.doc "Quads that describe node layout relative to viewport."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        quads : Types.DOM.Quad.t list;
            [@key "quads"]
            [@ocaml.doc "Quads that describe node layout relative to viewport."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId () =
        { nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getContentQuads"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the root DOM node (and optionally the subtree) to the caller.
     Implicitly enables the DOM domain events for the current target. *)
  module GetDocument = struct
    module Response : sig
      type result = {
        root : Types.DOM.Node.t; [@key "root"] [@ocaml.doc "Resulting node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        root : Types.DOM.Node.t; [@key "root"] [@ocaml.doc "Resulting node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        depth : Types.number option;
            [@key "depth"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum depth at which children should be retrieved, \
               defaults to 1. Use -1 for the\n\
               entire subtree or provide an integer larger than 0."]
        pierce : bool option;
            [@key "pierce"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not iframes and shadow roots should be traversed \
               when returning the subtree\n\
               (default is false)."]
      }
      [@@deriving yojson]

      let make ?depth ?pierce () = { depth; pierce }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getDocument"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the root DOM node (and optionally the subtree) to the caller.
     Deprecated, as it is not designed to work well with the rest of the DOM agent.
     Use DOMSnapshot.captureSnapshot instead. *)
  module GetFlattenedDocument = struct
    module Response : sig
      type result = {
        nodes : Types.DOM.Node.t list;
            [@key "nodes"] [@ocaml.doc "Resulting node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodes : Types.DOM.Node.t list;
            [@key "nodes"] [@ocaml.doc "Resulting node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        depth : Types.number option;
            [@key "depth"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum depth at which children should be retrieved, \
               defaults to 1. Use -1 for the\n\
               entire subtree or provide an integer larger than 0."]
        pierce : bool option;
            [@key "pierce"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not iframes and shadow roots should be traversed \
               when returning the subtree\n\
               (default is false)."]
      }
      [@@deriving yojson]

      let make ?depth ?pierce () = { depth; pierce }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getFlattenedDocument"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Finds nodes with a given computed style in a subtree. *)
  module GetNodesForSubtreeByStyle = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "Resulting nodes."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "Resulting nodes."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Node ID pointing to the root of a subtree."]
        computedStyles : Types.DOM.CSSComputedStyleProperty.t list;
            [@key "computedStyles"]
            [@ocaml.doc
              "The style to filter nodes by (includes nodes if any of \
               properties matches)."]
        pierce : bool option;
            [@key "pierce"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not iframes and shadow roots in the same target \
               should be traversed when returning the\n\
               results (default is false)."]
      }
      [@@deriving yojson]

      let make ~nodeId ~computedStyles ?pierce () =
        { nodeId; computedStyles; pierce }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getNodesForSubtreeByStyle"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
     either returned or not. *)
  module GetNodeForLocation = struct
    module Response : sig
      type result = {
        backendNodeId : Types.DOM.BackendNodeId.t;
            [@key "backendNodeId"] [@ocaml.doc "Resulting node."]
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "Frame this node belongs to."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Id of the node at given coordinates, only when enabled and \
               requested document."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        backendNodeId : Types.DOM.BackendNodeId.t;
            [@key "backendNodeId"] [@ocaml.doc "Resulting node."]
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "Frame this node belongs to."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Id of the node at given coordinates, only when enabled and \
               requested document."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        x : Types.number; [@key "x"] [@ocaml.doc "X coordinate."]
        y : Types.number; [@key "y"] [@ocaml.doc "Y coordinate."]
        includeUserAgentShadowDOM : bool option;
            [@key "includeUserAgentShadowDOM"]
            [@yojson.option]
            [@ocaml.doc
              "False to skip to the nearest non-UA shadow root ancestor \
               (default: false)."]
        ignorePointerEventsNone : bool option;
            [@key "ignorePointerEventsNone"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to ignore pointer-events: none on elements and hit test \
               them."]
      }
      [@@deriving yojson]

      let make ~x ~y ?includeUserAgentShadowDOM ?ignorePointerEventsNone () =
        { x; y; includeUserAgentShadowDOM; ignorePointerEventsNone }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getNodeForLocation"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns node's HTML markup. *)
  module GetOuterHTML = struct
    module Response : sig
      type result = {
        outerHTML : string; [@key "outerHTML"] [@ocaml.doc "Outer HTML markup."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        outerHTML : string; [@key "outerHTML"] [@ocaml.doc "Outer HTML markup."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId () =
        { nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getOuterHTML"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the id of the nearest ancestor that is a relayout boundary. *)
  module GetRelayoutBoundary = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Relayout boundary node id for the given node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Relayout boundary node id for the given node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getRelayoutBoundary"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns search results from given `fromIndex` to given `toIndex` from the search with the given
     identifier. *)
  module GetSearchResults = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "Ids of the search result nodes."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "Ids of the search result nodes."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        searchId : string;
            [@key "searchId"] [@ocaml.doc "Unique search session identifier."]
        fromIndex : Types.number;
            [@key "fromIndex"]
            [@ocaml.doc "Start index of the search result to be returned."]
        toIndex : Types.number;
            [@key "toIndex"]
            [@ocaml.doc "End index of the search result to be returned."]
      }
      [@@deriving yojson]

      let make ~searchId ~fromIndex ~toIndex () =
        { searchId; fromIndex; toIndex }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getSearchResults"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Hides any highlight. *)
  module HideHighlight = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.hideHighlight"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Highlights DOM node. *)
  module HighlightNode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.highlightNode"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Highlights given rectangle. *)
  module HighlightRect = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.highlightRect"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Marks last undoable state. *)
  module MarkUndoableState = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.markUndoableState"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Moves node into the new container, places it before the given anchor. *)
  module MoveTo = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "New id of the moved node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "New id of the moved node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to move."]
        targetNodeId : Types.DOM.NodeId.t;
            [@key "targetNodeId"]
            [@ocaml.doc "Id of the element to drop the moved node into."]
        insertBeforeNodeId : Types.DOM.NodeId.t option;
            [@key "insertBeforeNodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Drop node before this one (if absent, the moved node becomes \
               the last child of\n\
               `targetNodeId`)."]
      }
      [@@deriving yojson]

      let make ~nodeId ~targetNodeId ?insertBeforeNodeId () =
        { nodeId; targetNodeId; insertBeforeNodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.moveTo"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
     `cancelSearch` to end this search session. *)
  module PerformSearch = struct
    module Response : sig
      type result = {
        searchId : string;
            [@key "searchId"] [@ocaml.doc "Unique search session identifier."]
        resultCount : Types.number;
            [@key "resultCount"] [@ocaml.doc "Number of search results."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        searchId : string;
            [@key "searchId"] [@ocaml.doc "Unique search session identifier."]
        resultCount : Types.number;
            [@key "resultCount"] [@ocaml.doc "Number of search results."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        query : string;
            [@key "query"]
            [@ocaml.doc "Plain text or query selector or XPath search query."]
        includeUserAgentShadowDOM : bool option;
            [@key "includeUserAgentShadowDOM"]
            [@yojson.option]
            [@ocaml.doc "True to search in user agent shadow DOM."]
      }
      [@@deriving yojson]

      let make ~query ?includeUserAgentShadowDOM () =
        { query; includeUserAgentShadowDOM }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.performSearch"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests that the node is sent to the caller given its path. // FIXME, use XPath *)
  module PushNodeByPathToFrontend = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node for given path."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node for given path."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        path : string;
            [@key "path"] [@ocaml.doc "Path to node in the proprietary format."]
      }
      [@@deriving yojson]

      let make ~path () = { path }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.pushNodeByPathToFrontend"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests that a batch of nodes is sent to the caller given their backend node ids. *)
  module PushNodesByBackendIdsToFrontend = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "The array of ids of pushed nodes that correspond to the backend \
               ids specified in\n\
               backendNodeIds."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "The array of ids of pushed nodes that correspond to the backend \
               ids specified in\n\
               backendNodeIds."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        backendNodeIds : Types.DOM.BackendNodeId.t list;
            [@key "backendNodeIds"]
            [@ocaml.doc "The array of backend node ids."]
      }
      [@@deriving yojson]

      let make ~backendNodeIds () = { backendNodeIds }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOM.pushNodesByBackendIdsToFrontend";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Executes `querySelector` on a given node. *)
  module QuerySelector = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Query selector result."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Query selector result."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to query upon."]
        selector : string; [@key "selector"] [@ocaml.doc "Selector string."]
      }
      [@@deriving yojson]

      let make ~nodeId ~selector () = { nodeId; selector }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.querySelector"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Executes `querySelectorAll` on a given node. *)
  module QuerySelectorAll = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "Query selector result."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "Query selector result."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to query upon."]
        selector : string; [@key "selector"] [@ocaml.doc "Selector string."]
      }
      [@@deriving yojson]

      let make ~nodeId ~selector () = { nodeId; selector }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.querySelectorAll"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns NodeIds of current top layer elements.
     Top layer is rendered closest to the user within a viewport, therefore its elements always
     appear on top of all other content. *)
  module GetTopLayerElements = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "NodeIds of top layer elements"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "NodeIds of top layer elements"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.getTopLayerElements"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Re-does the last undone action. *)
  module Redo = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.redo"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Removes attribute with given name from an element with given id. *)
  module RemoveAttribute = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the element to remove attribute from."]
        name : string;
            [@key "name"] [@ocaml.doc "Name of the attribute to remove."]
      }
      [@@deriving yojson]

      let make ~nodeId ~name () = { nodeId; name }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.removeAttribute"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Removes node with given id. *)
  module RemoveNode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to remove."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.removeNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests that children of the node with given id are returned to the caller in form of
     `setChildNodes` events where not only immediate children are retrieved, but all children down to
     the specified depth. *)
  module RequestChildNodes = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to get children for."]
        depth : Types.number option;
            [@key "depth"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum depth at which children should be retrieved, \
               defaults to 1. Use -1 for the\n\
               entire subtree or provide an integer larger than 0."]
        pierce : bool option;
            [@key "pierce"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not iframes and shadow roots should be traversed \
               when returning the sub-tree\n\
               (default is false)."]
      }
      [@@deriving yojson]

      let make ~nodeId ?depth ?pierce () = { nodeId; depth; pierce }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.requestChildNodes"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests that the node is sent to the caller given the JavaScript node object reference. All
     nodes that form the path from the node to the root are also sent to the client as a series of
     `setChildNodes` notifications. *)
  module RequestNode = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Node id for given object."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Node id for given object."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"]
            [@ocaml.doc "JavaScript object id to convert into node."]
      }
      [@@deriving yojson]

      let make ~objectId () = { objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.requestNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Resolves the JavaScript node object for a given NodeId or BackendNodeId. *)
  module ResolveNode = struct
    module Response : sig
      type result = {
        object_ : Types.Runtime.RemoteObject.t;
            [@key "object"]
            [@ocaml.doc "JavaScript object wrapper for given node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        object_ : Types.Runtime.RemoteObject.t;
            [@key "object"]
            [@ocaml.doc "JavaScript object wrapper for given node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Id of the node to resolve."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Backend identifier of the node to resolve."]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "Symbolic group name that can be used to release multiple \
               objects."]
        executionContextId : Types.Runtime.ExecutionContextId.t option;
            [@key "executionContextId"]
            [@yojson.option]
            [@ocaml.doc "Execution context in which to resolve the node."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectGroup ?executionContextId () =
        { nodeId; backendNodeId; objectGroup; executionContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.resolveNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets attribute for an element with given id. *)
  module SetAttributeValue = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the element to set attribute for."]
        name : string; [@key "name"] [@ocaml.doc "Attribute name."]
        value : string; [@key "value"] [@ocaml.doc "Attribute value."]
      }
      [@@deriving yojson]

      let make ~nodeId ~name ~value () = { nodeId; name; value }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setAttributeValue"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets attributes on element with given id. This method is useful when user edits some existing
     attribute value and types in several attribute name/value pairs. *)
  module SetAttributesAsText = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the element to set attributes for."]
        text : string;
            [@key "text"]
            [@ocaml.doc
              "Text with a number of attributes. Will parse this text using \
               HTML parser."]
        name : string option;
            [@key "name"]
            [@yojson.option]
            [@ocaml.doc
              "Attribute name to replace with new attributes derived from text \
               in case text parsed\n\
               successfully."]
      }
      [@@deriving yojson]

      let make ~nodeId ~text ?name () = { nodeId; text; name }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setAttributesAsText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets files for the given file input element. *)
  module SetFileInputFiles = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        files : string list;
            [@key "files"] [@ocaml.doc "Array of file paths to set."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
      }
      [@@deriving yojson]

      let make ~files ?nodeId ?backendNodeId ?objectId () =
        { files; nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setFileInputFiles"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled. *)
  module SetNodeStackTracesEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enable : bool; [@key "enable"] [@ocaml.doc "Enable or disable."]
      }
      [@@deriving yojson]

      let make ~enable () = { enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setNodeStackTracesEnabled"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation. *)
  module GetNodeStackTraces = struct
    module Response : sig
      type result = {
        creation : Types.Runtime.StackTrace.t option;
            [@key "creation"]
            [@yojson.option]
            [@ocaml.doc "Creation stack trace, if available."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        creation : Types.Runtime.StackTrace.t option;
            [@key "creation"]
            [@yojson.option]
            [@ocaml.doc "Creation stack trace, if available."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the node to get stack traces for."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getNodeStackTraces"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns file information for the given
     File wrapper. *)
  module GetFileInfo = struct
    module Response : sig
      type result = {
        path : string; [@key "path"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        path : string; [@key "path"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
      }
      [@@deriving yojson]

      let make ~objectId () = { objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getFileInfo"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables console to refer to the node with given id via $x (see Command Line API for more details
     $x functions). *)
  module SetInspectedNode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc
              "DOM node id to be accessible by means of $x command line API."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setInspectedNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets node name for a node with given id. *)
  module SetNodeName = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "New node's id."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "New node's id."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to set name for."]
        name : string; [@key "name"] [@ocaml.doc "New node's name."]
      }
      [@@deriving yojson]

      let make ~nodeId ~name () = { nodeId; name }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setNodeName"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets node value for a node with given id. *)
  module SetNodeValue = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to set value for."]
        value : string; [@key "value"] [@ocaml.doc "New node's value."]
      }
      [@@deriving yojson]

      let make ~nodeId ~value () = { nodeId; value }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setNodeValue"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets node HTML markup, returns new node id. *)
  module SetOuterHTML = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to set markup for."]
        outerHTML : string;
            [@key "outerHTML"] [@ocaml.doc "Outer HTML markup to set."]
      }
      [@@deriving yojson]

      let make ~nodeId ~outerHTML () = { nodeId; outerHTML }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setOuterHTML"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Undoes the last performed action. *)
  module Undo = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.undo"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns iframe node that owns iframe with the given domain. *)
  module GetFrameOwner = struct
    module Response : sig
      type result = {
        backendNodeId : Types.DOM.BackendNodeId.t;
            [@key "backendNodeId"] [@ocaml.doc "Resulting node."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Id of the node at given coordinates, only when enabled and \
               requested document."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        backendNodeId : Types.DOM.BackendNodeId.t;
            [@key "backendNodeId"] [@ocaml.doc "Resulting node."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Id of the node at given coordinates, only when enabled and \
               requested document."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getFrameOwner"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the query container of the given node based on container query
     conditions: containerName, physical, and logical axes. If no axes are
     provided, the style container is returned, which is the direct parent or the
     closest element with a matching container-name. *)
  module GetContainerForNode = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "The container node for the given node, or null if not found."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "The container node for the given node, or null if not found."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
        containerName : string option;
            [@key "containerName"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        physicalAxes : Types.DOM.PhysicalAxes.t option;
            [@key "physicalAxes"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        logicalAxes : Types.DOM.LogicalAxes.t option;
            [@key "logicalAxes"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId ?containerName ?physicalAxes ?logicalAxes () =
        { nodeId; containerName; physicalAxes; logicalAxes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getContainerForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the descendants of a container query container that have
     container queries against this container. *)
  module GetQueryingDescendantsForContainer = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "Descendant nodes with container queries against the given \
               container."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "Descendant nodes with container queries against the given \
               container."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc
              "Id of the container node to find querying descendants from."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOM.getQueryingDescendantsForContainer";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module DOMDebugger = struct
  (* Returns event listeners of the given object. *)
  module GetEventListeners = struct
    module Response : sig
      type result = {
        listeners : Types.DOMDebugger.EventListener.t list;
            [@key "listeners"] [@ocaml.doc "Array of relevant listeners."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        listeners : Types.DOMDebugger.EventListener.t list;
            [@key "listeners"] [@ocaml.doc "Array of relevant listeners."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"]
            [@ocaml.doc "Identifier of the object to return listeners for."]
        depth : Types.number option;
            [@key "depth"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum depth at which Node children should be retrieved, \
               defaults to 1. Use -1 for the\n\
               entire subtree or provide an integer larger than 0."]
        pierce : bool option;
            [@key "pierce"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not iframes and shadow roots should be traversed \
               when returning the subtree\n\
               (default is false). Reports listeners for all contexts if \
               pierce is enabled."]
      }
      [@@deriving yojson]

      let make ~objectId ?depth ?pierce () = { objectId; depth; pierce }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMDebugger.getEventListeners"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Removes DOM breakpoint that was set using `setDOMBreakpoint`. *)
  module RemoveDOMBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Identifier of the node to remove breakpoint from."]
        type_ : Types.DOMDebugger.DOMBreakpointType.t;
            [@key "type"] [@ocaml.doc "Type of the breakpoint to remove."]
      }
      [@@deriving yojson]

      let make ~nodeId ~type_ () = { nodeId; type_ }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMDebugger.removeDOMBreakpoint"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Removes breakpoint on particular DOM event. *)
  module RemoveEventListenerBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventName : string; [@key "eventName"] [@ocaml.doc "Event name."]
        targetName : string option;
            [@key "targetName"]
            [@yojson.option]
            [@ocaml.doc "EventTarget interface name."]
      }
      [@@deriving yojson]

      let make ~eventName ?targetName () = { eventName; targetName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOMDebugger.removeEventListenerBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Removes breakpoint on particular native event. *)
  module RemoveInstrumentationBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventName : string;
            [@key "eventName"] [@ocaml.doc "Instrumentation name to stop on."]
      }
      [@@deriving yojson]

      let make ~eventName () = { eventName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOMDebugger.removeInstrumentationBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Removes breakpoint from XMLHttpRequest. *)
  module RemoveXHRBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        url : string; [@key "url"] [@ocaml.doc "Resource URL substring."]
      }
      [@@deriving yojson]

      let make ~url () = { url }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMDebugger.removeXHRBreakpoint"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets breakpoint on particular CSP violations. *)
  module SetBreakOnCSPViolation = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        violationTypes : Types.DOMDebugger.CSPViolationType.t list;
            [@key "violationTypes"] [@ocaml.doc "CSP Violations to stop upon."]
      }
      [@@deriving yojson]

      let make ~violationTypes () = { violationTypes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOMDebugger.setBreakOnCSPViolation";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets breakpoint on particular operation with DOM. *)
  module SetDOMBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Identifier of the node to set breakpoint on."]
        type_ : Types.DOMDebugger.DOMBreakpointType.t;
            [@key "type"] [@ocaml.doc "Type of the operation to stop upon."]
      }
      [@@deriving yojson]

      let make ~nodeId ~type_ () = { nodeId; type_ }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMDebugger.setDOMBreakpoint"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets breakpoint on particular DOM event. *)
  module SetEventListenerBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventName : string;
            [@key "eventName"]
            [@ocaml.doc "DOM Event name to stop on (any DOM event will do)."]
        targetName : string option;
            [@key "targetName"]
            [@yojson.option]
            [@ocaml.doc
              "EventTarget interface name to stop on. If equal to `\"*\"` or \
               not provided, will stop on any\n\
               EventTarget."]
      }
      [@@deriving yojson]

      let make ~eventName ?targetName () = { eventName; targetName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOMDebugger.setEventListenerBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets breakpoint on particular native event. *)
  module SetInstrumentationBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventName : string;
            [@key "eventName"] [@ocaml.doc "Instrumentation name to stop on."]
      }
      [@@deriving yojson]

      let make ~eventName () = { eventName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOMDebugger.setInstrumentationBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets breakpoint on XMLHttpRequest. *)
  module SetXHRBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        url : string;
            [@key "url"]
            [@ocaml.doc
              "Resource URL substring. All XHRs having this substring in the \
               URL will get stopped upon."]
      }
      [@@deriving yojson]

      let make ~url () = { url }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMDebugger.setXHRBreakpoint"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module EventBreakpoints = struct
  (* Sets breakpoint on particular native event. *)
  module SetInstrumentationBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventName : string;
            [@key "eventName"] [@ocaml.doc "Instrumentation name to stop on."]
      }
      [@@deriving yojson]

      let make ~eventName () = { eventName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "EventBreakpoints.setInstrumentationBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Removes breakpoint on particular native event. *)
  module RemoveInstrumentationBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventName : string;
            [@key "eventName"] [@ocaml.doc "Instrumentation name to stop on."]
      }
      [@@deriving yojson]

      let make ~eventName () = { eventName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "EventBreakpoints.removeInstrumentationBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module DOMSnapshot = struct
  (* Disables DOM snapshot agent for the given page. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOMSnapshot.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables DOM snapshot agent for the given page. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOMSnapshot.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns a document snapshot, including the full DOM tree of the root node (including iframes,
     template contents, and imported documents) in a flattened array, as well as layout and
     white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
     flattened. *)
  module GetSnapshot = struct
    module Response : sig
      type result = {
        domNodes : Types.DOMSnapshot.DOMNode.t list;
            [@key "domNodes"]
            [@ocaml.doc
              "The nodes in the DOM tree. The DOMNode at index 0 corresponds \
               to the root document."]
        layoutTreeNodes : Types.DOMSnapshot.LayoutTreeNode.t list;
            [@key "layoutTreeNodes"]
            [@ocaml.doc "The nodes in the layout tree."]
        computedStyles : Types.DOMSnapshot.ComputedStyle.t list;
            [@key "computedStyles"]
            [@ocaml.doc
              "Whitelisted ComputedStyle properties for each node in the \
               layout tree."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        domNodes : Types.DOMSnapshot.DOMNode.t list;
            [@key "domNodes"]
            [@ocaml.doc
              "The nodes in the DOM tree. The DOMNode at index 0 corresponds \
               to the root document."]
        layoutTreeNodes : Types.DOMSnapshot.LayoutTreeNode.t list;
            [@key "layoutTreeNodes"]
            [@ocaml.doc "The nodes in the layout tree."]
        computedStyles : Types.DOMSnapshot.ComputedStyle.t list;
            [@key "computedStyles"]
            [@ocaml.doc
              "Whitelisted ComputedStyle properties for each node in the \
               layout tree."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        computedStyleWhitelist : string list;
            [@key "computedStyleWhitelist"]
            [@ocaml.doc "Whitelist of computed styles to return."]
        includeEventListeners : bool option;
            [@key "includeEventListeners"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not to retrieve details of DOM listeners (default \
               false)."]
        includePaintOrder : bool option;
            [@key "includePaintOrder"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to determine and include the paint order index of \
               LayoutTreeNodes (default false)."]
        includeUserAgentShadowTree : bool option;
            [@key "includeUserAgentShadowTree"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include UA shadow tree in the snapshot (default \
               false)."]
      }
      [@@deriving yojson]

      let make ~computedStyleWhitelist ?includeEventListeners ?includePaintOrder
          ?includeUserAgentShadowTree () =
        {
          computedStyleWhitelist;
          includeEventListeners;
          includePaintOrder;
          includeUserAgentShadowTree;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMSnapshot.getSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns a document snapshot, including the full DOM tree of the root node (including iframes,
     template contents, and imported documents) in a flattened array, as well as layout and
     white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
     flattened. *)
  module CaptureSnapshot = struct
    module Response : sig
      type result = {
        documents : Types.DOMSnapshot.DocumentSnapshot.t list;
            [@key "documents"]
            [@ocaml.doc
              "The nodes in the DOM tree. The DOMNode at index 0 corresponds \
               to the root document."]
        strings : string list;
            [@key "strings"]
            [@ocaml.doc
              "Shared string table that all string properties refer to with \
               indexes."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        documents : Types.DOMSnapshot.DocumentSnapshot.t list;
            [@key "documents"]
            [@ocaml.doc
              "The nodes in the DOM tree. The DOMNode at index 0 corresponds \
               to the root document."]
        strings : string list;
            [@key "strings"]
            [@ocaml.doc
              "Shared string table that all string properties refer to with \
               indexes."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        computedStyles : string list;
            [@key "computedStyles"]
            [@ocaml.doc "Whitelist of computed styles to return."]
        includePaintOrder : bool option;
            [@key "includePaintOrder"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include layout object paint orders into the snapshot."]
        includeDOMRects : bool option;
            [@key "includeDOMRects"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include DOM rectangles (offsetRects, clientRects, \
               scrollRects) into the snapshot"]
        includeBlendedBackgroundColors : bool option;
            [@key "includeBlendedBackgroundColors"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include blended background colors in the snapshot \
               (default: false).\n\
               Blended background color is achieved by blending background \
               colors of all elements\n\
               that overlap with the current element."]
        includeTextColorOpacities : bool option;
            [@key "includeTextColorOpacities"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include text color opacity in the snapshot (default: \
               false).\n\
               An element might have the opacity property set that affects the \
               text color of the element.\n\
               The final text color opacity is computed based on the opacity \
               of all overlapping elements."]
      }
      [@@deriving yojson]

      let make ~computedStyles ?includePaintOrder ?includeDOMRects
          ?includeBlendedBackgroundColors ?includeTextColorOpacities () =
        {
          computedStyles;
          includePaintOrder;
          includeDOMRects;
          includeBlendedBackgroundColors;
          includeTextColorOpacities;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMSnapshot.captureSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module DOMStorage = struct
  (* No description provided *)
  module Clear = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageId : Types.DOMStorage.StorageId.t;
            [@key "storageId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~storageId () = { storageId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMStorage.clear"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables storage tracking, prevents storage events from being sent to the client. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOMStorage.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables storage tracking, storage events will now be delivered to the client. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOMStorage.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module GetDOMStorageItems = struct
    module Response : sig
      type result = {
        entries : Types.DOMStorage.Item.t list;
            [@key "entries"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        entries : Types.DOMStorage.Item.t list;
            [@key "entries"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageId : Types.DOMStorage.StorageId.t;
            [@key "storageId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~storageId () = { storageId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMStorage.getDOMStorageItems"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module RemoveDOMStorageItem = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageId : Types.DOMStorage.StorageId.t;
            [@key "storageId"] [@ocaml.doc "No description provided"]
        key : string; [@key "key"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~storageId ~key () = { storageId; key }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMStorage.removeDOMStorageItem"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetDOMStorageItem = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageId : Types.DOMStorage.StorageId.t;
            [@key "storageId"] [@ocaml.doc "No description provided"]
        key : string; [@key "key"] [@ocaml.doc "No description provided"]
        value : string; [@key "value"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~storageId ~key ~value () = { storageId; key; value }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMStorage.setDOMStorageItem"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Database = struct
  (* Disables database tracking, prevents database events from being sent to the client. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Database.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables database tracking, database events will now be delivered to the client. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Database.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module ExecuteSQL = struct
    module Response : sig
      type result = {
        columnNames : string list option;
            [@key "columnNames"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        values : string list option;
            [@key "values"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        sqlError : Types.Database.Error.t option;
            [@key "sqlError"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        columnNames : string list option;
            [@key "columnNames"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        values : string list option;
            [@key "values"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        sqlError : Types.Database.Error.t option;
            [@key "sqlError"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        databaseId : Types.Database.DatabaseId.t;
            [@key "databaseId"] [@ocaml.doc "No description provided"]
        query : string; [@key "query"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~databaseId ~query () = { databaseId; query }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Database.executeSQL"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module GetDatabaseTableNames = struct
    module Response : sig
      type result = {
        tableNames : string list;
            [@key "tableNames"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        tableNames : string list;
            [@key "tableNames"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        databaseId : Types.Database.DatabaseId.t;
            [@key "databaseId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~databaseId () = { databaseId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Database.getDatabaseTableNames"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module DeviceOrientation = struct
  (* Clears the overridden Device Orientation. *)
  module ClearDeviceOrientationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        {
          id;
          method_ = "DeviceOrientation.clearDeviceOrientationOverride";
          sessionId;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Overrides the Device Orientation. *)
  module SetDeviceOrientationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        alpha : Types.number; [@key "alpha"] [@ocaml.doc "Mock alpha"]
        beta : Types.number; [@key "beta"] [@ocaml.doc "Mock beta"]
        gamma : Types.number; [@key "gamma"] [@ocaml.doc "Mock gamma"]
      }
      [@@deriving yojson]

      let make ~alpha ~beta ~gamma () = { alpha; beta; gamma }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DeviceOrientation.setDeviceOrientationOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Emulation = struct
  (* Tells whether emulation is supported. *)
  module CanEmulate = struct
    module Response : sig
      type result = {
        result : bool;
            [@key "result"] [@ocaml.doc "True if emulation is supported."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : bool;
            [@key "result"] [@ocaml.doc "True if emulation is supported."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.canEmulate"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears the overridden device metrics. *)
  module ClearDeviceMetricsOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.clearDeviceMetricsOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears the overridden Geolocation Position and Error. *)
  module ClearGeolocationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.clearGeolocationOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests that page scale factor is reset to initial values. *)
  module ResetPageScaleFactor = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.resetPageScaleFactor"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables or disables simulating a focused and active page. *)
  module SetFocusEmulationEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc "Whether to enable to disable focus emulation."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setFocusEmulationEnabled";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Automatically render all web contents using a dark theme. *)
  module SetAutoDarkModeOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool option;
            [@key "enabled"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to enable or disable automatic dark mode.\n\
               If not specified, any existing override will be cleared."]
      }
      [@@deriving yojson]

      let make ?enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setAutoDarkModeOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables CPU throttling to emulate slow CPUs. *)
  module SetCPUThrottlingRate = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        rate : Types.number;
            [@key "rate"]
            [@ocaml.doc
              "Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x \
               slowdown, etc)."]
      }
      [@@deriving yojson]

      let make ~rate () = { rate }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setCPUThrottlingRate"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets or clears an override of the default background color of the frame. This override is used
     if the content does not specify one. *)
  module SetDefaultBackgroundColorOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        color : Types.DOM.RGBA.t option;
            [@key "color"]
            [@yojson.option]
            [@ocaml.doc
              "RGBA of the default background color. If not specified, any \
               existing override will be\n\
               cleared."]
      }
      [@@deriving yojson]

      let make ?color () = { color }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setDefaultBackgroundColorOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
     window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
     query results). *)
  module SetDeviceMetricsOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        width : Types.number;
            [@key "width"]
            [@ocaml.doc
              "Overriding width value in pixels (minimum 0, maximum 10000000). \
               0 disables the override."]
        height : Types.number;
            [@key "height"]
            [@ocaml.doc
              "Overriding height value in pixels (minimum 0, maximum \
               10000000). 0 disables the override."]
        deviceScaleFactor : Types.number;
            [@key "deviceScaleFactor"]
            [@ocaml.doc
              "Overriding device scale factor value. 0 disables the override."]
        mobile : bool;
            [@key "mobile"]
            [@ocaml.doc
              "Whether to emulate mobile device. This includes viewport meta \
               tag, overlay scrollbars, text\n\
               autosizing and more."]
        scale : Types.number option;
            [@key "scale"]
            [@yojson.option]
            [@ocaml.doc "Scale to apply to resulting view image."]
        screenWidth : Types.number option;
            [@key "screenWidth"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding screen width value in pixels (minimum 0, maximum \
               10000000)."]
        screenHeight : Types.number option;
            [@key "screenHeight"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding screen height value in pixels (minimum 0, maximum \
               10000000)."]
        positionX : Types.number option;
            [@key "positionX"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding view X position on screen in pixels (minimum 0, \
               maximum 10000000)."]
        positionY : Types.number option;
            [@key "positionY"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding view Y position on screen in pixels (minimum 0, \
               maximum 10000000)."]
        dontSetVisibleSize : bool option;
            [@key "dontSetVisibleSize"]
            [@yojson.option]
            [@ocaml.doc
              "Do not set visible view size, rely upon explicit setVisibleSize \
               call."]
        screenOrientation : Types.Emulation.ScreenOrientation.t option;
            [@key "screenOrientation"]
            [@yojson.option]
            [@ocaml.doc "Screen orientation override."]
        viewport : Types.Page.Viewport.t option;
            [@key "viewport"]
            [@yojson.option]
            [@ocaml.doc
              "If set, the visible area of the page will be overridden to this \
               viewport. This viewport\n\
               change is not observed by the page, e.g. viewport-relative \
               elements do not change positions."]
        displayFeature : Types.Emulation.DisplayFeature.t option;
            [@key "displayFeature"]
            [@yojson.option]
            [@ocaml.doc
              "If set, the display feature of a multi-segment screen. If not \
               set, multi-segment support\n\
               is turned-off."]
      }
      [@@deriving yojson]

      let make ~width ~height ~deviceScaleFactor ~mobile ?scale ?screenWidth
          ?screenHeight ?positionX ?positionY ?dontSetVisibleSize
          ?screenOrientation ?viewport ?displayFeature () =
        {
          width;
          height;
          deviceScaleFactor;
          mobile;
          scale;
          screenWidth;
          screenHeight;
          positionX;
          positionY;
          dontSetVisibleSize;
          screenOrientation;
          viewport;
          displayFeature;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setDeviceMetricsOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetScrollbarsHidden = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        hidden : bool;
            [@key "hidden"]
            [@ocaml.doc "Whether scrollbars should be always hidden."]
      }
      [@@deriving yojson]

      let make ~hidden () = { hidden }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setScrollbarsHidden"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetDocumentCookieDisabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        disabled : bool;
            [@key "disabled"]
            [@ocaml.doc "Whether document.coookie API should be disabled."]
      }
      [@@deriving yojson]

      let make ~disabled () = { disabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setDocumentCookieDisabled";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetEmitTouchEventsForMouse = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setemittoucheventsformouse_configuration = [ `mobile | `desktop ]

      let setemittoucheventsformouse_configuration_of_yojson = function
        | `String "mobile" -> `mobile
        | `String "desktop" -> `desktop
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setemittoucheventsformouse_configuration = function
        | `mobile -> `String "mobile"
        | `desktop -> `String "desktop"

      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc
              "Whether touch emulation based on mouse input should be enabled."]
        configuration : setemittoucheventsformouse_configuration option;
            [@key "configuration"]
            [@yojson.option]
            [@ocaml.doc
              "Touch/gesture events configuration. Default: current platform."]
      }
      [@@deriving yojson]

      let make ~enabled ?configuration () = { enabled; configuration }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setEmitTouchEventsForMouse";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Emulates the given media type or media feature for CSS media queries. *)
  module SetEmulatedMedia = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        media : string option;
            [@key "media"]
            [@yojson.option]
            [@ocaml.doc
              "Media type to emulate. Empty string disables the override."]
        features : Types.Emulation.MediaFeature.t list option;
            [@key "features"]
            [@yojson.option]
            [@ocaml.doc "Media features to emulate."]
      }
      [@@deriving yojson]

      let make ?media ?features () = { media; features }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setEmulatedMedia"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Emulates the given vision deficiency. *)
  module SetEmulatedVisionDeficiency = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setemulatedvisiondeficiency_type =
        [ `none
        | `blurredVision
        | `reducedContrast
        | `achromatopsia
        | `deuteranopia
        | `protanopia
        | `tritanopia ]

      let setemulatedvisiondeficiency_type_of_yojson = function
        | `String "none" -> `none
        | `String "blurredVision" -> `blurredVision
        | `String "reducedContrast" -> `reducedContrast
        | `String "achromatopsia" -> `achromatopsia
        | `String "deuteranopia" -> `deuteranopia
        | `String "protanopia" -> `protanopia
        | `String "tritanopia" -> `tritanopia
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setemulatedvisiondeficiency_type = function
        | `none -> `String "none"
        | `blurredVision -> `String "blurredVision"
        | `reducedContrast -> `String "reducedContrast"
        | `achromatopsia -> `String "achromatopsia"
        | `deuteranopia -> `String "deuteranopia"
        | `protanopia -> `String "protanopia"
        | `tritanopia -> `String "tritanopia"

      type t = {
        type_ : setemulatedvisiondeficiency_type;
            [@key "type"]
            [@ocaml.doc
              "Vision deficiency to emulate. Order: best-effort emulations \
               come first, followed by any\n\
               physiologically accurate emulations for medically recognized \
               color vision deficiencies."]
      }
      [@@deriving yojson]

      let make ~type_ () = { type_ }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setEmulatedVisionDeficiency";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
     unavailable. *)
  module SetGeolocationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        latitude : Types.number option;
            [@key "latitude"] [@yojson.option] [@ocaml.doc "Mock latitude"]
        longitude : Types.number option;
            [@key "longitude"] [@yojson.option] [@ocaml.doc "Mock longitude"]
        accuracy : Types.number option;
            [@key "accuracy"] [@yojson.option] [@ocaml.doc "Mock accuracy"]
      }
      [@@deriving yojson]

      let make ?latitude ?longitude ?accuracy () =
        { latitude; longitude; accuracy }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setGeolocationOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Overrides the Idle state. *)
  module SetIdleOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        isUserActive : bool;
            [@key "isUserActive"] [@ocaml.doc "Mock isUserActive"]
        isScreenUnlocked : bool;
            [@key "isScreenUnlocked"] [@ocaml.doc "Mock isScreenUnlocked"]
      }
      [@@deriving yojson]

      let make ~isUserActive ~isScreenUnlocked () =
        { isUserActive; isScreenUnlocked }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setIdleOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears Idle state overrides. *)
  module ClearIdleOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.clearIdleOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Overrides value returned by the javascript navigator object. *)
  module SetNavigatorOverrides = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        platform : string;
            [@key "platform"]
            [@ocaml.doc "The platform navigator.platform should return."]
      }
      [@@deriving yojson]

      let make ~platform () = { platform }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setNavigatorOverrides"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets a specified page scale factor. *)
  module SetPageScaleFactor = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        pageScaleFactor : Types.number;
            [@key "pageScaleFactor"] [@ocaml.doc "Page scale factor."]
      }
      [@@deriving yojson]

      let make ~pageScaleFactor () = { pageScaleFactor }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setPageScaleFactor"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Switches script execution in the page. *)
  module SetScriptExecutionDisabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        value : bool;
            [@key "value"]
            [@ocaml.doc
              "Whether script execution should be disabled in the page."]
      }
      [@@deriving yojson]

      let make ~value () = { value }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setScriptExecutionDisabled";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables touch on platforms which do not support them. *)
  module SetTouchEmulationEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc "Whether the touch event emulation should be enabled."]
        maxTouchPoints : Types.number option;
            [@key "maxTouchPoints"]
            [@yojson.option]
            [@ocaml.doc "Maximum touch points supported. Defaults to one."]
      }
      [@@deriving yojson]

      let make ~enabled ?maxTouchPoints () = { enabled; maxTouchPoints }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setTouchEmulationEnabled";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
     the current virtual time policy.  Note this supersedes any previous time budget. *)
  module SetVirtualTimePolicy = struct
    module Response : sig
      type result = {
        virtualTimeTicksBase : Types.number;
            [@key "virtualTimeTicksBase"]
            [@ocaml.doc
              "Absolute timestamp at which virtual time was first enabled (up \
               time in milliseconds)."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        virtualTimeTicksBase : Types.number;
            [@key "virtualTimeTicksBase"]
            [@ocaml.doc
              "Absolute timestamp at which virtual time was first enabled (up \
               time in milliseconds)."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        policy : Types.Emulation.VirtualTimePolicy.t;
            [@key "policy"] [@ocaml.doc "No description provided"]
        budget : Types.number option;
            [@key "budget"]
            [@yojson.option]
            [@ocaml.doc
              "If set, after this many virtual milliseconds have elapsed \
               virtual time will be paused and a\n\
               virtualTimeBudgetExpired event is sent."]
        maxVirtualTimeTaskStarvationCount : Types.number option;
            [@key "maxVirtualTimeTaskStarvationCount"]
            [@yojson.option]
            [@ocaml.doc
              "If set this specifies the maximum number of tasks that can be \
               run before virtual is forced\n\
               forwards to prevent deadlock."]
        initialVirtualTime : Types.Network.TimeSinceEpoch.t option;
            [@key "initialVirtualTime"]
            [@yojson.option]
            [@ocaml.doc
              "If set, base::Time::Now will be overridden to initially return \
               this value."]
      }
      [@@deriving yojson]

      let make ~policy ?budget ?maxVirtualTimeTaskStarvationCount
          ?initialVirtualTime () =
        {
          policy;
          budget;
          maxVirtualTimeTaskStarvationCount;
          initialVirtualTime;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setVirtualTimePolicy"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Overrides default host system locale with the specified one. *)
  module SetLocaleOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        locale : string option;
            [@key "locale"]
            [@yojson.option]
            [@ocaml.doc
              "ICU style C locale (e.g. \"en_US\"). If not specified or empty, \
               disables the override and\n\
               restores default host system locale."]
      }
      [@@deriving yojson]

      let make ?locale () = { locale }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setLocaleOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Overrides default host system timezone with the specified one. *)
  module SetTimezoneOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        timezoneId : string;
            [@key "timezoneId"]
            [@ocaml.doc
              "The timezone identifier. If empty, disables the override and\n\
               restores default host system timezone."]
      }
      [@@deriving yojson]

      let make ~timezoneId () = { timezoneId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setTimezoneOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Resizes the frame/viewport of the page. Note that this does not affect the frame's container
     (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
     on Android. *)
  module SetVisibleSize = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        width : Types.number; [@key "width"] [@ocaml.doc "Frame width (DIP)."]
        height : Types.number; [@key "height"] [@ocaml.doc "Frame height (DIP)."]
      }
      [@@deriving yojson]

      let make ~width ~height () = { width; height }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setVisibleSize"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetDisabledImageTypes = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        imageTypes : Types.Emulation.DisabledImageType.t list;
            [@key "imageTypes"] [@ocaml.doc "Image types to disable."]
      }
      [@@deriving yojson]

      let make ~imageTypes () = { imageTypes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setDisabledImageTypes"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetHardwareConcurrencyOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        hardwareConcurrency : Types.number;
            [@key "hardwareConcurrency"]
            [@ocaml.doc "Hardware concurrency to report"]
      }
      [@@deriving yojson]

      let make ~hardwareConcurrency () = { hardwareConcurrency }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setHardwareConcurrencyOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Allows overriding user agent with the given string. *)
  module SetUserAgentOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        userAgent : string; [@key "userAgent"] [@ocaml.doc "User agent to use."]
        acceptLanguage : string option;
            [@key "acceptLanguage"]
            [@yojson.option]
            [@ocaml.doc "Browser langugage to emulate."]
        platform : string option;
            [@key "platform"]
            [@yojson.option]
            [@ocaml.doc "The platform navigator.platform should return."]
        userAgentMetadata : Types.Emulation.UserAgentMetadata.t option;
            [@key "userAgentMetadata"]
            [@yojson.option]
            [@ocaml.doc
              "To be sent in Sec-CH-UA-* headers and returned in \
               navigator.userAgentData"]
      }
      [@@deriving yojson]

      let make ~userAgent ?acceptLanguage ?platform ?userAgentMetadata () =
        { userAgent; acceptLanguage; platform; userAgentMetadata }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setUserAgentOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Allows overriding the automation flag. *)
  module SetAutomationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc "Whether the override should be enabled."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setAutomationOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module HeadlessExperimental = struct
  (* Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
     screenshot from the resulting frame. Requires that the target was created with enabled
     BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
     https://goo.gle/chrome-headless-rendering for more background. *)
  module BeginFrame = struct
    module Response : sig
      type result = {
        hasDamage : bool;
            [@key "hasDamage"]
            [@ocaml.doc
              "Whether the BeginFrame resulted in damage and, thus, a new \
               frame was committed to the\n\
               display. Reported for diagnostic uses, may be removed in the \
               future."]
        screenshotData : string option;
            [@key "screenshotData"]
            [@yojson.option]
            [@ocaml.doc
              "Base64-encoded image data of the screenshot, if one was \
               requested and successfully taken. (Encoded as a base64 string \
               when passed over JSON)"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        hasDamage : bool;
            [@key "hasDamage"]
            [@ocaml.doc
              "Whether the BeginFrame resulted in damage and, thus, a new \
               frame was committed to the\n\
               display. Reported for diagnostic uses, may be removed in the \
               future."]
        screenshotData : string option;
            [@key "screenshotData"]
            [@yojson.option]
            [@ocaml.doc
              "Base64-encoded image data of the screenshot, if one was \
               requested and successfully taken. (Encoded as a base64 string \
               when passed over JSON)"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameTimeTicks : Types.number option;
            [@key "frameTimeTicks"]
            [@yojson.option]
            [@ocaml.doc
              "Timestamp of this BeginFrame in Renderer TimeTicks \
               (milliseconds of uptime). If not set,\n\
               the current time will be used."]
        interval : Types.number option;
            [@key "interval"]
            [@yojson.option]
            [@ocaml.doc
              "The interval between BeginFrames that is reported to the \
               compositor, in milliseconds.\n\
               Defaults to a 60 frames/second interval, i.e. about 16.666 \
               milliseconds."]
        noDisplayUpdates : bool option;
            [@key "noDisplayUpdates"]
            [@yojson.option]
            [@ocaml.doc
              "Whether updates should not be committed and drawn onto the \
               display. False by default. If\n\
               true, only side effects of the BeginFrame will be run, such as \
               layout and animations, but\n\
               any visual updates may not be visible on the display or in \
               screenshots."]
        screenshot : Types.HeadlessExperimental.ScreenshotParams.t option;
            [@key "screenshot"]
            [@yojson.option]
            [@ocaml.doc
              "If set, a screenshot of the frame will be captured and returned \
               in the response. Otherwise,\n\
               no screenshot will be captured. Note that capturing a \
               screenshot can fail, for example,\n\
               during renderer initialization. In such a case, no screenshot \
               data will be returned."]
      }
      [@@deriving yojson]

      let make ?frameTimeTicks ?interval ?noDisplayUpdates ?screenshot () =
        { frameTimeTicks; interval; noDisplayUpdates; screenshot }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "HeadlessExperimental.beginFrame"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables headless events for the target. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeadlessExperimental.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables headless events for the target. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeadlessExperimental.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module IO = struct
  (* Close the stream, discard any temporary backing storage. *)
  module Close = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        handle : Types.IO.StreamHandle.t;
            [@key "handle"] [@ocaml.doc "Handle of the stream to close."]
      }
      [@@deriving yojson]

      let make ~handle () = { handle }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IO.close"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Read a chunk of the stream *)
  module Read = struct
    module Response : sig
      type result = {
        base64Encoded : bool option;
            [@key "base64Encoded"]
            [@yojson.option]
            [@ocaml.doc "Set if the data is base64-encoded"]
        data : string; [@key "data"] [@ocaml.doc "Data that were read."]
        eof : bool;
            [@key "eof"]
            [@ocaml.doc
              "Set if the end-of-file condition occurred while reading."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        base64Encoded : bool option;
            [@key "base64Encoded"]
            [@yojson.option]
            [@ocaml.doc "Set if the data is base64-encoded"]
        data : string; [@key "data"] [@ocaml.doc "Data that were read."]
        eof : bool;
            [@key "eof"]
            [@ocaml.doc
              "Set if the end-of-file condition occurred while reading."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        handle : Types.IO.StreamHandle.t;
            [@key "handle"] [@ocaml.doc "Handle of the stream to read."]
        offset : Types.number option;
            [@key "offset"]
            [@yojson.option]
            [@ocaml.doc
              "Seek to the specified offset before reading (if not specificed, \
               proceed with offset\n\
               following the last read). Some types of streams may only \
               support sequential reads."]
        size : Types.number option;
            [@key "size"]
            [@yojson.option]
            [@ocaml.doc
              "Maximum number of bytes to read (left upon the agent discretion \
               if not specified)."]
      }
      [@@deriving yojson]

      let make ~handle ?offset ?size () = { handle; offset; size }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IO.read"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Return UUID of Blob object specified by a remote object id. *)
  module ResolveBlob = struct
    module Response : sig
      type result = {
        uuid : string; [@key "uuid"] [@ocaml.doc "UUID of the specified Blob."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        uuid : string; [@key "uuid"] [@ocaml.doc "UUID of the specified Blob."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"] [@ocaml.doc "Object id of a Blob object wrapper."]
      }
      [@@deriving yojson]

      let make ~objectId () = { objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IO.resolveBlob"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module IndexedDB = struct
  (* Clears all entries from an object store. *)
  module ClearObjectStore = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey must be \
               specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        databaseName : string;
            [@key "databaseName"] [@ocaml.doc "Database name."]
        objectStoreName : string;
            [@key "objectStoreName"] [@ocaml.doc "Object store name."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ~databaseName ~objectStoreName () =
        { securityOrigin; storageKey; databaseName; objectStoreName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IndexedDB.clearObjectStore"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Deletes a database. *)
  module DeleteDatabase = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey must be \
               specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        databaseName : string;
            [@key "databaseName"] [@ocaml.doc "Database name."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ~databaseName () =
        { securityOrigin; storageKey; databaseName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IndexedDB.deleteDatabase"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Delete a range of entries from an object store *)
  module DeleteObjectStoreEntries = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey must be \
               specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        databaseName : string;
            [@key "databaseName"] [@ocaml.doc "No description provided"]
        objectStoreName : string;
            [@key "objectStoreName"] [@ocaml.doc "No description provided"]
        keyRange : Types.IndexedDB.KeyRange.t;
            [@key "keyRange"] [@ocaml.doc "Range of entry keys to delete"]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ~databaseName ~objectStoreName
          ~keyRange () =
        { securityOrigin; storageKey; databaseName; objectStoreName; keyRange }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "IndexedDB.deleteObjectStoreEntries";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables events from backend. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "IndexedDB.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables events from backend. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "IndexedDB.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests data from object store or index. *)
  module RequestData = struct
    module Response : sig
      type result = {
        objectStoreDataEntries : Types.IndexedDB.DataEntry.t list;
            [@key "objectStoreDataEntries"]
            [@ocaml.doc "Array of object store data entries."]
        hasMore : bool;
            [@key "hasMore"]
            [@ocaml.doc
              "If true, there are more entries to fetch in the given range."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        objectStoreDataEntries : Types.IndexedDB.DataEntry.t list;
            [@key "objectStoreDataEntries"]
            [@ocaml.doc "Array of object store data entries."]
        hasMore : bool;
            [@key "hasMore"]
            [@ocaml.doc
              "If true, there are more entries to fetch in the given range."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey must be \
               specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        databaseName : string;
            [@key "databaseName"] [@ocaml.doc "Database name."]
        objectStoreName : string;
            [@key "objectStoreName"] [@ocaml.doc "Object store name."]
        indexName : string;
            [@key "indexName"]
            [@ocaml.doc
              "Index name, empty string for object store data requests."]
        skipCount : Types.number;
            [@key "skipCount"] [@ocaml.doc "Number of records to skip."]
        pageSize : Types.number;
            [@key "pageSize"] [@ocaml.doc "Number of records to fetch."]
        keyRange : Types.IndexedDB.KeyRange.t option;
            [@key "keyRange"] [@yojson.option] [@ocaml.doc "Key range."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ~databaseName ~objectStoreName
          ~indexName ~skipCount ~pageSize ?keyRange () =
        {
          securityOrigin;
          storageKey;
          databaseName;
          objectStoreName;
          indexName;
          skipCount;
          pageSize;
          keyRange;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IndexedDB.requestData"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Gets metadata of an object store. *)
  module GetMetadata = struct
    module Response : sig
      type result = {
        entriesCount : Types.number;
            [@key "entriesCount"] [@ocaml.doc "the entries count"]
        keyGeneratorValue : Types.number;
            [@key "keyGeneratorValue"]
            [@ocaml.doc
              "the current value of key generator, to become the next inserted\n\
               key into the object store. Valid if objectStore.autoIncrement\n\
               is true."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        entriesCount : Types.number;
            [@key "entriesCount"] [@ocaml.doc "the entries count"]
        keyGeneratorValue : Types.number;
            [@key "keyGeneratorValue"]
            [@ocaml.doc
              "the current value of key generator, to become the next inserted\n\
               key into the object store. Valid if objectStore.autoIncrement\n\
               is true."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey must be \
               specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        databaseName : string;
            [@key "databaseName"] [@ocaml.doc "Database name."]
        objectStoreName : string;
            [@key "objectStoreName"] [@ocaml.doc "Object store name."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ~databaseName ~objectStoreName () =
        { securityOrigin; storageKey; databaseName; objectStoreName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IndexedDB.getMetadata"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests database with given name in given frame. *)
  module RequestDatabase = struct
    module Response : sig
      type result = {
        databaseWithObjectStores : Types.IndexedDB.DatabaseWithObjectStores.t;
            [@key "databaseWithObjectStores"]
            [@ocaml.doc "Database with an array of object stores."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        databaseWithObjectStores : Types.IndexedDB.DatabaseWithObjectStores.t;
            [@key "databaseWithObjectStores"]
            [@ocaml.doc "Database with an array of object stores."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey must be \
               specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        databaseName : string;
            [@key "databaseName"] [@ocaml.doc "Database name."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ~databaseName () =
        { securityOrigin; storageKey; databaseName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IndexedDB.requestDatabase"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests database names for given security origin. *)
  module RequestDatabaseNames = struct
    module Response : sig
      type result = {
        databaseNames : string list;
            [@key "databaseNames"] [@ocaml.doc "Database names for origin."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        databaseNames : string list;
            [@key "databaseNames"] [@ocaml.doc "Database names for origin."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey must be \
               specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey () = { securityOrigin; storageKey }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IndexedDB.requestDatabaseNames"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Input = struct
  (* Dispatches a drag event into the page. *)
  module DispatchDragEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type dispatchdragevent_type =
        [ `dragEnter | `dragOver | `drop | `dragCancel ]

      let dispatchdragevent_type_of_yojson = function
        | `String "dragEnter" -> `dragEnter
        | `String "dragOver" -> `dragOver
        | `String "drop" -> `drop
        | `String "dragCancel" -> `dragCancel
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_dispatchdragevent_type = function
        | `dragEnter -> `String "dragEnter"
        | `dragOver -> `String "dragOver"
        | `drop -> `String "drop"
        | `dragCancel -> `String "dragCancel"

      type t = {
        type_ : dispatchdragevent_type;
            [@key "type"] [@ocaml.doc "Type of the drag event."]
        x : Types.number;
            [@key "x"]
            [@ocaml.doc
              "X coordinate of the event relative to the main frame's viewport \
               in CSS pixels."]
        y : Types.number;
            [@key "y"]
            [@ocaml.doc
              "Y coordinate of the event relative to the main frame's viewport \
               in CSS pixels. 0 refers to\n\
               the top of the viewport and Y increases as it proceeds towards \
               the bottom of the viewport."]
        data : Types.Input.DragData.t;
            [@key "data"] [@ocaml.doc "No description provided"]
        modifiers : Types.number option;
            [@key "modifiers"]
            [@yojson.option]
            [@ocaml.doc
              "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, \
               Meta/Command=4, Shift=8\n\
               (default: 0)."]
      }
      [@@deriving yojson]

      let make ~type_ ~x ~y ~data ?modifiers () =
        { type_; x; y; data; modifiers }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.dispatchDragEvent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Dispatches a key event to the page. *)
  module DispatchKeyEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type dispatchkeyevent_type = [ `keyDown | `keyUp | `rawKeyDown | `char ]

      let dispatchkeyevent_type_of_yojson = function
        | `String "keyDown" -> `keyDown
        | `String "keyUp" -> `keyUp
        | `String "rawKeyDown" -> `rawKeyDown
        | `String "char" -> `char
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_dispatchkeyevent_type = function
        | `keyDown -> `String "keyDown"
        | `keyUp -> `String "keyUp"
        | `rawKeyDown -> `String "rawKeyDown"
        | `char -> `String "char"

      type t = {
        type_ : dispatchkeyevent_type;
            [@key "type"] [@ocaml.doc "Type of the key event."]
        modifiers : Types.number option;
            [@key "modifiers"]
            [@yojson.option]
            [@ocaml.doc
              "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, \
               Meta/Command=4, Shift=8\n\
               (default: 0)."]
        timestamp : Types.Input.TimeSinceEpoch.t option;
            [@key "timestamp"]
            [@yojson.option]
            [@ocaml.doc "Time at which the event occurred."]
        text : string option;
            [@key "text"]
            [@yojson.option]
            [@ocaml.doc
              "Text as generated by processing a virtual key code with a \
               keyboard layout. Not needed for\n\
               for `keyUp` and `rawKeyDown` events (default: \"\")"]
        unmodifiedText : string option;
            [@key "unmodifiedText"]
            [@yojson.option]
            [@ocaml.doc
              "Text that would have been generated by the keyboard if no \
               modifiers were pressed (except for\n\
               shift). Useful for shortcut (accelerator) key handling \
               (default: \"\")."]
        keyIdentifier : string option;
            [@key "keyIdentifier"]
            [@yojson.option]
            [@ocaml.doc
              "Unique key identifier (e.g., 'U+0041') (default: \"\")."]
        code : string option;
            [@key "code"]
            [@yojson.option]
            [@ocaml.doc
              "Unique DOM defined string value for each physical key (e.g., \
               'KeyA') (default: \"\")."]
        key : string option;
            [@key "key"]
            [@yojson.option]
            [@ocaml.doc
              "Unique DOM defined string value describing the meaning of the \
               key in the context of active\n\
               modifiers, keyboard layout, etc (e.g., 'AltGr') (default: \"\")."]
        windowsVirtualKeyCode : Types.number option;
            [@key "windowsVirtualKeyCode"]
            [@yojson.option]
            [@ocaml.doc "Windows virtual key code (default: 0)."]
        nativeVirtualKeyCode : Types.number option;
            [@key "nativeVirtualKeyCode"]
            [@yojson.option]
            [@ocaml.doc "Native virtual key code (default: 0)."]
        autoRepeat : bool option;
            [@key "autoRepeat"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the event was generated from auto repeat (default: \
               false)."]
        isKeypad : bool option;
            [@key "isKeypad"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the event was generated from the keypad (default: \
               false)."]
        isSystemKey : bool option;
            [@key "isSystemKey"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the event was a system key event (default: false)."]
        location : Types.number option;
            [@key "location"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the event was from the left or right side of the \
               keyboard. 1=Left, 2=Right (default:\n\
               0)."]
        commands : string list option;
            [@key "commands"]
            [@yojson.option]
            [@ocaml.doc
              "Editing commands to send with the key event (e.g., 'selectAll') \
               (default: []).\n\
               These are related to but not equal the command names used in \
               `document.execCommand` and NSStandardKeyBindingResponding.\n\
               See \
               https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h \
               for valid command names."]
      }
      [@@deriving yojson]

      let make ~type_ ?modifiers ?timestamp ?text ?unmodifiedText ?keyIdentifier
          ?code ?key ?windowsVirtualKeyCode ?nativeVirtualKeyCode ?autoRepeat
          ?isKeypad ?isSystemKey ?location ?commands () =
        {
          type_;
          modifiers;
          timestamp;
          text;
          unmodifiedText;
          keyIdentifier;
          code;
          key;
          windowsVirtualKeyCode;
          nativeVirtualKeyCode;
          autoRepeat;
          isKeypad;
          isSystemKey;
          location;
          commands;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.dispatchKeyEvent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* This method emulates inserting text that doesn't come from a key press,
     for example an emoji keyboard or an IME. *)
  module InsertText = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        text : string; [@key "text"] [@ocaml.doc "The text to insert."]
      }
      [@@deriving yojson]

      let make ~text () = { text }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.insertText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* This method sets the current candidate text for ime.
     Use imeCommitComposition to commit the final text.
     Use imeSetComposition with empty string as text to cancel composition. *)
  module ImeSetComposition = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        text : string; [@key "text"] [@ocaml.doc "The text to insert"]
        selectionStart : Types.number;
            [@key "selectionStart"] [@ocaml.doc "selection start"]
        selectionEnd : Types.number;
            [@key "selectionEnd"] [@ocaml.doc "selection end"]
        replacementStart : Types.number option;
            [@key "replacementStart"]
            [@yojson.option]
            [@ocaml.doc "replacement start"]
        replacementEnd : Types.number option;
            [@key "replacementEnd"]
            [@yojson.option]
            [@ocaml.doc "replacement end"]
      }
      [@@deriving yojson]

      let make ~text ~selectionStart ~selectionEnd ?replacementStart
          ?replacementEnd () =
        { text; selectionStart; selectionEnd; replacementStart; replacementEnd }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.imeSetComposition"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Dispatches a mouse event to the page. *)
  module DispatchMouseEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type dispatchmouseevent_type =
        [ `mousePressed | `mouseReleased | `mouseMoved | `mouseWheel ]

      let dispatchmouseevent_type_of_yojson = function
        | `String "mousePressed" -> `mousePressed
        | `String "mouseReleased" -> `mouseReleased
        | `String "mouseMoved" -> `mouseMoved
        | `String "mouseWheel" -> `mouseWheel
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_dispatchmouseevent_type = function
        | `mousePressed -> `String "mousePressed"
        | `mouseReleased -> `String "mouseReleased"
        | `mouseMoved -> `String "mouseMoved"
        | `mouseWheel -> `String "mouseWheel"

      type dispatchmouseevent_pointertype = [ `mouse | `pen ]

      let dispatchmouseevent_pointertype_of_yojson = function
        | `String "mouse" -> `mouse
        | `String "pen" -> `pen
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_dispatchmouseevent_pointertype = function
        | `mouse -> `String "mouse"
        | `pen -> `String "pen"

      type t = {
        type_ : dispatchmouseevent_type;
            [@key "type"] [@ocaml.doc "Type of the mouse event."]
        x : Types.number;
            [@key "x"]
            [@ocaml.doc
              "X coordinate of the event relative to the main frame's viewport \
               in CSS pixels."]
        y : Types.number;
            [@key "y"]
            [@ocaml.doc
              "Y coordinate of the event relative to the main frame's viewport \
               in CSS pixels. 0 refers to\n\
               the top of the viewport and Y increases as it proceeds towards \
               the bottom of the viewport."]
        modifiers : Types.number option;
            [@key "modifiers"]
            [@yojson.option]
            [@ocaml.doc
              "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, \
               Meta/Command=4, Shift=8\n\
               (default: 0)."]
        timestamp : Types.Input.TimeSinceEpoch.t option;
            [@key "timestamp"]
            [@yojson.option]
            [@ocaml.doc "Time at which the event occurred."]
        button : Types.Input.MouseButton.t option;
            [@key "button"]
            [@yojson.option]
            [@ocaml.doc "Mouse button (default: \"none\")."]
        buttons : Types.number option;
            [@key "buttons"]
            [@yojson.option]
            [@ocaml.doc
              "A number indicating which buttons are pressed on the mouse when \
               a mouse event is triggered.\n\
               Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0."]
        clickCount : Types.number option;
            [@key "clickCount"]
            [@yojson.option]
            [@ocaml.doc
              "Number of times the mouse button was clicked (default: 0)."]
        force : Types.number option;
            [@key "force"]
            [@yojson.option]
            [@ocaml.doc
              "The normalized pressure, which has a range of [0,1] (default: \
               0)."]
        tangentialPressure : Types.number option;
            [@key "tangentialPressure"]
            [@yojson.option]
            [@ocaml.doc
              "The normalized tangential pressure, which has a range of [-1,1] \
               (default: 0)."]
        tiltX : Types.number option;
            [@key "tiltX"]
            [@yojson.option]
            [@ocaml.doc
              "The plane angle between the Y-Z plane and the plane containing \
               both the stylus axis and the Y axis, in degrees of the range \
               [-90,90], a positive tiltX is to the right (default: 0)."]
        tiltY : Types.number option;
            [@key "tiltY"]
            [@yojson.option]
            [@ocaml.doc
              "The plane angle between the X-Z plane and the plane containing \
               both the stylus axis and the X axis, in degrees of the range \
               [-90,90], a positive tiltY is towards the user (default: 0)."]
        twist : Types.number option;
            [@key "twist"]
            [@yojson.option]
            [@ocaml.doc
              "The clockwise rotation of a pen stylus around its own major \
               axis, in degrees in the range [0,359] (default: 0)."]
        deltaX : Types.number option;
            [@key "deltaX"]
            [@yojson.option]
            [@ocaml.doc
              "X delta in CSS pixels for mouse wheel event (default: 0)."]
        deltaY : Types.number option;
            [@key "deltaY"]
            [@yojson.option]
            [@ocaml.doc
              "Y delta in CSS pixels for mouse wheel event (default: 0)."]
        pointerType : dispatchmouseevent_pointertype option;
            [@key "pointerType"]
            [@yojson.option]
            [@ocaml.doc "Pointer type (default: \"mouse\")."]
      }
      [@@deriving yojson]

      let make ~type_ ~x ~y ?modifiers ?timestamp ?button ?buttons ?clickCount
          ?force ?tangentialPressure ?tiltX ?tiltY ?twist ?deltaX ?deltaY
          ?pointerType () =
        {
          type_;
          x;
          y;
          modifiers;
          timestamp;
          button;
          buttons;
          clickCount;
          force;
          tangentialPressure;
          tiltX;
          tiltY;
          twist;
          deltaX;
          deltaY;
          pointerType;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.dispatchMouseEvent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Dispatches a touch event to the page. *)
  module DispatchTouchEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type dispatchtouchevent_type =
        [ `touchStart | `touchEnd | `touchMove | `touchCancel ]

      let dispatchtouchevent_type_of_yojson = function
        | `String "touchStart" -> `touchStart
        | `String "touchEnd" -> `touchEnd
        | `String "touchMove" -> `touchMove
        | `String "touchCancel" -> `touchCancel
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_dispatchtouchevent_type = function
        | `touchStart -> `String "touchStart"
        | `touchEnd -> `String "touchEnd"
        | `touchMove -> `String "touchMove"
        | `touchCancel -> `String "touchCancel"

      type t = {
        type_ : dispatchtouchevent_type;
            [@key "type"]
            [@ocaml.doc
              "Type of the touch event. TouchEnd and TouchCancel must not \
               contain any touch points, while\n\
               TouchStart and TouchMove must contains at least one."]
        touchPoints : Types.Input.TouchPoint.t list;
            [@key "touchPoints"]
            [@ocaml.doc
              "Active touch points on the touch device. One event per any \
               changed point (compared to\n\
               previous touch event in a sequence) is generated, emulating \
               pressing/moving/releasing points\n\
               one by one."]
        modifiers : Types.number option;
            [@key "modifiers"]
            [@yojson.option]
            [@ocaml.doc
              "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, \
               Meta/Command=4, Shift=8\n\
               (default: 0)."]
        timestamp : Types.Input.TimeSinceEpoch.t option;
            [@key "timestamp"]
            [@yojson.option]
            [@ocaml.doc "Time at which the event occurred."]
      }
      [@@deriving yojson]

      let make ~type_ ~touchPoints ?modifiers ?timestamp () =
        { type_; touchPoints; modifiers; timestamp }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.dispatchTouchEvent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Emulates touch event from the mouse event parameters. *)
  module EmulateTouchFromMouseEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type emulatetouchfrommouseevent_type =
        [ `mousePressed | `mouseReleased | `mouseMoved | `mouseWheel ]

      let emulatetouchfrommouseevent_type_of_yojson = function
        | `String "mousePressed" -> `mousePressed
        | `String "mouseReleased" -> `mouseReleased
        | `String "mouseMoved" -> `mouseMoved
        | `String "mouseWheel" -> `mouseWheel
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_emulatetouchfrommouseevent_type = function
        | `mousePressed -> `String "mousePressed"
        | `mouseReleased -> `String "mouseReleased"
        | `mouseMoved -> `String "mouseMoved"
        | `mouseWheel -> `String "mouseWheel"

      type t = {
        type_ : emulatetouchfrommouseevent_type;
            [@key "type"] [@ocaml.doc "Type of the mouse event."]
        x : Types.number;
            [@key "x"] [@ocaml.doc "X coordinate of the mouse pointer in DIP."]
        y : Types.number;
            [@key "y"] [@ocaml.doc "Y coordinate of the mouse pointer in DIP."]
        button : Types.Input.MouseButton.t;
            [@key "button"]
            [@ocaml.doc
              "Mouse button. Only \"none\", \"left\", \"right\" are supported."]
        timestamp : Types.Input.TimeSinceEpoch.t option;
            [@key "timestamp"]
            [@yojson.option]
            [@ocaml.doc
              "Time at which the event occurred (default: current time)."]
        deltaX : Types.number option;
            [@key "deltaX"]
            [@yojson.option]
            [@ocaml.doc "X delta in DIP for mouse wheel event (default: 0)."]
        deltaY : Types.number option;
            [@key "deltaY"]
            [@yojson.option]
            [@ocaml.doc "Y delta in DIP for mouse wheel event (default: 0)."]
        modifiers : Types.number option;
            [@key "modifiers"]
            [@yojson.option]
            [@ocaml.doc
              "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, \
               Meta/Command=4, Shift=8\n\
               (default: 0)."]
        clickCount : Types.number option;
            [@key "clickCount"]
            [@yojson.option]
            [@ocaml.doc
              "Number of times the mouse button was clicked (default: 0)."]
      }
      [@@deriving yojson]

      let make ~type_ ~x ~y ~button ?timestamp ?deltaX ?deltaY ?modifiers
          ?clickCount () =
        {
          type_;
          x;
          y;
          button;
          timestamp;
          deltaX;
          deltaY;
          modifiers;
          clickCount;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.emulateTouchFromMouseEvent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Ignores input events (useful while auditing page). *)
  module SetIgnoreInputEvents = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ignore : bool;
            [@key "ignore"]
            [@ocaml.doc "Ignores input events processing when set to true."]
      }
      [@@deriving yojson]

      let make ~ignore () = { ignore }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.setIgnoreInputEvents"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
     Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`. *)
  module SetInterceptDrags = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool; [@key "enabled"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.setInterceptDrags"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Synthesizes a pinch gesture over a time period by issuing appropriate touch events. *)
  module SynthesizePinchGesture = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        x : Types.number;
            [@key "x"]
            [@ocaml.doc
              "X coordinate of the start of the gesture in CSS pixels."]
        y : Types.number;
            [@key "y"]
            [@ocaml.doc
              "Y coordinate of the start of the gesture in CSS pixels."]
        scaleFactor : Types.number;
            [@key "scaleFactor"]
            [@ocaml.doc
              "Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms \
               out)."]
        relativeSpeed : Types.number option;
            [@key "relativeSpeed"]
            [@yojson.option]
            [@ocaml.doc
              "Relative pointer speed in pixels per second (default: 800)."]
        gestureSourceType : Types.Input.GestureSourceType.t option;
            [@key "gestureSourceType"]
            [@yojson.option]
            [@ocaml.doc
              "Which type of input events to be generated (default: 'default', \
               which queries the platform\n\
               for the preferred input type)."]
      }
      [@@deriving yojson]

      let make ~x ~y ~scaleFactor ?relativeSpeed ?gestureSourceType () =
        { x; y; scaleFactor; relativeSpeed; gestureSourceType }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.synthesizePinchGesture"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Synthesizes a scroll gesture over a time period by issuing appropriate touch events. *)
  module SynthesizeScrollGesture = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        x : Types.number;
            [@key "x"]
            [@ocaml.doc
              "X coordinate of the start of the gesture in CSS pixels."]
        y : Types.number;
            [@key "y"]
            [@ocaml.doc
              "Y coordinate of the start of the gesture in CSS pixels."]
        xDistance : Types.number option;
            [@key "xDistance"]
            [@yojson.option]
            [@ocaml.doc
              "The distance to scroll along the X axis (positive to scroll \
               left)."]
        yDistance : Types.number option;
            [@key "yDistance"]
            [@yojson.option]
            [@ocaml.doc
              "The distance to scroll along the Y axis (positive to scroll up)."]
        xOverscroll : Types.number option;
            [@key "xOverscroll"]
            [@yojson.option]
            [@ocaml.doc
              "The number of additional pixels to scroll back along the X \
               axis, in addition to the given\n\
               distance."]
        yOverscroll : Types.number option;
            [@key "yOverscroll"]
            [@yojson.option]
            [@ocaml.doc
              "The number of additional pixels to scroll back along the Y \
               axis, in addition to the given\n\
               distance."]
        preventFling : bool option;
            [@key "preventFling"]
            [@yojson.option]
            [@ocaml.doc "Prevent fling (default: true)."]
        speed : Types.number option;
            [@key "speed"]
            [@yojson.option]
            [@ocaml.doc "Swipe speed in pixels per second (default: 800)."]
        gestureSourceType : Types.Input.GestureSourceType.t option;
            [@key "gestureSourceType"]
            [@yojson.option]
            [@ocaml.doc
              "Which type of input events to be generated (default: 'default', \
               which queries the platform\n\
               for the preferred input type)."]
        repeatCount : Types.number option;
            [@key "repeatCount"]
            [@yojson.option]
            [@ocaml.doc
              "The number of times to repeat the gesture (default: 0)."]
        repeatDelayMs : Types.number option;
            [@key "repeatDelayMs"]
            [@yojson.option]
            [@ocaml.doc
              "The number of milliseconds delay between each repeat. (default: \
               250)."]
        interactionMarkerName : string option;
            [@key "interactionMarkerName"]
            [@yojson.option]
            [@ocaml.doc
              "The name of the interaction markers to generate, if not empty \
               (default: \"\")."]
      }
      [@@deriving yojson]

      let make ~x ~y ?xDistance ?yDistance ?xOverscroll ?yOverscroll
          ?preventFling ?speed ?gestureSourceType ?repeatCount ?repeatDelayMs
          ?interactionMarkerName () =
        {
          x;
          y;
          xDistance;
          yDistance;
          xOverscroll;
          yOverscroll;
          preventFling;
          speed;
          gestureSourceType;
          repeatCount;
          repeatDelayMs;
          interactionMarkerName;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.synthesizeScrollGesture"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Synthesizes a tap gesture over a time period by issuing appropriate touch events. *)
  module SynthesizeTapGesture = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        x : Types.number;
            [@key "x"]
            [@ocaml.doc
              "X coordinate of the start of the gesture in CSS pixels."]
        y : Types.number;
            [@key "y"]
            [@ocaml.doc
              "Y coordinate of the start of the gesture in CSS pixels."]
        duration : Types.number option;
            [@key "duration"]
            [@yojson.option]
            [@ocaml.doc
              "Duration between touchdown and touchup events in ms (default: \
               50)."]
        tapCount : Types.number option;
            [@key "tapCount"]
            [@yojson.option]
            [@ocaml.doc
              "Number of times to perform the tap (e.g. 2 for double tap, \
               default: 1)."]
        gestureSourceType : Types.Input.GestureSourceType.t option;
            [@key "gestureSourceType"]
            [@yojson.option]
            [@ocaml.doc
              "Which type of input events to be generated (default: 'default', \
               which queries the platform\n\
               for the preferred input type)."]
      }
      [@@deriving yojson]

      let make ~x ~y ?duration ?tapCount ?gestureSourceType () =
        { x; y; duration; tapCount; gestureSourceType }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.synthesizeTapGesture"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Inspector = struct
  (* Disables inspector domain notifications. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Inspector.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables inspector domain notifications. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Inspector.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module LayerTree = struct
  (* Provides the reasons why the given layer was composited. *)
  module CompositingReasons = struct
    module Response : sig
      type result = {
        compositingReasons : string list;
            [@key "compositingReasons"]
            [@ocaml.doc
              "A list of strings specifying reasons for the given layer to \
               become composited."]
        compositingReasonIds : string list;
            [@key "compositingReasonIds"]
            [@ocaml.doc
              "A list of strings specifying reason IDs for the given layer to \
               become composited."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        compositingReasons : string list;
            [@key "compositingReasons"]
            [@ocaml.doc
              "A list of strings specifying reasons for the given layer to \
               become composited."]
        compositingReasonIds : string list;
            [@key "compositingReasonIds"]
            [@ocaml.doc
              "A list of strings specifying reason IDs for the given layer to \
               become composited."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        layerId : Types.LayerTree.LayerId.t;
            [@key "layerId"]
            [@ocaml.doc
              "The id of the layer for which we want to get the reasons it was \
               composited."]
      }
      [@@deriving yojson]

      let make ~layerId () = { layerId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.compositingReasons"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables compositing tree inspection. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "LayerTree.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables compositing tree inspection. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "LayerTree.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the snapshot identifier. *)
  module LoadSnapshot = struct
    module Response : sig
      type result = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the snapshot."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the snapshot."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        tiles : Types.LayerTree.PictureTile.t list;
            [@key "tiles"]
            [@ocaml.doc "An array of tiles composing the snapshot."]
      }
      [@@deriving yojson]

      let make ~tiles () = { tiles }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.loadSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the layer snapshot identifier. *)
  module MakeSnapshot = struct
    module Response : sig
      type result = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the layer snapshot."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the layer snapshot."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        layerId : Types.LayerTree.LayerId.t;
            [@key "layerId"] [@ocaml.doc "The id of the layer."]
      }
      [@@deriving yojson]

      let make ~layerId () = { layerId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.makeSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module ProfileSnapshot = struct
    module Response : sig
      type result = {
        timings : Types.LayerTree.PaintProfile.t list;
            [@key "timings"]
            [@ocaml.doc "The array of paint profiles, one per run."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        timings : Types.LayerTree.PaintProfile.t list;
            [@key "timings"]
            [@ocaml.doc "The array of paint profiles, one per run."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the layer snapshot."]
        minRepeatCount : Types.number option;
            [@key "minRepeatCount"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum number of times to replay the snapshot (1, if not \
               specified)."]
        minDuration : Types.number option;
            [@key "minDuration"]
            [@yojson.option]
            [@ocaml.doc
              "The minimum duration (in seconds) to replay the snapshot."]
        clipRect : Types.DOM.Rect.t option;
            [@key "clipRect"]
            [@yojson.option]
            [@ocaml.doc
              "The clip rectangle to apply when replaying the snapshot."]
      }
      [@@deriving yojson]

      let make ~snapshotId ?minRepeatCount ?minDuration ?clipRect () =
        { snapshotId; minRepeatCount; minDuration; clipRect }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.profileSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Releases layer snapshot captured by the back-end. *)
  module ReleaseSnapshot = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the layer snapshot."]
      }
      [@@deriving yojson]

      let make ~snapshotId () = { snapshotId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.releaseSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Replays the layer snapshot and returns the resulting bitmap. *)
  module ReplaySnapshot = struct
    module Response : sig
      type result = {
        dataURL : string;
            [@key "dataURL"] [@ocaml.doc "A data: URL for resulting image."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        dataURL : string;
            [@key "dataURL"] [@ocaml.doc "A data: URL for resulting image."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the layer snapshot."]
        fromStep : Types.number option;
            [@key "fromStep"]
            [@yojson.option]
            [@ocaml.doc
              "The first step to replay from (replay from the very start if \
               not specified)."]
        toStep : Types.number option;
            [@key "toStep"]
            [@yojson.option]
            [@ocaml.doc
              "The last step to replay to (replay till the end if not \
               specified)."]
        scale : Types.number option;
            [@key "scale"]
            [@yojson.option]
            [@ocaml.doc "The scale to apply while replaying (defaults to 1)."]
      }
      [@@deriving yojson]

      let make ~snapshotId ?fromStep ?toStep ?scale () =
        { snapshotId; fromStep; toStep; scale }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.replaySnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Replays the layer snapshot and returns canvas log. *)
  module SnapshotCommandLog = struct
    module Response : sig
      type result = {
        commandLog : Types.assoc list;
            [@key "commandLog"]
            [@ocaml.doc "The array of canvas function calls."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        commandLog : Types.assoc list;
            [@key "commandLog"]
            [@ocaml.doc "The array of canvas function calls."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the layer snapshot."]
      }
      [@@deriving yojson]

      let make ~snapshotId () = { snapshotId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.snapshotCommandLog"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Log = struct
  (* Clears the log. *)
  module Clear = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Log.clear"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables log domain, prevents further log entries from being reported to the client. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Log.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables log domain, sends the entries collected so far to the client by means of the
     `entryAdded` notification. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Log.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* start violation reporting. *)
  module StartViolationsReport = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        config : Types.Log.ViolationSetting.t list;
            [@key "config"] [@ocaml.doc "Configuration for violations."]
      }
      [@@deriving yojson]

      let make ~config () = { config }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Log.startViolationsReport"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Stop violation reporting. *)
  module StopViolationsReport = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Log.stopViolationsReport"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Memory = struct
  (* No description provided *)
  module GetDOMCounters = struct
    module Response : sig
      type result = {
        documents : Types.number;
            [@key "documents"] [@ocaml.doc "No description provided"]
        nodes : Types.number;
            [@key "nodes"] [@ocaml.doc "No description provided"]
        jsEventListeners : Types.number;
            [@key "jsEventListeners"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        documents : Types.number;
            [@key "documents"] [@ocaml.doc "No description provided"]
        nodes : Types.number;
            [@key "nodes"] [@ocaml.doc "No description provided"]
        jsEventListeners : Types.number;
            [@key "jsEventListeners"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.getDOMCounters"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module PrepareForLeakDetection = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.prepareForLeakDetection"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Simulate OomIntervention by purging V8 memory. *)
  module ForciblyPurgeJavaScriptMemory = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.forciblyPurgeJavaScriptMemory"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enable/disable suppressing memory pressure notifications in all processes. *)
  module SetPressureNotificationsSuppressed = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        suppressed : bool;
            [@key "suppressed"]
            [@ocaml.doc
              "If true, memory pressure notifications will be suppressed."]
      }
      [@@deriving yojson]

      let make ~suppressed () = { suppressed }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Memory.setPressureNotificationsSuppressed";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Simulate a memory pressure notification in all processes. *)
  module SimulatePressureNotification = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        level : Types.Memory.PressureLevel.t;
            [@key "level"]
            [@ocaml.doc "Memory pressure level of the notification."]
      }
      [@@deriving yojson]

      let make ~level () = { level }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Memory.simulatePressureNotification";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Start collecting native memory profile. *)
  module StartSampling = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        samplingInterval : Types.number option;
            [@key "samplingInterval"]
            [@yojson.option]
            [@ocaml.doc "Average number of bytes between samples."]
        suppressRandomness : bool option;
            [@key "suppressRandomness"]
            [@yojson.option]
            [@ocaml.doc "Do not randomize intervals between samples."]
      }
      [@@deriving yojson]

      let make ?samplingInterval ?suppressRandomness () =
        { samplingInterval; suppressRandomness }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Memory.startSampling"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Stop collecting native memory profile. *)
  module StopSampling = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.stopSampling"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Retrieve native memory allocations profile
     collected since renderer process startup. *)
  module GetAllTimeSamplingProfile = struct
    module Response : sig
      type result = {
        profile : Types.Memory.SamplingProfile.t;
            [@key "profile"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        profile : Types.Memory.SamplingProfile.t;
            [@key "profile"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.getAllTimeSamplingProfile"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Retrieve native memory allocations profile
     collected since browser process startup. *)
  module GetBrowserSamplingProfile = struct
    module Response : sig
      type result = {
        profile : Types.Memory.SamplingProfile.t;
            [@key "profile"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        profile : Types.Memory.SamplingProfile.t;
            [@key "profile"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.getBrowserSamplingProfile"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Retrieve native memory allocations profile collected since last
     `startSampling` call. *)
  module GetSamplingProfile = struct
    module Response : sig
      type result = {
        profile : Types.Memory.SamplingProfile.t;
            [@key "profile"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        profile : Types.Memory.SamplingProfile.t;
            [@key "profile"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.getSamplingProfile"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Network = struct
  (* Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted. *)
  module SetAcceptedEncodings = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        encodings : Types.Network.ContentEncoding.t list;
            [@key "encodings"]
            [@ocaml.doc "List of accepted content encodings."]
      }
      [@@deriving yojson]

      let make ~encodings () = { encodings }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setAcceptedEncodings"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears accepted encodings set by setAcceptedEncodings *)
  module ClearAcceptedEncodingsOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.clearAcceptedEncodingsOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Tells whether clearing browser cache is supported. *)
  module CanClearBrowserCache = struct
    module Response : sig
      type result = {
        result : bool;
            [@key "result"] [@ocaml.doc "True if browser cache can be cleared."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : bool;
            [@key "result"] [@ocaml.doc "True if browser cache can be cleared."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.canClearBrowserCache"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Tells whether clearing browser cookies is supported. *)
  module CanClearBrowserCookies = struct
    module Response : sig
      type result = {
        result : bool;
            [@key "result"]
            [@ocaml.doc "True if browser cookies can be cleared."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : bool;
            [@key "result"]
            [@ocaml.doc "True if browser cookies can be cleared."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.canClearBrowserCookies"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Tells whether emulation of network conditions is supported. *)
  module CanEmulateNetworkConditions = struct
    module Response : sig
      type result = {
        result : bool;
            [@key "result"]
            [@ocaml.doc "True if emulation of network conditions is supported."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : bool;
            [@key "result"]
            [@ocaml.doc "True if emulation of network conditions is supported."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.canEmulateNetworkConditions"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears browser cache. *)
  module ClearBrowserCache = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.clearBrowserCache"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears browser cookies. *)
  module ClearBrowserCookies = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.clearBrowserCookies"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Response to Network.requestIntercepted which either modifies the request to continue with any
     modifications, or blocks it, or completes it with the provided response bytes. If a network
     fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
     event will be sent with the same InterceptionId.
     Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead. *)
  module ContinueInterceptedRequest = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        interceptionId : Types.Network.InterceptionId.t;
            [@key "interceptionId"] [@ocaml.doc "No description provided"]
        errorReason : Types.Network.ErrorReason.t option;
            [@key "errorReason"]
            [@yojson.option]
            [@ocaml.doc
              "If set this causes the request to fail with the given reason. \
               Passing `Aborted` for requests\n\
               marked with `isNavigationRequest` also cancels the navigation. \
               Must not be set in response\n\
               to an authChallenge."]
        rawResponse : string option;
            [@key "rawResponse"]
            [@yojson.option]
            [@ocaml.doc
              "If set the requests completes using with the provided base64 \
               encoded raw response, including\n\
               HTTP status line and headers etc... Must not be set in response \
               to an authChallenge. (Encoded as a base64 string when passed \
               over JSON)"]
        url : string option;
            [@key "url"]
            [@yojson.option]
            [@ocaml.doc
              "If set the request url will be modified in a way that's not \
               observable by page. Must not be\n\
               set in response to an authChallenge."]
        method_ : string option;
            [@key "method"]
            [@yojson.option]
            [@ocaml.doc
              "If set this allows the request method to be overridden. Must \
               not be set in response to an\n\
               authChallenge."]
        postData : string option;
            [@key "postData"]
            [@yojson.option]
            [@ocaml.doc
              "If set this allows postData to be set. Must not be set in \
               response to an authChallenge."]
        headers : Types.Network.Headers.t option;
            [@key "headers"]
            [@yojson.option]
            [@ocaml.doc
              "If set this allows the request headers to be changed. Must not \
               be set in response to an\n\
               authChallenge."]
        authChallengeResponse : Types.Network.AuthChallengeResponse.t option;
            [@key "authChallengeResponse"]
            [@yojson.option]
            [@ocaml.doc
              "Response to a requestIntercepted with an authChallenge. Must \
               not be set otherwise."]
      }
      [@@deriving yojson]

      let make ~interceptionId ?errorReason ?rawResponse ?url ?method_ ?postData
          ?headers ?authChallengeResponse () =
        {
          interceptionId;
          errorReason;
          rawResponse;
          url;
          method_;
          postData;
          headers;
          authChallengeResponse;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Network.continueInterceptedRequest";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Deletes browser cookies with matching name and url or domain/path pair. *)
  module DeleteCookies = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        name : string;
            [@key "name"] [@ocaml.doc "Name of the cookies to remove."]
        url : string option;
            [@key "url"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, deletes all the cookies with the given name where \
               domain and path match\n\
               provided URL."]
        domain : string option;
            [@key "domain"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, deletes only cookies with the exact domain."]
        path : string option;
            [@key "path"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, deletes only cookies with the exact path."]
      }
      [@@deriving yojson]

      let make ~name ?url ?domain ?path () = { name; url; domain; path }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.deleteCookies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables network tracking, prevents network events from being sent to the client. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Activates emulation of network conditions. *)
  module EmulateNetworkConditions = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        offline : bool;
            [@key "offline"]
            [@ocaml.doc "True to emulate internet disconnection."]
        latency : Types.number;
            [@key "latency"]
            [@ocaml.doc
              "Minimum latency from request sent to response headers received \
               (ms)."]
        downloadThroughput : Types.number;
            [@key "downloadThroughput"]
            [@ocaml.doc
              "Maximal aggregated download throughput (bytes/sec). -1 disables \
               download throttling."]
        uploadThroughput : Types.number;
            [@key "uploadThroughput"]
            [@ocaml.doc
              "Maximal aggregated upload throughput (bytes/sec).  -1 disables \
               upload throttling."]
        connectionType : Types.Network.ConnectionType.t option;
            [@key "connectionType"]
            [@yojson.option]
            [@ocaml.doc "Connection type if known."]
      }
      [@@deriving yojson]

      let make ~offline ~latency ~downloadThroughput ~uploadThroughput
          ?connectionType () =
        {
          offline;
          latency;
          downloadThroughput;
          uploadThroughput;
          connectionType;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.emulateNetworkConditions"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables network tracking, network events will now be delivered to the client. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        maxTotalBufferSize : Types.number option;
            [@key "maxTotalBufferSize"]
            [@yojson.option]
            [@ocaml.doc
              "Buffer size in bytes to use when preserving network payloads \
               (XHRs, etc)."]
        maxResourceBufferSize : Types.number option;
            [@key "maxResourceBufferSize"]
            [@yojson.option]
            [@ocaml.doc
              "Per-resource buffer size in bytes to use when preserving \
               network payloads (XHRs, etc)."]
        maxPostDataSize : Types.number option;
            [@key "maxPostDataSize"]
            [@yojson.option]
            [@ocaml.doc
              "Longest post body size (in bytes) that would be included in \
               requestWillBeSent notification"]
      }
      [@@deriving yojson]

      let make ?maxTotalBufferSize ?maxResourceBufferSize ?maxPostDataSize () =
        { maxTotalBufferSize; maxResourceBufferSize; maxPostDataSize }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns all browser cookies. Depending on the backend support, will return detailed cookie
     information in the `cookies` field.
     Deprecated. Use Storage.getCookies instead. *)
  module GetAllCookies = struct
    module Response : sig
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.getAllCookies"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the DER-encoded certificate. *)
  module GetCertificate = struct
    module Response : sig
      type result = {
        tableNames : string list;
            [@key "tableNames"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        tableNames : string list;
            [@key "tableNames"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string;
            [@key "origin"] [@ocaml.doc "Origin to get certificate for."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.getCertificate"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns all browser cookies for the current URL. Depending on the backend support, will return
     detailed cookie information in the `cookies` field. *)
  module GetCookies = struct
    module Response : sig
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        urls : string list option;
            [@key "urls"]
            [@yojson.option]
            [@ocaml.doc
              "The list of URLs for which applicable cookies will be fetched.\n\
               If not specified, it's assumed to be set to the list containing\n\
               the URLs of the page and all of its subframes."]
      }
      [@@deriving yojson]

      let make ?urls () = { urls }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.getCookies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns content served for the given request. *)
  module GetResponseBody = struct
    module Response : sig
      type result = {
        body : string; [@key "body"] [@ocaml.doc "Response body."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        body : string; [@key "body"] [@ocaml.doc "Response body."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Network.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "Identifier of the network request to get content for."]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.getResponseBody"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns post data sent with the request. Returns an error when no data was sent with the request. *)
  module GetRequestPostData = struct
    module Response : sig
      type result = {
        postData : string;
            [@key "postData"]
            [@ocaml.doc
              "Request body string, omitting files from multipart requests"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        postData : string;
            [@key "postData"]
            [@ocaml.doc
              "Request body string, omitting files from multipart requests"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Network.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "Identifier of the network request to get content for."]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.getRequestPostData"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns content served for the given currently intercepted request. *)
  module GetResponseBodyForInterception = struct
    module Response : sig
      type result = {
        body : string; [@key "body"] [@ocaml.doc "Response body."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        body : string; [@key "body"] [@ocaml.doc "Response body."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        interceptionId : Types.Network.InterceptionId.t;
            [@key "interceptionId"]
            [@ocaml.doc
              "Identifier for the intercepted request to get body for."]
      }
      [@@deriving yojson]

      let make ~interceptionId () = { interceptionId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Network.getResponseBodyForInterception";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns a handle to the stream representing the response body. Note that after this command,
     the intercepted request can't be continued as is -- you either need to cancel it or to provide
     the response body. The stream only supports sequential read, IO.read will fail if the position
     is specified. *)
  module TakeResponseBodyForInterceptionAsStream = struct
    module Response : sig
      type result = {
        stream : Types.IO.StreamHandle.t;
            [@key "stream"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        stream : Types.IO.StreamHandle.t;
            [@key "stream"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        interceptionId : Types.Network.InterceptionId.t;
            [@key "interceptionId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~interceptionId () = { interceptionId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Network.takeResponseBodyForInterceptionAsStream";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* This method sends a new XMLHttpRequest which is identical to the original one. The following
     parameters should be identical: method, url, async, request body, extra headers, withCredentials
     attribute, user, password. *)
  module ReplayXHR = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Network.RequestId.t;
            [@key "requestId"] [@ocaml.doc "Identifier of XHR to replay."]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.replayXHR"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Searches for given string in response content. *)
  module SearchInResponseBody = struct
    module Response : sig
      type result = {
        result : Types.Debugger.SearchMatch.t list;
            [@key "result"] [@ocaml.doc "List of search matches."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Debugger.SearchMatch.t list;
            [@key "result"] [@ocaml.doc "List of search matches."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Network.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "Identifier of the network response to search."]
        query : string; [@key "query"] [@ocaml.doc "String to search for."]
        caseSensitive : bool option;
            [@key "caseSensitive"]
            [@yojson.option]
            [@ocaml.doc "If true, search is case sensitive."]
        isRegex : bool option;
            [@key "isRegex"]
            [@yojson.option]
            [@ocaml.doc "If true, treats string parameter as regex."]
      }
      [@@deriving yojson]

      let make ~requestId ~query ?caseSensitive ?isRegex () =
        { requestId; query; caseSensitive; isRegex }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.searchInResponseBody"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Blocks URLs from loading. *)
  module SetBlockedURLs = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        urls : string list;
            [@key "urls"]
            [@ocaml.doc "URL patterns to block. Wildcards ('*') are allowed."]
      }
      [@@deriving yojson]

      let make ~urls () = { urls }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setBlockedURLs"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Toggles ignoring of service worker for each request. *)
  module SetBypassServiceWorker = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        bypass : bool;
            [@key "bypass"]
            [@ocaml.doc "Bypass service worker and load from network."]
      }
      [@@deriving yojson]

      let make ~bypass () = { bypass }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setBypassServiceWorker"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Toggles ignoring cache for each request. If `true`, cache will not be used. *)
  module SetCacheDisabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cacheDisabled : bool;
            [@key "cacheDisabled"] [@ocaml.doc "Cache disabled state."]
      }
      [@@deriving yojson]

      let make ~cacheDisabled () = { cacheDisabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setCacheDisabled"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist. *)
  module SetCookie = struct
    module Response : sig
      type result = {
        success : bool;
            [@key "success"]
            [@ocaml.doc
              "Always set to true. If an error occurs, the response indicates \
               protocol error."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        success : bool;
            [@key "success"]
            [@ocaml.doc
              "Always set to true. If an error occurs, the response indicates \
               protocol error."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        name : string; [@key "name"] [@ocaml.doc "Cookie name."]
        value : string; [@key "value"] [@ocaml.doc "Cookie value."]
        url : string option;
            [@key "url"]
            [@yojson.option]
            [@ocaml.doc
              "The request-URI to associate with the setting of the cookie. \
               This value can affect the\n\
               default domain, path, source port, and source scheme values of \
               the created cookie."]
        domain : string option;
            [@key "domain"] [@yojson.option] [@ocaml.doc "Cookie domain."]
        path : string option;
            [@key "path"] [@yojson.option] [@ocaml.doc "Cookie path."]
        secure : bool option;
            [@key "secure"]
            [@yojson.option]
            [@ocaml.doc "True if cookie is secure."]
        httpOnly : bool option;
            [@key "httpOnly"]
            [@yojson.option]
            [@ocaml.doc "True if cookie is http-only."]
        sameSite : Types.Network.CookieSameSite.t option;
            [@key "sameSite"]
            [@yojson.option]
            [@ocaml.doc "Cookie SameSite type."]
        expires : Types.Network.TimeSinceEpoch.t option;
            [@key "expires"]
            [@yojson.option]
            [@ocaml.doc "Cookie expiration date, session cookie if not set"]
        priority : Types.Network.CookiePriority.t option;
            [@key "priority"]
            [@yojson.option]
            [@ocaml.doc "Cookie Priority type."]
        sameParty : bool option;
            [@key "sameParty"]
            [@yojson.option]
            [@ocaml.doc "True if cookie is SameParty."]
        sourceScheme : Types.Network.CookieSourceScheme.t option;
            [@key "sourceScheme"]
            [@yojson.option]
            [@ocaml.doc "Cookie source scheme type."]
        sourcePort : Types.number option;
            [@key "sourcePort"]
            [@yojson.option]
            [@ocaml.doc
              "Cookie source port. Valid values are {-1, [1, 65535]}, -1 \
               indicates an unspecified port.\n\
               An unspecified port value allows protocol clients to emulate \
               legacy cookie scope for the port.\n\
               This is a temporary ability and it will be removed in the \
               future."]
        partitionKey : string option;
            [@key "partitionKey"]
            [@yojson.option]
            [@ocaml.doc
              "Cookie partition key. The site of the top-level URL the browser \
               was visiting at the start\n\
               of the request to the endpoint that set the cookie.\n\
               If not set, the cookie will be set as not partitioned."]
      }
      [@@deriving yojson]

      let make ~name ~value ?url ?domain ?path ?secure ?httpOnly ?sameSite
          ?expires ?priority ?sameParty ?sourceScheme ?sourcePort ?partitionKey
          () =
        {
          name;
          value;
          url;
          domain;
          path;
          secure;
          httpOnly;
          sameSite;
          expires;
          priority;
          sameParty;
          sourceScheme;
          sourcePort;
          partitionKey;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setCookie"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets given cookies. *)
  module SetCookies = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cookies : Types.Network.CookieParam.t list;
            [@key "cookies"] [@ocaml.doc "Cookies to be set."]
      }
      [@@deriving yojson]

      let make ~cookies () = { cookies }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setCookies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Specifies whether to always send extra HTTP headers with the requests from this page. *)
  module SetExtraHTTPHeaders = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        headers : Types.Network.Headers.t;
            [@key "headers"] [@ocaml.doc "Map with extra HTTP headers."]
      }
      [@@deriving yojson]

      let make ~headers () = { headers }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setExtraHTTPHeaders"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Specifies whether to attach a page script stack id in requests *)
  module SetAttachDebugStack = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc
              "Whether to attach a page script stack for debugging purpose."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setAttachDebugStack"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets the requests to intercept that match the provided patterns and optionally resource types.
     Deprecated, please use Fetch.enable instead. *)
  module SetRequestInterception = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        patterns : Types.Network.RequestPattern.t list;
            [@key "patterns"]
            [@ocaml.doc
              "Requests matching any of these patterns will be forwarded and \
               wait for the corresponding\n\
               continueInterceptedRequest call."]
      }
      [@@deriving yojson]

      let make ~patterns () = { patterns }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setRequestInterception"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Allows overriding user agent with the given string. *)
  module SetUserAgentOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        userAgent : string; [@key "userAgent"] [@ocaml.doc "User agent to use."]
        acceptLanguage : string option;
            [@key "acceptLanguage"]
            [@yojson.option]
            [@ocaml.doc "Browser langugage to emulate."]
        platform : string option;
            [@key "platform"]
            [@yojson.option]
            [@ocaml.doc "The platform navigator.platform should return."]
        userAgentMetadata : Types.Emulation.UserAgentMetadata.t option;
            [@key "userAgentMetadata"]
            [@yojson.option]
            [@ocaml.doc
              "To be sent in Sec-CH-UA-* headers and returned in \
               navigator.userAgentData"]
      }
      [@@deriving yojson]

      let make ~userAgent ?acceptLanguage ?platform ?userAgentMetadata () =
        { userAgent; acceptLanguage; platform; userAgentMetadata }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setUserAgentOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns information about the COEP/COOP isolation status. *)
  module GetSecurityIsolationStatus = struct
    module Response : sig
      type result = {
        status : Types.Network.SecurityIsolationStatus.t;
            [@key "status"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        status : Types.Network.SecurityIsolationStatus.t;
            [@key "status"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc
              "If no frameId is provided, the status of the target is provided."]
      }
      [@@deriving yojson]

      let make ?frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Network.getSecurityIsolationStatus";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
     Enabling triggers 'reportingApiReportAdded' for all existing reports. *)
  module EnableReportingApi = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enable : bool;
            [@key "enable"]
            [@ocaml.doc
              "Whether to enable or disable events for the Reporting API"]
      }
      [@@deriving yojson]

      let make ~enable () = { enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.enableReportingApi"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Fetches the resource and returns the content. *)
  module LoadNetworkResource = struct
    module Response : sig
      type result = {
        resource : Types.Network.LoadNetworkResourcePageResult.t;
            [@key "resource"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        resource : Types.Network.LoadNetworkResourcePageResult.t;
            [@key "resource"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc
              "Frame id to get the resource for. Mandatory for frame targets, \
               and\n\
               should be omitted for worker targets."]
        url : string;
            [@key "url"] [@ocaml.doc "URL of the resource to get content for."]
        options : Types.Network.LoadNetworkResourceOptions.t;
            [@key "options"] [@ocaml.doc "Options for the request."]
      }
      [@@deriving yojson]

      let make ?frameId ~url ~options () = { frameId; url; options }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.loadNetworkResource"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Overlay = struct
  (* Disables domain notifications. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Overlay.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables domain notifications. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Overlay.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* For testing. *)
  module GetHighlightObjectForTest = struct
    module Response : sig
      type result = {
        highlight : Types.assoc;
            [@key "highlight"] [@ocaml.doc "Highlight data for the node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        highlight : Types.assoc;
            [@key "highlight"] [@ocaml.doc "Highlight data for the node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the node to get highlight object for."]
        includeDistance : bool option;
            [@key "includeDistance"]
            [@yojson.option]
            [@ocaml.doc "Whether to include distance info."]
        includeStyle : bool option;
            [@key "includeStyle"]
            [@yojson.option]
            [@ocaml.doc "Whether to include style info."]
        colorFormat : Types.Overlay.ColorFormat.t option;
            [@key "colorFormat"]
            [@yojson.option]
            [@ocaml.doc "The color format to get config with (default: hex)."]
        showAccessibilityInfo : bool option;
            [@key "showAccessibilityInfo"]
            [@yojson.option]
            [@ocaml.doc "Whether to show accessibility info (default: true)."]
      }
      [@@deriving yojson]

      let make ~nodeId ?includeDistance ?includeStyle ?colorFormat
          ?showAccessibilityInfo () =
        {
          nodeId;
          includeDistance;
          includeStyle;
          colorFormat;
          showAccessibilityInfo;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.getHighlightObjectForTest"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* For Persistent Grid testing. *)
  module GetGridHighlightObjectsForTest = struct
    module Response : sig
      type result = {
        highlights : Types.assoc;
            [@key "highlights"]
            [@ocaml.doc "Grid Highlight data for the node ids provided."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        highlights : Types.assoc;
            [@key "highlights"]
            [@ocaml.doc "Grid Highlight data for the node ids provided."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc "Ids of the node to get highlight object for."]
      }
      [@@deriving yojson]

      let make ~nodeIds () = { nodeIds }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.getGridHighlightObjectsForTest";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* For Source Order Viewer testing. *)
  module GetSourceOrderHighlightObjectForTest = struct
    module Response : sig
      type result = {
        highlight : Types.assoc;
            [@key "highlight"]
            [@ocaml.doc "Source order highlight data for the node id provided."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        highlight : Types.assoc;
            [@key "highlight"]
            [@ocaml.doc "Source order highlight data for the node id provided."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to highlight."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.getSourceOrderHighlightObjectForTest";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Hides any highlight. *)
  module HideHighlight = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Overlay.hideHighlight"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Highlights owner element of the frame with given id.
     Deprecated: Doesn't work reliablity and cannot be fixed due to process
     separatation (the owner node might be in a different process). Determine
     the owner node in the client and use highlightNode. *)
  module HighlightFrame = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"]
            [@ocaml.doc "Identifier of the frame to highlight."]
        contentColor : Types.DOM.RGBA.t option;
            [@key "contentColor"]
            [@yojson.option]
            [@ocaml.doc
              "The content box highlight fill color (default: transparent)."]
        contentOutlineColor : Types.DOM.RGBA.t option;
            [@key "contentOutlineColor"]
            [@yojson.option]
            [@ocaml.doc
              "The content box highlight outline color (default: transparent)."]
      }
      [@@deriving yojson]

      let make ~frameId ?contentColor ?contentOutlineColor () =
        { frameId; contentColor; contentOutlineColor }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.highlightFrame"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
     objectId must be specified. *)
  module HighlightNode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        highlightConfig : Types.Overlay.HighlightConfig.t;
            [@key "highlightConfig"]
            [@ocaml.doc "A descriptor for the highlight appearance."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node to highlight."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node to highlight."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node to be highlighted."]
        selector : string option;
            [@key "selector"]
            [@yojson.option]
            [@ocaml.doc "Selectors to highlight relevant nodes."]
      }
      [@@deriving yojson]

      let make ~highlightConfig ?nodeId ?backendNodeId ?objectId ?selector () =
        { highlightConfig; nodeId; backendNodeId; objectId; selector }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.highlightNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Highlights given quad. Coordinates are absolute with respect to the main frame viewport. *)
  module HighlightQuad = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        quad : Types.DOM.Quad.t; [@key "quad"] [@ocaml.doc "Quad to highlight"]
        color : Types.DOM.RGBA.t option;
            [@key "color"]
            [@yojson.option]
            [@ocaml.doc "The highlight fill color (default: transparent)."]
        outlineColor : Types.DOM.RGBA.t option;
            [@key "outlineColor"]
            [@yojson.option]
            [@ocaml.doc "The highlight outline color (default: transparent)."]
      }
      [@@deriving yojson]

      let make ~quad ?color ?outlineColor () = { quad; color; outlineColor }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.highlightQuad"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport. *)
  module HighlightRect = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        x : Types.number; [@key "x"] [@ocaml.doc "X coordinate"]
        y : Types.number; [@key "y"] [@ocaml.doc "Y coordinate"]
        width : Types.number; [@key "width"] [@ocaml.doc "Rectangle width"]
        height : Types.number; [@key "height"] [@ocaml.doc "Rectangle height"]
        color : Types.DOM.RGBA.t option;
            [@key "color"]
            [@yojson.option]
            [@ocaml.doc "The highlight fill color (default: transparent)."]
        outlineColor : Types.DOM.RGBA.t option;
            [@key "outlineColor"]
            [@yojson.option]
            [@ocaml.doc "The highlight outline color (default: transparent)."]
      }
      [@@deriving yojson]

      let make ~x ~y ~width ~height ?color ?outlineColor () =
        { x; y; width; height; color; outlineColor }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.highlightRect"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Highlights the source order of the children of the DOM node with given id or with the given
     JavaScript object wrapper. Either nodeId or objectId must be specified. *)
  module HighlightSourceOrder = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sourceOrderConfig : Types.Overlay.SourceOrderConfig.t;
            [@key "sourceOrderConfig"]
            [@ocaml.doc
              "A descriptor for the appearance of the overlay drawing."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node to highlight."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node to highlight."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node to be highlighted."]
      }
      [@@deriving yojson]

      let make ~sourceOrderConfig ?nodeId ?backendNodeId ?objectId () =
        { sourceOrderConfig; nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.highlightSourceOrder"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
     Backend then generates 'inspectNodeRequested' event upon element selection. *)
  module SetInspectMode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        mode : Types.Overlay.InspectMode.t;
            [@key "mode"] [@ocaml.doc "Set an inspection mode."]
        highlightConfig : Types.Overlay.HighlightConfig.t option;
            [@key "highlightConfig"]
            [@yojson.option]
            [@ocaml.doc
              "A descriptor for the highlight appearance of hovered-over \
               nodes. May be omitted if `enabled\n\
               == false`."]
      }
      [@@deriving yojson]

      let make ~mode ?highlightConfig () = { mode; highlightConfig }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setInspectMode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Highlights owner element of all frames detected to be ads. *)
  module SetShowAdHighlights = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool; [@key "show"] [@ocaml.doc "True for showing ad highlights"]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowAdHighlights"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetPausedInDebuggerMessage = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        message : string option;
            [@key "message"]
            [@yojson.option]
            [@ocaml.doc
              "The message to display, also triggers resume and step over \
               controls."]
      }
      [@@deriving yojson]

      let make ?message () = { message }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.setPausedInDebuggerMessage";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests that backend shows debug borders on layers *)
  module SetShowDebugBorders = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool; [@key "show"] [@ocaml.doc "True for showing debug borders"]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowDebugBorders"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests that backend shows the FPS counter *)
  module SetShowFPSCounter = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool;
            [@key "show"] [@ocaml.doc "True for showing the FPS counter"]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowFPSCounter"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Highlight multiple elements with the CSS Grid overlay. *)
  module SetShowGridOverlays = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        gridNodeHighlightConfigs : Types.Overlay.GridNodeHighlightConfig.t list;
            [@key "gridNodeHighlightConfigs"]
            [@ocaml.doc
              "An array of node identifiers and descriptors for the highlight \
               appearance."]
      }
      [@@deriving yojson]

      let make ~gridNodeHighlightConfigs () = { gridNodeHighlightConfigs }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowGridOverlays"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetShowFlexOverlays = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        flexNodeHighlightConfigs : Types.Overlay.FlexNodeHighlightConfig.t list;
            [@key "flexNodeHighlightConfigs"]
            [@ocaml.doc
              "An array of node identifiers and descriptors for the highlight \
               appearance."]
      }
      [@@deriving yojson]

      let make ~flexNodeHighlightConfigs () = { flexNodeHighlightConfigs }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowFlexOverlays"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetShowScrollSnapOverlays = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scrollSnapHighlightConfigs :
          Types.Overlay.ScrollSnapHighlightConfig.t list;
            [@key "scrollSnapHighlightConfigs"]
            [@ocaml.doc
              "An array of node identifiers and descriptors for the highlight \
               appearance."]
      }
      [@@deriving yojson]

      let make ~scrollSnapHighlightConfigs () = { scrollSnapHighlightConfigs }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowScrollSnapOverlays"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetShowContainerQueryOverlays = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        containerQueryHighlightConfigs :
          Types.Overlay.ContainerQueryHighlightConfig.t list;
            [@key "containerQueryHighlightConfigs"]
            [@ocaml.doc
              "An array of node identifiers and descriptors for the highlight \
               appearance."]
      }
      [@@deriving yojson]

      let make ~containerQueryHighlightConfigs () =
        { containerQueryHighlightConfigs }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.setShowContainerQueryOverlays";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests that backend shows paint rectangles *)
  module SetShowPaintRects = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        result : bool;
            [@key "result"] [@ocaml.doc "True for showing paint rectangles"]
      }
      [@@deriving yojson]

      let make ~result () = { result }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowPaintRects"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests that backend shows layout shift regions *)
  module SetShowLayoutShiftRegions = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        result : bool;
            [@key "result"] [@ocaml.doc "True for showing layout shift regions"]
      }
      [@@deriving yojson]

      let make ~result () = { result }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowLayoutShiftRegions"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests that backend shows scroll bottleneck rects *)
  module SetShowScrollBottleneckRects = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool;
            [@key "show"]
            [@ocaml.doc "True for showing scroll bottleneck rects"]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.setShowScrollBottleneckRects";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Deprecated, no longer has any effect. *)
  module SetShowHitTestBorders = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool;
            [@key "show"] [@ocaml.doc "True for showing hit-test borders"]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowHitTestBorders"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Request that backend shows an overlay with web vital metrics. *)
  module SetShowWebVitals = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool; [@key "show"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowWebVitals"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Paints viewport size upon main frame resize. *)
  module SetShowViewportSizeOnResize = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool; [@key "show"] [@ocaml.doc "Whether to paint size or not."]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.setShowViewportSizeOnResize";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Add a dual screen device hinge *)
  module SetShowHinge = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        hingeConfig : Types.Overlay.HingeConfig.t option;
            [@key "hingeConfig"]
            [@yojson.option]
            [@ocaml.doc "hinge data, null means hideHinge"]
      }
      [@@deriving yojson]

      let make ?hingeConfig () = { hingeConfig }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowHinge"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Show elements in isolation mode with overlays. *)
  module SetShowIsolatedElements = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        isolatedElementHighlightConfigs :
          Types.Overlay.IsolatedElementHighlightConfig.t list;
            [@key "isolatedElementHighlightConfigs"]
            [@ocaml.doc
              "An array of node identifiers and descriptors for the highlight \
               appearance."]
      }
      [@@deriving yojson]

      let make ~isolatedElementHighlightConfigs () =
        { isolatedElementHighlightConfigs }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowIsolatedElements"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Page = struct
  (* Deprecated, please use addScriptToEvaluateOnNewDocument instead. *)
  module AddScriptToEvaluateOnLoad = struct
    module Response : sig
      type result = {
        identifier : Types.Page.ScriptIdentifier.t;
            [@key "identifier"] [@ocaml.doc "Identifier of the added script."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        identifier : Types.Page.ScriptIdentifier.t;
            [@key "identifier"] [@ocaml.doc "Identifier of the added script."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptSource : string;
            [@key "scriptSource"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scriptSource () = { scriptSource }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.addScriptToEvaluateOnLoad"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Evaluates given script in every frame upon creation (before loading frame's scripts). *)
  module AddScriptToEvaluateOnNewDocument = struct
    module Response : sig
      type result = {
        identifier : Types.Page.ScriptIdentifier.t;
            [@key "identifier"] [@ocaml.doc "Identifier of the added script."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        identifier : Types.Page.ScriptIdentifier.t;
            [@key "identifier"] [@ocaml.doc "Identifier of the added script."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        source : string; [@key "source"] [@ocaml.doc "No description provided"]
        worldName : string option;
            [@key "worldName"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, creates an isolated world with the given name and \
               evaluates given script in it.\n\
               This world name will be used as the \
               ExecutionContextDescription::name when the corresponding\n\
               event is emitted."]
        includeCommandLineAPI : bool option;
            [@key "includeCommandLineAPI"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies whether command line API should be available to the \
               script, defaults\n\
               to false."]
      }
      [@@deriving yojson]

      let make ~source ?worldName ?includeCommandLineAPI () =
        { source; worldName; includeCommandLineAPI }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Page.addScriptToEvaluateOnNewDocument";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Brings page to front (activates tab). *)
  module BringToFront = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.bringToFront"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Capture page screenshot. *)
  module CaptureScreenshot = struct
    module Response : sig
      type result = {
        data : string;
            [@key "data"]
            [@ocaml.doc
              "Base64-encoded image data. (Encoded as a base64 string when \
               passed over JSON)"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        data : string;
            [@key "data"]
            [@ocaml.doc
              "Base64-encoded image data. (Encoded as a base64 string when \
               passed over JSON)"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type capturescreenshot_format = [ `jpeg | `png | `webp ]

      let capturescreenshot_format_of_yojson = function
        | `String "jpeg" -> `jpeg
        | `String "png" -> `png
        | `String "webp" -> `webp
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_capturescreenshot_format = function
        | `jpeg -> `String "jpeg"
        | `png -> `String "png"
        | `webp -> `String "webp"

      type t = {
        format : capturescreenshot_format option;
            [@key "format"]
            [@yojson.option]
            [@ocaml.doc "Image compression format (defaults to png)."]
        quality : Types.number option;
            [@key "quality"]
            [@yojson.option]
            [@ocaml.doc "Compression quality from range [0..100] (jpeg only)."]
        clip : Types.Page.Viewport.t option;
            [@key "clip"]
            [@yojson.option]
            [@ocaml.doc "Capture the screenshot of a given region only."]
        fromSurface : bool option;
            [@key "fromSurface"]
            [@yojson.option]
            [@ocaml.doc
              "Capture the screenshot from the surface, rather than the view. \
               Defaults to true."]
        captureBeyondViewport : bool option;
            [@key "captureBeyondViewport"]
            [@yojson.option]
            [@ocaml.doc
              "Capture the screenshot beyond the viewport. Defaults to false."]
        optimizeForSpeed : bool option;
            [@key "optimizeForSpeed"]
            [@yojson.option]
            [@ocaml.doc
              "Optimize image encoding for speed, not for resulting size \
               (defaults to false)"]
      }
      [@@deriving yojson]

      let make ?format ?quality ?clip ?fromSurface ?captureBeyondViewport
          ?optimizeForSpeed () =
        {
          format;
          quality;
          clip;
          fromSurface;
          captureBeyondViewport;
          optimizeForSpeed;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.captureScreenshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns a snapshot of the page as a string. For MHTML format, the serialization includes
     iframes, shadow DOM, external resources, and element-inline styles. *)
  module CaptureSnapshot = struct
    module Response : sig
      type result = {
        data : string; [@key "data"] [@ocaml.doc "Serialized page data."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        data : string; [@key "data"] [@ocaml.doc "Serialized page data."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type capturesnapshot_format = [ `mhtml ]

      let capturesnapshot_format_of_yojson = function
        | `String "mhtml" -> `mhtml
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_capturesnapshot_format = function
        | `mhtml -> `String "mhtml"

      type t = {
        format : capturesnapshot_format option;
            [@key "format"]
            [@yojson.option]
            [@ocaml.doc "Format (defaults to mhtml)."]
      }
      [@@deriving yojson]

      let make ?format () = { format }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.captureSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears the overridden device metrics. *)
  module ClearDeviceMetricsOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.clearDeviceMetricsOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears the overridden Device Orientation. *)
  module ClearDeviceOrientationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.clearDeviceOrientationOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears the overridden Geolocation Position and Error. *)
  module ClearGeolocationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.clearGeolocationOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Creates an isolated world for the given frame. *)
  module CreateIsolatedWorld = struct
    module Response : sig
      type result = {
        executionContextId : Types.Runtime.ExecutionContextId.t;
            [@key "executionContextId"]
            [@ocaml.doc "Execution context of the isolated world."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        executionContextId : Types.Runtime.ExecutionContextId.t;
            [@key "executionContextId"]
            [@ocaml.doc "Execution context of the isolated world."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"]
            [@ocaml.doc
              "Id of the frame in which the isolated world should be created."]
        worldName : string option;
            [@key "worldName"]
            [@yojson.option]
            [@ocaml.doc
              "An optional name which is reported in the Execution Context."]
        grantUniveralAccess : bool option;
            [@key "grantUniveralAccess"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not universal access should be granted to the \
               isolated world. This is a powerful\n\
               option, use with caution."]
      }
      [@@deriving yojson]

      let make ~frameId ?worldName ?grantUniveralAccess () =
        { frameId; worldName; grantUniveralAccess }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.createIsolatedWorld"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Deletes browser cookie with given name, domain and path. *)
  module DeleteCookie = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cookieName : string;
            [@key "cookieName"] [@ocaml.doc "Name of the cookie to remove."]
        url : string;
            [@key "url"] [@ocaml.doc "URL to match cooke domain and path."]
      }
      [@@deriving yojson]

      let make ~cookieName ~url () = { cookieName; url }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.deleteCookie"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables page domain notifications. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables page domain notifications. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module GetAppManifest = struct
    module Response : sig
      type result = {
        url : string; [@key "url"] [@ocaml.doc "Manifest location."]
        errors : Types.Page.AppManifestError.t list;
            [@key "errors"] [@ocaml.doc "No description provided"]
        data : string option;
            [@key "data"] [@yojson.option] [@ocaml.doc "Manifest content."]
        parsed : Types.Page.AppManifestParsedProperties.t option;
            [@key "parsed"]
            [@yojson.option]
            [@ocaml.doc "Parsed manifest properties"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        url : string; [@key "url"] [@ocaml.doc "Manifest location."]
        errors : Types.Page.AppManifestError.t list;
            [@key "errors"] [@ocaml.doc "No description provided"]
        data : string option;
            [@key "data"] [@yojson.option] [@ocaml.doc "Manifest content."]
        parsed : Types.Page.AppManifestParsedProperties.t option;
            [@key "parsed"]
            [@yojson.option]
            [@ocaml.doc "Parsed manifest properties"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getAppManifest"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module GetInstallabilityErrors = struct
    module Response : sig
      type result = {
        installabilityErrors : Types.Page.InstallabilityError.t list;
            [@key "installabilityErrors"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        installabilityErrors : Types.Page.InstallabilityError.t list;
            [@key "installabilityErrors"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getInstallabilityErrors"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation. *)
  module GetManifestIcons = struct
    module Response : sig
      type result = {
        primaryIcon : string option;
            [@key "primaryIcon"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        primaryIcon : string option;
            [@key "primaryIcon"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getManifestIcons"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the unique (PWA) app id.
     Only returns values if the feature flag 'WebAppEnableManifestId' is enabled *)
  module GetAppId = struct
    module Response : sig
      type result = {
        appId : string option;
            [@key "appId"]
            [@yojson.option]
            [@ocaml.doc
              "App id, either from manifest's id attribute or computed from \
               start_url"]
        recommendedId : string option;
            [@key "recommendedId"]
            [@yojson.option]
            [@ocaml.doc
              "Recommendation for manifest's id attribute to match current id \
               computed from start_url"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        appId : string option;
            [@key "appId"]
            [@yojson.option]
            [@ocaml.doc
              "App id, either from manifest's id attribute or computed from \
               start_url"]
        recommendedId : string option;
            [@key "recommendedId"]
            [@yojson.option]
            [@ocaml.doc
              "Recommendation for manifest's id attribute to match current id \
               computed from start_url"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getAppId"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module GetAdScriptId = struct
    module Response : sig
      type result = {
        adScriptId : Types.Page.AdScriptId.t option;
            [@key "adScriptId"]
            [@yojson.option]
            [@ocaml.doc
              "Identifies the bottom-most script which caused the frame to be \
               labelled\n\
               as an ad. Only sent if frame is labelled as an ad and id is \
               available."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        adScriptId : Types.Page.AdScriptId.t option;
            [@key "adScriptId"]
            [@yojson.option]
            [@ocaml.doc
              "Identifies the bottom-most script which caused the frame to be \
               labelled\n\
               as an ad. Only sent if frame is labelled as an ad and id is \
               available."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.getAdScriptId"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns all browser cookies for the page and all of its subframes. Depending
     on the backend support, will return detailed cookie information in the
     `cookies` field. *)
  module GetCookies = struct
    module Response : sig
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getCookies"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns present frame tree structure. *)
  module GetFrameTree = struct
    module Response : sig
      type result = {
        frameTree : Types.Page.FrameTree.t;
            [@key "frameTree"] [@ocaml.doc "Present frame tree structure."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        frameTree : Types.Page.FrameTree.t;
            [@key "frameTree"] [@ocaml.doc "Present frame tree structure."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getFrameTree"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns metrics relating to the layouting of the page, such as viewport bounds/scale. *)
  module GetLayoutMetrics = struct
    module Response : sig
      type result = {
        layoutViewport : Types.Page.LayoutViewport.t;
            [@key "layoutViewport"]
            [@ocaml.doc
              "Deprecated metrics relating to the layout viewport. Is in \
               device pixels. Use `cssLayoutViewport` instead."]
        visualViewport : Types.Page.VisualViewport.t;
            [@key "visualViewport"]
            [@ocaml.doc
              "Deprecated metrics relating to the visual viewport. Is in \
               device pixels. Use `cssVisualViewport` instead."]
        contentSize : Types.DOM.Rect.t;
            [@key "contentSize"]
            [@ocaml.doc
              "Deprecated size of scrollable area. Is in DP. Use \
               `cssContentSize` instead."]
        cssLayoutViewport : Types.Page.LayoutViewport.t;
            [@key "cssLayoutViewport"]
            [@ocaml.doc
              "Metrics relating to the layout viewport in CSS pixels."]
        cssVisualViewport : Types.Page.VisualViewport.t;
            [@key "cssVisualViewport"]
            [@ocaml.doc
              "Metrics relating to the visual viewport in CSS pixels."]
        cssContentSize : Types.DOM.Rect.t;
            [@key "cssContentSize"]
            [@ocaml.doc "Size of scrollable area in CSS pixels."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        layoutViewport : Types.Page.LayoutViewport.t;
            [@key "layoutViewport"]
            [@ocaml.doc
              "Deprecated metrics relating to the layout viewport. Is in \
               device pixels. Use `cssLayoutViewport` instead."]
        visualViewport : Types.Page.VisualViewport.t;
            [@key "visualViewport"]
            [@ocaml.doc
              "Deprecated metrics relating to the visual viewport. Is in \
               device pixels. Use `cssVisualViewport` instead."]
        contentSize : Types.DOM.Rect.t;
            [@key "contentSize"]
            [@ocaml.doc
              "Deprecated size of scrollable area. Is in DP. Use \
               `cssContentSize` instead."]
        cssLayoutViewport : Types.Page.LayoutViewport.t;
            [@key "cssLayoutViewport"]
            [@ocaml.doc
              "Metrics relating to the layout viewport in CSS pixels."]
        cssVisualViewport : Types.Page.VisualViewport.t;
            [@key "cssVisualViewport"]
            [@ocaml.doc
              "Metrics relating to the visual viewport in CSS pixels."]
        cssContentSize : Types.DOM.Rect.t;
            [@key "cssContentSize"]
            [@ocaml.doc "Size of scrollable area in CSS pixels."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getLayoutMetrics"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns navigation history for the current page. *)
  module GetNavigationHistory = struct
    module Response : sig
      type result = {
        currentIndex : Types.number;
            [@key "currentIndex"]
            [@ocaml.doc "Index of the current navigation history entry."]
        entries : Types.Page.NavigationEntry.t list;
            [@key "entries"] [@ocaml.doc "Array of navigation history entries."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        currentIndex : Types.number;
            [@key "currentIndex"]
            [@ocaml.doc "Index of the current navigation history entry."]
        entries : Types.Page.NavigationEntry.t list;
            [@key "entries"] [@ocaml.doc "Array of navigation history entries."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getNavigationHistory"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Resets navigation history for the current page. *)
  module ResetNavigationHistory = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.resetNavigationHistory"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns content of the given resource. *)
  module GetResourceContent = struct
    module Response : sig
      type result = {
        content : string; [@key "content"] [@ocaml.doc "Resource content."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was served as base64."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        content : string; [@key "content"] [@ocaml.doc "Resource content."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was served as base64."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "Frame id to get resource for."]
        url : string;
            [@key "url"] [@ocaml.doc "URL of the resource to get content for."]
      }
      [@@deriving yojson]

      let make ~frameId ~url () = { frameId; url }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.getResourceContent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns present frame / resource tree structure. *)
  module GetResourceTree = struct
    module Response : sig
      type result = {
        frameTree : Types.Page.FrameResourceTree.t;
            [@key "frameTree"]
            [@ocaml.doc "Present frame / resource tree structure."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        frameTree : Types.Page.FrameResourceTree.t;
            [@key "frameTree"]
            [@ocaml.doc "Present frame / resource tree structure."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getResourceTree"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). *)
  module HandleJavaScriptDialog = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        accept : bool;
            [@key "accept"]
            [@ocaml.doc "Whether to accept or dismiss the dialog."]
        promptText : string option;
            [@key "promptText"]
            [@yojson.option]
            [@ocaml.doc
              "The text to enter into the dialog prompt before accepting. Used \
               only if this is a prompt\n\
               dialog."]
      }
      [@@deriving yojson]

      let make ~accept ?promptText () = { accept; promptText }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.handleJavaScriptDialog"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Navigates current page to the given URL. *)
  module Navigate = struct
    module Response : sig
      type result = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"]
            [@ocaml.doc "Frame id that has navigated (or failed to navigate)"]
        loaderId : Types.Network.LoaderId.t option;
            [@key "loaderId"]
            [@yojson.option]
            [@ocaml.doc
              "Loader identifier. This is omitted in case of same-document \
               navigation,\n\
               as the previously committed loaderId would not change."]
        errorText : string option;
            [@key "errorText"]
            [@yojson.option]
            [@ocaml.doc
              "User friendly error message, present if and only if navigation \
               has failed."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"]
            [@ocaml.doc "Frame id that has navigated (or failed to navigate)"]
        loaderId : Types.Network.LoaderId.t option;
            [@key "loaderId"]
            [@yojson.option]
            [@ocaml.doc
              "Loader identifier. This is omitted in case of same-document \
               navigation,\n\
               as the previously committed loaderId would not change."]
        errorText : string option;
            [@key "errorText"]
            [@yojson.option]
            [@ocaml.doc
              "User friendly error message, present if and only if navigation \
               has failed."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        url : string; [@key "url"] [@ocaml.doc "URL to navigate the page to."]
        referrer : string option;
            [@key "referrer"] [@yojson.option] [@ocaml.doc "Referrer URL."]
        transitionType : Types.Page.TransitionType.t option;
            [@key "transitionType"]
            [@yojson.option]
            [@ocaml.doc "Intended transition type."]
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc
              "Frame id to navigate, if not specified navigates the top frame."]
        referrerPolicy : Types.Page.ReferrerPolicy.t option;
            [@key "referrerPolicy"]
            [@yojson.option]
            [@ocaml.doc "Referrer-policy used for the navigation."]
      }
      [@@deriving yojson]

      let make ~url ?referrer ?transitionType ?frameId ?referrerPolicy () =
        { url; referrer; transitionType; frameId; referrerPolicy }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.navigate"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Navigates current page to the given history entry. *)
  module NavigateToHistoryEntry = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        entryId : Types.number;
            [@key "entryId"]
            [@ocaml.doc "Unique id of the entry to navigate to."]
      }
      [@@deriving yojson]

      let make ~entryId () = { entryId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.navigateToHistoryEntry"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Print page as PDF. *)
  module PrintToPDF = struct
    module Response : sig
      type result = {
        data : string;
            [@key "data"]
            [@ocaml.doc
              "Base64-encoded pdf data. Empty if |returnAsStream| is \
               specified. (Encoded as a base64 string when passed over JSON)"]
        stream : Types.IO.StreamHandle.t option;
            [@key "stream"]
            [@yojson.option]
            [@ocaml.doc "A handle of the stream that holds resulting PDF data."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        data : string;
            [@key "data"]
            [@ocaml.doc
              "Base64-encoded pdf data. Empty if |returnAsStream| is \
               specified. (Encoded as a base64 string when passed over JSON)"]
        stream : Types.IO.StreamHandle.t option;
            [@key "stream"]
            [@yojson.option]
            [@ocaml.doc "A handle of the stream that holds resulting PDF data."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type printtopdf_transfermode = [ `ReturnAsBase64 | `ReturnAsStream ]

      let printtopdf_transfermode_of_yojson = function
        | `String "ReturnAsBase64" -> `ReturnAsBase64
        | `String "ReturnAsStream" -> `ReturnAsStream
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_printtopdf_transfermode = function
        | `ReturnAsBase64 -> `String "ReturnAsBase64"
        | `ReturnAsStream -> `String "ReturnAsStream"

      type t = {
        landscape : bool option;
            [@key "landscape"]
            [@yojson.option]
            [@ocaml.doc "Paper orientation. Defaults to false."]
        displayHeaderFooter : bool option;
            [@key "displayHeaderFooter"]
            [@yojson.option]
            [@ocaml.doc "Display header and footer. Defaults to false."]
        printBackground : bool option;
            [@key "printBackground"]
            [@yojson.option]
            [@ocaml.doc "Print background graphics. Defaults to false."]
        scale : Types.number option;
            [@key "scale"]
            [@yojson.option]
            [@ocaml.doc "Scale of the webpage rendering. Defaults to 1."]
        paperWidth : Types.number option;
            [@key "paperWidth"]
            [@yojson.option]
            [@ocaml.doc "Paper width in inches. Defaults to 8.5 inches."]
        paperHeight : Types.number option;
            [@key "paperHeight"]
            [@yojson.option]
            [@ocaml.doc "Paper height in inches. Defaults to 11 inches."]
        marginTop : Types.number option;
            [@key "marginTop"]
            [@yojson.option]
            [@ocaml.doc "Top margin in inches. Defaults to 1cm (~0.4 inches)."]
        marginBottom : Types.number option;
            [@key "marginBottom"]
            [@yojson.option]
            [@ocaml.doc
              "Bottom margin in inches. Defaults to 1cm (~0.4 inches)."]
        marginLeft : Types.number option;
            [@key "marginLeft"]
            [@yojson.option]
            [@ocaml.doc "Left margin in inches. Defaults to 1cm (~0.4 inches)."]
        marginRight : Types.number option;
            [@key "marginRight"]
            [@yojson.option]
            [@ocaml.doc
              "Right margin in inches. Defaults to 1cm (~0.4 inches)."]
        pageRanges : string option;
            [@key "pageRanges"]
            [@yojson.option]
            [@ocaml.doc
              "Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages \
               are\n\
               printed in the document order, not in the order specified, and no\n\
               more than once.\n\
               Defaults to empty string, which implies the entire document is \
               printed.\n\
               The page numbers are quietly capped to actual page count of the\n\
               document, and ranges beyond the end of the document are ignored.\n\
               If this results in no pages to print, an error is reported.\n\
               It is an error to specify a range with start greater than end."]
        headerTemplate : string option;
            [@key "headerTemplate"]
            [@yojson.option]
            [@ocaml.doc
              "HTML template for the print header. Should be valid HTML markup \
               with following\n\
               classes used to inject printing values into them:\n\
               - `date`: formatted print date\n\
               - `title`: document title\n\
               - `url`: document location\n\
               - `pageNumber`: current page number\n\
               - `totalPages`: total pages in the document\n\n\
               For example, `<span class=title></span>` would generate span \
               containing the title."]
        footerTemplate : string option;
            [@key "footerTemplate"]
            [@yojson.option]
            [@ocaml.doc
              "HTML template for the print footer. Should use the same format \
               as the `headerTemplate`."]
        preferCSSPageSize : bool option;
            [@key "preferCSSPageSize"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not to prefer page size as defined by css. Defaults \
               to false,\n\
               in which case the content will be scaled to fit the paper size."]
        transferMode : printtopdf_transfermode option;
            [@key "transferMode"]
            [@yojson.option]
            [@ocaml.doc "return as stream"]
      }
      [@@deriving yojson]

      let make ?landscape ?displayHeaderFooter ?printBackground ?scale
          ?paperWidth ?paperHeight ?marginTop ?marginBottom ?marginLeft
          ?marginRight ?pageRanges ?headerTemplate ?footerTemplate
          ?preferCSSPageSize ?transferMode () =
        {
          landscape;
          displayHeaderFooter;
          printBackground;
          scale;
          paperWidth;
          paperHeight;
          marginTop;
          marginBottom;
          marginLeft;
          marginRight;
          pageRanges;
          headerTemplate;
          footerTemplate;
          preferCSSPageSize;
          transferMode;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.printToPDF"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Reloads given page optionally ignoring the cache. *)
  module Reload = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ignoreCache : bool option;
            [@key "ignoreCache"]
            [@yojson.option]
            [@ocaml.doc
              "If true, browser cache is ignored (as if the user pressed \
               Shift+refresh)."]
        scriptToEvaluateOnLoad : string option;
            [@key "scriptToEvaluateOnLoad"]
            [@yojson.option]
            [@ocaml.doc
              "If set, the script will be injected into all frames of the \
               inspected page after reload.\n\
               Argument will be ignored if reloading dataURL origin."]
      }
      [@@deriving yojson]

      let make ?ignoreCache ?scriptToEvaluateOnLoad () =
        { ignoreCache; scriptToEvaluateOnLoad }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.reload"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Deprecated, please use removeScriptToEvaluateOnNewDocument instead. *)
  module RemoveScriptToEvaluateOnLoad = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        identifier : Types.Page.ScriptIdentifier.t;
            [@key "identifier"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~identifier () = { identifier }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.removeScriptToEvaluateOnLoad"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Removes given script from the list. *)
  module RemoveScriptToEvaluateOnNewDocument = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        identifier : Types.Page.ScriptIdentifier.t;
            [@key "identifier"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~identifier () = { identifier }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Page.removeScriptToEvaluateOnNewDocument";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Acknowledges that a screencast frame has been received by the frontend. *)
  module ScreencastFrameAck = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sessionId : Types.number; [@key "sessionId"] [@ocaml.doc "Frame number."]
      }
      [@@deriving yojson]

      let make ~sessionId () = { sessionId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.screencastFrameAck"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Searches for given string in resource content. *)
  module SearchInResource = struct
    module Response : sig
      type result = {
        result : Types.Debugger.SearchMatch.t list;
            [@key "result"] [@ocaml.doc "List of search matches."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Debugger.SearchMatch.t list;
            [@key "result"] [@ocaml.doc "List of search matches."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "Frame id for resource to search in."]
        url : string;
            [@key "url"] [@ocaml.doc "URL of the resource to search in."]
        query : string; [@key "query"] [@ocaml.doc "String to search for."]
        caseSensitive : bool option;
            [@key "caseSensitive"]
            [@yojson.option]
            [@ocaml.doc "If true, search is case sensitive."]
        isRegex : bool option;
            [@key "isRegex"]
            [@yojson.option]
            [@ocaml.doc "If true, treats string parameter as regex."]
      }
      [@@deriving yojson]

      let make ~frameId ~url ~query ?caseSensitive ?isRegex () =
        { frameId; url; query; caseSensitive; isRegex }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.searchInResource"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enable Chrome's experimental ad filter on all sites. *)
  module SetAdBlockingEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool; [@key "enabled"] [@ocaml.doc "Whether to block ads."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setAdBlockingEnabled"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enable page Content Security Policy by-passing. *)
  module SetBypassCSP = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"] [@ocaml.doc "Whether to bypass page CSP."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setBypassCSP"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Get Permissions Policy state on given frame. *)
  module GetPermissionsPolicyState = struct
    module Response : sig
      type result = {
        states : Types.Page.PermissionsPolicyFeatureState.t list;
            [@key "states"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        states : Types.Page.PermissionsPolicyFeatureState.t list;
            [@key "states"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.getPermissionsPolicyState"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Get Origin Trials on given frame. *)
  module GetOriginTrials = struct
    module Response : sig
      type result = {
        originTrials : Types.Page.OriginTrial.t list;
            [@key "originTrials"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        originTrials : Types.Page.OriginTrial.t list;
            [@key "originTrials"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.getOriginTrials"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
     window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
     query results). *)
  module SetDeviceMetricsOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        width : Types.number;
            [@key "width"]
            [@ocaml.doc
              "Overriding width value in pixels (minimum 0, maximum 10000000). \
               0 disables the override."]
        height : Types.number;
            [@key "height"]
            [@ocaml.doc
              "Overriding height value in pixels (minimum 0, maximum \
               10000000). 0 disables the override."]
        deviceScaleFactor : Types.number;
            [@key "deviceScaleFactor"]
            [@ocaml.doc
              "Overriding device scale factor value. 0 disables the override."]
        mobile : bool;
            [@key "mobile"]
            [@ocaml.doc
              "Whether to emulate mobile device. This includes viewport meta \
               tag, overlay scrollbars, text\n\
               autosizing and more."]
        scale : Types.number option;
            [@key "scale"]
            [@yojson.option]
            [@ocaml.doc "Scale to apply to resulting view image."]
        screenWidth : Types.number option;
            [@key "screenWidth"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding screen width value in pixels (minimum 0, maximum \
               10000000)."]
        screenHeight : Types.number option;
            [@key "screenHeight"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding screen height value in pixels (minimum 0, maximum \
               10000000)."]
        positionX : Types.number option;
            [@key "positionX"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding view X position on screen in pixels (minimum 0, \
               maximum 10000000)."]
        positionY : Types.number option;
            [@key "positionY"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding view Y position on screen in pixels (minimum 0, \
               maximum 10000000)."]
        dontSetVisibleSize : bool option;
            [@key "dontSetVisibleSize"]
            [@yojson.option]
            [@ocaml.doc
              "Do not set visible view size, rely upon explicit setVisibleSize \
               call."]
        screenOrientation : Types.Emulation.ScreenOrientation.t option;
            [@key "screenOrientation"]
            [@yojson.option]
            [@ocaml.doc "Screen orientation override."]
        viewport : Types.Page.Viewport.t option;
            [@key "viewport"]
            [@yojson.option]
            [@ocaml.doc
              "The viewport dimensions and scale. If not set, the override is \
               cleared."]
      }
      [@@deriving yojson]

      let make ~width ~height ~deviceScaleFactor ~mobile ?scale ?screenWidth
          ?screenHeight ?positionX ?positionY ?dontSetVisibleSize
          ?screenOrientation ?viewport () =
        {
          width;
          height;
          deviceScaleFactor;
          mobile;
          scale;
          screenWidth;
          screenHeight;
          positionX;
          positionY;
          dontSetVisibleSize;
          screenOrientation;
          viewport;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setDeviceMetricsOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Overrides the Device Orientation. *)
  module SetDeviceOrientationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        alpha : Types.number; [@key "alpha"] [@ocaml.doc "Mock alpha"]
        beta : Types.number; [@key "beta"] [@ocaml.doc "Mock beta"]
        gamma : Types.number; [@key "gamma"] [@ocaml.doc "Mock gamma"]
      }
      [@@deriving yojson]

      let make ~alpha ~beta ~gamma () = { alpha; beta; gamma }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setDeviceOrientationOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Set generic font families. *)
  module SetFontFamilies = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        fontFamilies : Types.Page.FontFamilies.t;
            [@key "fontFamilies"]
            [@ocaml.doc
              "Specifies font families to set. If a font family is not \
               specified, it won't be changed."]
        forScripts : Types.Page.ScriptFontFamilies.t list option;
            [@key "forScripts"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies font families to set for individual scripts."]
      }
      [@@deriving yojson]

      let make ~fontFamilies ?forScripts () = { fontFamilies; forScripts }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setFontFamilies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Set default font sizes. *)
  module SetFontSizes = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        fontSizes : Types.Page.FontSizes.t;
            [@key "fontSizes"]
            [@ocaml.doc
              "Specifies font sizes to set. If a font size is not specified, \
               it won't be changed."]
      }
      [@@deriving yojson]

      let make ~fontSizes () = { fontSizes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setFontSizes"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets given markup as the document's HTML. *)
  module SetDocumentContent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "Frame id to set HTML for."]
        html : string; [@key "html"] [@ocaml.doc "HTML content to set."]
      }
      [@@deriving yojson]

      let make ~frameId ~html () = { frameId; html }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setDocumentContent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Set the behavior when downloading a file. *)
  module SetDownloadBehavior = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setdownloadbehavior_behavior = [ `deny | `allow | `default ]

      let setdownloadbehavior_behavior_of_yojson = function
        | `String "deny" -> `deny
        | `String "allow" -> `allow
        | `String "default" -> `default
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setdownloadbehavior_behavior = function
        | `deny -> `String "deny"
        | `allow -> `String "allow"
        | `default -> `String "default"

      type t = {
        behavior : setdownloadbehavior_behavior;
            [@key "behavior"]
            [@ocaml.doc
              "Whether to allow all or deny all download requests, or use \
               default Chrome behavior if\n\
               available (otherwise deny)."]
        downloadPath : string option;
            [@key "downloadPath"]
            [@yojson.option]
            [@ocaml.doc
              "The default path to save downloaded files to. This is required \
               if behavior is set to 'allow'"]
      }
      [@@deriving yojson]

      let make ~behavior ?downloadPath () = { behavior; downloadPath }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setDownloadBehavior"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
     unavailable. *)
  module SetGeolocationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        latitude : Types.number option;
            [@key "latitude"] [@yojson.option] [@ocaml.doc "Mock latitude"]
        longitude : Types.number option;
            [@key "longitude"] [@yojson.option] [@ocaml.doc "Mock longitude"]
        accuracy : Types.number option;
            [@key "accuracy"] [@yojson.option] [@ocaml.doc "Mock accuracy"]
      }
      [@@deriving yojson]

      let make ?latitude ?longitude ?accuracy () =
        { latitude; longitude; accuracy }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setGeolocationOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Controls whether page will emit lifecycle events. *)
  module SetLifecycleEventsEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc "If true, starts emitting lifecycle events."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setLifecycleEventsEnabled"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Toggles mouse event-based touch event emulation. *)
  module SetTouchEmulationEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type settouchemulationenabled_configuration = [ `mobile | `desktop ]

      let settouchemulationenabled_configuration_of_yojson = function
        | `String "mobile" -> `mobile
        | `String "desktop" -> `desktop
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_settouchemulationenabled_configuration = function
        | `mobile -> `String "mobile"
        | `desktop -> `String "desktop"

      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc "Whether the touch event emulation should be enabled."]
        configuration : settouchemulationenabled_configuration option;
            [@key "configuration"]
            [@yojson.option]
            [@ocaml.doc
              "Touch/gesture events configuration. Default: current platform."]
      }
      [@@deriving yojson]

      let make ~enabled ?configuration () = { enabled; configuration }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setTouchEmulationEnabled"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Starts sending each frame using the `screencastFrame` event. *)
  module StartScreencast = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type startscreencast_format = [ `jpeg | `png ]

      let startscreencast_format_of_yojson = function
        | `String "jpeg" -> `jpeg
        | `String "png" -> `png
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_startscreencast_format = function
        | `jpeg -> `String "jpeg"
        | `png -> `String "png"

      type t = {
        format : startscreencast_format option;
            [@key "format"]
            [@yojson.option]
            [@ocaml.doc "Image compression format."]
        quality : Types.number option;
            [@key "quality"]
            [@yojson.option]
            [@ocaml.doc "Compression quality from range [0..100]."]
        maxWidth : Types.number option;
            [@key "maxWidth"]
            [@yojson.option]
            [@ocaml.doc "Maximum screenshot width."]
        maxHeight : Types.number option;
            [@key "maxHeight"]
            [@yojson.option]
            [@ocaml.doc "Maximum screenshot height."]
        everyNthFrame : Types.number option;
            [@key "everyNthFrame"]
            [@yojson.option]
            [@ocaml.doc "Send every n-th frame."]
      }
      [@@deriving yojson]

      let make ?format ?quality ?maxWidth ?maxHeight ?everyNthFrame () =
        { format; quality; maxWidth; maxHeight; everyNthFrame }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.startScreencast"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Force the page stop all navigations and pending resource fetches. *)
  module StopLoading = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.stopLoading"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Crashes renderer on the IO thread, generates minidumps. *)
  module Crash = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.crash"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Tries to close page, running its beforeunload hooks, if any. *)
  module Close = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.close"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Tries to update the web lifecycle state of the page.
     It will transition the page to the given state according to:
     https://github.com/WICG/web-lifecycle/ *)
  module SetWebLifecycleState = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setweblifecyclestate_state = [ `frozen | `active ]

      let setweblifecyclestate_state_of_yojson = function
        | `String "frozen" -> `frozen
        | `String "active" -> `active
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setweblifecyclestate_state = function
        | `frozen -> `String "frozen"
        | `active -> `String "active"

      type t = {
        state : setweblifecyclestate_state;
            [@key "state"] [@ocaml.doc "Target lifecycle state"]
      }
      [@@deriving yojson]

      let make ~state () = { state }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setWebLifecycleState"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Stops sending each frame in the `screencastFrame`. *)
  module StopScreencast = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.stopScreencast"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Requests backend to produce compilation cache for the specified scripts.
     `scripts` are appeneded to the list of scripts for which the cache
     would be produced. The list may be reset during page navigation.
     When script with a matching URL is encountered, the cache is optionally
     produced upon backend discretion, based on internal heuristics.
     See also: `Page.compilationCacheProduced`. *)
  module ProduceCompilationCache = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scripts : Types.Page.CompilationCacheParams.t list;
            [@key "scripts"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scripts () = { scripts }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.produceCompilationCache"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Seeds compilation cache for given url. Compilation cache does not survive
     cross-process navigation. *)
  module AddCompilationCache = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        url : string; [@key "url"] [@ocaml.doc "No description provided"]
        data : string;
            [@key "data"]
            [@ocaml.doc
              "Base64-encoded data (Encoded as a base64 string when passed \
               over JSON)"]
      }
      [@@deriving yojson]

      let make ~url ~data () = { url; data }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.addCompilationCache"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears seeded compilation cache. *)
  module ClearCompilationCache = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.clearCompilationCache"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets the Secure Payment Confirmation transaction mode.
     https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode *)
  module SetSPCTransactionMode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        mode : Types.Page.AutoResponseMode.t;
            [@key "mode"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~mode () = { mode }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setSPCTransactionMode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Extensions for Custom Handlers API:
     https://html.spec.whatwg.org/multipage/system-state.html#rph-automation *)
  module SetRPHRegistrationMode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        mode : Types.Page.AutoResponseMode.t;
            [@key "mode"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~mode () = { mode }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setRPHRegistrationMode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Generates a report for testing. *)
  module GenerateTestReport = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        message : string;
            [@key "message"]
            [@ocaml.doc "Message to be displayed in the report."]
        group : string option;
            [@key "group"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies the endpoint group to deliver the report to."]
      }
      [@@deriving yojson]

      let make ~message ?group () = { message; group }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.generateTestReport"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger. *)
  module WaitForDebugger = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.waitForDebugger"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Intercept file chooser requests and transfer control to protocol clients.
     When file chooser interception is enabled, native file chooser dialog is not shown.
     Instead, a protocol event `Page.fileChooserOpened` is emitted. *)
  module SetInterceptFileChooserDialog = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool; [@key "enabled"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Page.setInterceptFileChooserDialog";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Performance = struct
  (* Disable collecting and reporting metrics. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Performance.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enable collecting and reporting metrics. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type enable_timedomain = [ `timeTicks | `threadTicks ]

      let enable_timedomain_of_yojson = function
        | `String "timeTicks" -> `timeTicks
        | `String "threadTicks" -> `threadTicks
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_enable_timedomain = function
        | `timeTicks -> `String "timeTicks"
        | `threadTicks -> `String "threadTicks"

      type t = {
        timeDomain : enable_timedomain option;
            [@key "timeDomain"]
            [@yojson.option]
            [@ocaml.doc
              "Time domain to use for collecting and reporting duration \
               metrics."]
      }
      [@@deriving yojson]

      let make ?timeDomain () = { timeDomain }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Performance.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets time domain to use for collecting and reporting duration metrics.
     Note that this must be called before enabling metrics collection. Calling
     this method while metrics collection is enabled returns an error. *)
  module SetTimeDomain = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type settimedomain_timedomain = [ `timeTicks | `threadTicks ]

      let settimedomain_timedomain_of_yojson = function
        | `String "timeTicks" -> `timeTicks
        | `String "threadTicks" -> `threadTicks
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_settimedomain_timedomain = function
        | `timeTicks -> `String "timeTicks"
        | `threadTicks -> `String "threadTicks"

      type t = {
        timeDomain : settimedomain_timedomain;
            [@key "timeDomain"] [@ocaml.doc "Time domain"]
      }
      [@@deriving yojson]

      let make ~timeDomain () = { timeDomain }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Performance.setTimeDomain"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Retrieve current values of run-time metrics. *)
  module GetMetrics = struct
    module Response : sig
      type result = {
        metrics : Types.Performance.Metric.t list;
            [@key "metrics"] [@ocaml.doc "Current values for run-time metrics."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        metrics : Types.Performance.Metric.t list;
            [@key "metrics"] [@ocaml.doc "Current values for run-time metrics."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Performance.getMetrics"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module PerformanceTimeline = struct
  (* Previously buffered events would be reported before method returns.
     See also: timelineEventAdded *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventTypes : string list;
            [@key "eventTypes"]
            [@ocaml.doc
              "The types of event to report, as specified in\n\
               https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype\n\
               The specified filter overrides any previous filters, passing \
               empty\n\
               filter disables recording.\n\
               Note that not all types exposed to the web platform are \
               currently supported."]
      }
      [@@deriving yojson]

      let make ~eventTypes () = { eventTypes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "PerformanceTimeline.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Security = struct
  (* Disables tracking security state changes. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Security.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables tracking security state changes. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Security.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enable/disable whether all certificate errors should be ignored. *)
  module SetIgnoreCertificateErrors = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ignore : bool;
            [@key "ignore"]
            [@ocaml.doc "If true, all certificate errors will be ignored."]
      }
      [@@deriving yojson]

      let make ~ignore () = { ignore }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Security.setIgnoreCertificateErrors";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Handles a certificate error that fired a certificateError event. *)
  module HandleCertificateError = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventId : Types.number;
            [@key "eventId"] [@ocaml.doc "The ID of the event."]
        action : Types.Security.CertificateErrorAction.t;
            [@key "action"]
            [@ocaml.doc "The action to take on the certificate error."]
      }
      [@@deriving yojson]

      let make ~eventId ~action () = { eventId; action }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Security.handleCertificateError"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enable/disable overriding certificate errors. If enabled, all certificate error events need to
     be handled by the DevTools client and should be answered with `handleCertificateError` commands. *)
  module SetOverrideCertificateErrors = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        override : bool;
            [@key "override"]
            [@ocaml.doc "If true, certificate errors will be overridden."]
      }
      [@@deriving yojson]

      let make ~override () = { override }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Security.setOverrideCertificateErrors";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module ServiceWorker = struct
  (* No description provided *)
  module DeliverPushMessage = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "No description provided"]
        registrationId : Types.ServiceWorker.RegistrationID.t;
            [@key "registrationId"] [@ocaml.doc "No description provided"]
        data : string; [@key "data"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~origin ~registrationId ~data () =
        { origin; registrationId; data }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.deliverPushMessage"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "ServiceWorker.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module DispatchSyncEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "No description provided"]
        registrationId : Types.ServiceWorker.RegistrationID.t;
            [@key "registrationId"] [@ocaml.doc "No description provided"]
        tag : string; [@key "tag"] [@ocaml.doc "No description provided"]
        lastChance : bool;
            [@key "lastChance"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~origin ~registrationId ~tag ~lastChance () =
        { origin; registrationId; tag; lastChance }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.dispatchSyncEvent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module DispatchPeriodicSyncEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "No description provided"]
        registrationId : Types.ServiceWorker.RegistrationID.t;
            [@key "registrationId"] [@ocaml.doc "No description provided"]
        tag : string; [@key "tag"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~origin ~registrationId ~tag () = { origin; registrationId; tag }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "ServiceWorker.dispatchPeriodicSyncEvent";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "ServiceWorker.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module InspectWorker = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        versionId : string;
            [@key "versionId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~versionId () = { versionId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.inspectWorker"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetForceUpdateOnPageLoad = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        forceUpdateOnPageLoad : bool;
            [@key "forceUpdateOnPageLoad"]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~forceUpdateOnPageLoad () = { forceUpdateOnPageLoad }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "ServiceWorker.setForceUpdateOnPageLoad";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SkipWaiting = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scopeURL : string;
            [@key "scopeURL"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scopeURL () = { scopeURL }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.skipWaiting"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module StartWorker = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scopeURL : string;
            [@key "scopeURL"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scopeURL () = { scopeURL }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.startWorker"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module StopAllWorkers = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "ServiceWorker.stopAllWorkers"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module StopWorker = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        versionId : string;
            [@key "versionId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~versionId () = { versionId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.stopWorker"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module Unregister = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scopeURL : string;
            [@key "scopeURL"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scopeURL () = { scopeURL }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.unregister"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module UpdateRegistration = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scopeURL : string;
            [@key "scopeURL"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scopeURL () = { scopeURL }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.updateRegistration"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Storage = struct
  (* Returns a storage key given a frame id. *)
  module GetStorageKeyForFrame = struct
    module Response : sig
      type result = {
        storageKey : Types.Storage.SerializedStorageKey.t;
            [@key "storageKey"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        storageKey : Types.Storage.SerializedStorageKey.t;
            [@key "storageKey"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getStorageKeyForFrame"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears storage for origin. *)
  module ClearDataForOrigin = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
        storageTypes : string;
            [@key "storageTypes"]
            [@ocaml.doc "Comma separated list of StorageType to clear."]
      }
      [@@deriving yojson]

      let make ~origin ~storageTypes () = { origin; storageTypes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.clearDataForOrigin"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears storage for storage key. *)
  module ClearDataForStorageKey = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageKey : string; [@key "storageKey"] [@ocaml.doc "Storage key."]
        storageTypes : string;
            [@key "storageTypes"]
            [@ocaml.doc "Comma separated list of StorageType to clear."]
      }
      [@@deriving yojson]

      let make ~storageKey ~storageTypes () = { storageKey; storageTypes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.clearDataForStorageKey"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns all browser cookies. *)
  module GetCookies = struct
    module Response : sig
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Browser context to use when called on the browser endpoint."]
      }
      [@@deriving yojson]

      let make ?browserContextId () = { browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getCookies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets given cookies. *)
  module SetCookies = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cookies : Types.Network.CookieParam.t list;
            [@key "cookies"] [@ocaml.doc "Cookies to be set."]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Browser context to use when called on the browser endpoint."]
      }
      [@@deriving yojson]

      let make ~cookies ?browserContextId () = { cookies; browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.setCookies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears cookies. *)
  module ClearCookies = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Browser context to use when called on the browser endpoint."]
      }
      [@@deriving yojson]

      let make ?browserContextId () = { browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.clearCookies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns usage and quota in bytes. *)
  module GetUsageAndQuota = struct
    module Response : sig
      type result = {
        usage : Types.number;
            [@key "usage"] [@ocaml.doc "Storage usage (bytes)."]
        quota : Types.number;
            [@key "quota"] [@ocaml.doc "Storage quota (bytes)."]
        overrideActive : bool;
            [@key "overrideActive"]
            [@ocaml.doc
              "Whether or not the origin has an active storage quota override"]
        usageBreakdown : Types.Storage.UsageForType.t list;
            [@key "usageBreakdown"]
            [@ocaml.doc "Storage usage per type (bytes)."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        usage : Types.number;
            [@key "usage"] [@ocaml.doc "Storage usage (bytes)."]
        quota : Types.number;
            [@key "quota"] [@ocaml.doc "Storage quota (bytes)."]
        overrideActive : bool;
            [@key "overrideActive"]
            [@ocaml.doc
              "Whether or not the origin has an active storage quota override"]
        usageBreakdown : Types.Storage.UsageForType.t list;
            [@key "usageBreakdown"]
            [@ocaml.doc "Storage usage per type (bytes)."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getUsageAndQuota"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Override quota for the specified origin *)
  module OverrideQuotaForOrigin = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
        quotaSize : Types.number option;
            [@key "quotaSize"]
            [@yojson.option]
            [@ocaml.doc
              "The quota size (in bytes) to override the original quota with.\n\
               If this is called multiple times, the overridden quota will be \
               equal to\n\
               the quotaSize provided in the final call. If this is called \
               without\n\
               specifying a quotaSize, the quota will be reset to the default \
               value for\n\
               the specified origin. If this is called multiple times with \
               different\n\
               origins, the override will be maintained for each origin until \
               it is\n\
               disabled (called without a quotaSize)."]
      }
      [@@deriving yojson]

      let make ~origin ?quotaSize () = { origin; quotaSize }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.overrideQuotaForOrigin"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Registers origin to be notified when an update occurs to its cache storage list. *)
  module TrackCacheStorageForOrigin = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.trackCacheStorageForOrigin";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Registers storage key to be notified when an update occurs to its cache storage list. *)
  module TrackCacheStorageForStorageKey = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageKey : string; [@key "storageKey"] [@ocaml.doc "Storage key."]
      }
      [@@deriving yojson]

      let make ~storageKey () = { storageKey }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.trackCacheStorageForStorageKey";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Registers origin to be notified when an update occurs to its IndexedDB. *)
  module TrackIndexedDBForOrigin = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.trackIndexedDBForOrigin"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Registers storage key to be notified when an update occurs to its IndexedDB. *)
  module TrackIndexedDBForStorageKey = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageKey : string; [@key "storageKey"] [@ocaml.doc "Storage key."]
      }
      [@@deriving yojson]

      let make ~storageKey () = { storageKey }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.trackIndexedDBForStorageKey";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Unregisters origin from receiving notifications for cache storage. *)
  module UntrackCacheStorageForOrigin = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.untrackCacheStorageForOrigin";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Unregisters storage key from receiving notifications for cache storage. *)
  module UntrackCacheStorageForStorageKey = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageKey : string; [@key "storageKey"] [@ocaml.doc "Storage key."]
      }
      [@@deriving yojson]

      let make ~storageKey () = { storageKey }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.untrackCacheStorageForStorageKey";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Unregisters origin from receiving notifications for IndexedDB. *)
  module UntrackIndexedDBForOrigin = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.untrackIndexedDBForOrigin"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Unregisters storage key from receiving notifications for IndexedDB. *)
  module UntrackIndexedDBForStorageKey = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageKey : string; [@key "storageKey"] [@ocaml.doc "Storage key."]
      }
      [@@deriving yojson]

      let make ~storageKey () = { storageKey }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.untrackIndexedDBForStorageKey";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the number of stored Trust Tokens per issuer for the
     current browsing context. *)
  module GetTrustTokens = struct
    module Response : sig
      type result = {
        tokens : Types.Storage.TrustTokens.t list;
            [@key "tokens"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        tokens : Types.Storage.TrustTokens.t list;
            [@key "tokens"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Storage.getTrustTokens"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Removes all Trust Tokens issued by the provided issuerOrigin.
     Leaves other stored data, including the issuer's Redemption Records, intact. *)
  module ClearTrustTokens = struct
    module Response : sig
      type result = {
        didDeleteTokens : bool;
            [@key "didDeleteTokens"]
            [@ocaml.doc "True if any tokens were deleted, false otherwise."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        didDeleteTokens : bool;
            [@key "didDeleteTokens"]
            [@ocaml.doc "True if any tokens were deleted, false otherwise."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        issuerOrigin : string;
            [@key "issuerOrigin"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~issuerOrigin () = { issuerOrigin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.clearTrustTokens"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Gets details for a named interest group. *)
  module GetInterestGroupDetails = struct
    module Response : sig
      type result = {
        details : Types.Storage.InterestGroupDetails.t;
            [@key "details"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        details : Types.Storage.InterestGroupDetails.t;
            [@key "details"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
        name : string; [@key "name"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~ownerOrigin ~name () = { ownerOrigin; name }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getInterestGroupDetails"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables/Disables issuing of interestGroupAccessed events. *)
  module SetInterestGroupTracking = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enable : bool; [@key "enable"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enable () = { enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.setInterestGroupTracking"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Gets metadata for an origin's shared storage. *)
  module GetSharedStorageMetadata = struct
    module Response : sig
      type result = {
        metadata : Types.Storage.SharedStorageMetadata.t;
            [@key "metadata"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        metadata : Types.Storage.SharedStorageMetadata.t;
            [@key "metadata"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~ownerOrigin () = { ownerOrigin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getSharedStorageMetadata"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Gets the entries in an given origin's shared storage. *)
  module GetSharedStorageEntries = struct
    module Response : sig
      type result = {
        entries : Types.Storage.SharedStorageEntry.t list;
            [@key "entries"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        entries : Types.Storage.SharedStorageEntry.t list;
            [@key "entries"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~ownerOrigin () = { ownerOrigin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getSharedStorageEntries"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets entry with `key` and `value` for a given origin's shared storage. *)
  module SetSharedStorageEntry = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
        key : string; [@key "key"] [@ocaml.doc "No description provided"]
        value : string; [@key "value"] [@ocaml.doc "No description provided"]
        ignoreIfPresent : bool option;
            [@key "ignoreIfPresent"]
            [@yojson.option]
            [@ocaml.doc
              "If `ignoreIfPresent` is included and true, then only sets the \
               entry if\n\
               `key` doesn't already exist."]
      }
      [@@deriving yojson]

      let make ~ownerOrigin ~key ~value ?ignoreIfPresent () =
        { ownerOrigin; key; value; ignoreIfPresent }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.setSharedStorageEntry"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Deletes entry for `key` (if it exists) for a given origin's shared storage. *)
  module DeleteSharedStorageEntry = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
        key : string; [@key "key"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~ownerOrigin ~key () = { ownerOrigin; key }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.deleteSharedStorageEntry"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears all entries for a given origin's shared storage. *)
  module ClearSharedStorageEntries = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~ownerOrigin () = { ownerOrigin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.clearSharedStorageEntries"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Resets the budget for `ownerOrigin` by clearing all budget withdrawals. *)
  module ResetSharedStorageBudget = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~ownerOrigin () = { ownerOrigin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.resetSharedStorageBudget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables/disables issuing of sharedStorageAccessed events. *)
  module SetSharedStorageTracking = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enable : bool; [@key "enable"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enable () = { enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.setSharedStorageTracking"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module SystemInfo = struct
  (* Returns information about the system. *)
  module GetInfo = struct
    module Response : sig
      type result = {
        gpu : Types.SystemInfo.GPUInfo.t;
            [@key "gpu"]
            [@ocaml.doc "Information about the GPUs on the system."]
        modelName : string;
            [@key "modelName"]
            [@ocaml.doc
              "A platform-dependent description of the model of the machine. \
               On Mac OS, this is, for\n\
               example, 'MacBookPro'. Will be the empty string if not \
               supported."]
        modelVersion : string;
            [@key "modelVersion"]
            [@ocaml.doc
              "A platform-dependent description of the version of the machine. \
               On Mac OS, this is, for\n\
               example, '10.1'. Will be the empty string if not supported."]
        commandLine : string;
            [@key "commandLine"]
            [@ocaml.doc
              "The command line string used to launch the browser. Will be the \
               empty string if not\n\
               supported."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        gpu : Types.SystemInfo.GPUInfo.t;
            [@key "gpu"]
            [@ocaml.doc "Information about the GPUs on the system."]
        modelName : string;
            [@key "modelName"]
            [@ocaml.doc
              "A platform-dependent description of the model of the machine. \
               On Mac OS, this is, for\n\
               example, 'MacBookPro'. Will be the empty string if not \
               supported."]
        modelVersion : string;
            [@key "modelVersion"]
            [@ocaml.doc
              "A platform-dependent description of the version of the machine. \
               On Mac OS, this is, for\n\
               example, '10.1'. Will be the empty string if not supported."]
        commandLine : string;
            [@key "commandLine"]
            [@ocaml.doc
              "The command line string used to launch the browser. Will be the \
               empty string if not\n\
               supported."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "SystemInfo.getInfo"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns information about the feature state. *)
  module GetFeatureState = struct
    module Response : sig
      type result = {
        featureEnabled : bool;
            [@key "featureEnabled"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        featureEnabled : bool;
            [@key "featureEnabled"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        featureState : string;
            [@key "featureState"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~featureState () = { featureState }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "SystemInfo.getFeatureState"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns information about all running processes. *)
  module GetProcessInfo = struct
    module Response : sig
      type result = {
        processInfo : Types.SystemInfo.ProcessInfo.t list;
            [@key "processInfo"] [@ocaml.doc "An array of process info blocks."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        processInfo : Types.SystemInfo.ProcessInfo.t list;
            [@key "processInfo"] [@ocaml.doc "An array of process info blocks."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "SystemInfo.getProcessInfo"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Target = struct
  (* Activates (focuses) the target. *)
  module ActivateTarget = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~targetId () = { targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.activateTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Attaches to the target with given id. *)
  module AttachToTarget = struct
    module Response : sig
      type result = {
        sessionId : Types.Target.SessionID.t;
            [@key "sessionId"] [@ocaml.doc "Id assigned to the session."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        sessionId : Types.Target.SessionID.t;
            [@key "sessionId"] [@ocaml.doc "Id assigned to the session."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "No description provided"]
        flatten : bool option;
            [@key "flatten"]
            [@yojson.option]
            [@ocaml.doc
              "Enables \"flat\" access to the session via specifying sessionId \
               attribute in the commands.\n\
               We plan to make this the default, deprecate non-flattened mode,\n\
               and eventually retire it. See crbug.com/991325."]
      }
      [@@deriving yojson]

      let make ~targetId ?flatten () = { targetId; flatten }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.attachToTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Attaches to the browser target, only uses flat sessionId mode. *)
  module AttachToBrowserTarget = struct
    module Response : sig
      type result = {
        sessionId : Types.Target.SessionID.t;
            [@key "sessionId"] [@ocaml.doc "Id assigned to the session."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        sessionId : Types.Target.SessionID.t;
            [@key "sessionId"] [@ocaml.doc "Id assigned to the session."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Target.attachToBrowserTarget"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Closes the target. If the target is a page that gets closed too. *)
  module CloseTarget = struct
    module Response : sig
      type result = {
        success : bool;
            [@key "success"]
            [@ocaml.doc
              "Always set to true. If an error occurs, the response indicates \
               protocol error."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        success : bool;
            [@key "success"]
            [@ocaml.doc
              "Always set to true. If an error occurs, the response indicates \
               protocol error."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~targetId () = { targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.closeTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Inject object to the target's main frame that provides a communication
     channel with browser target.

     Injected object will be available as `window[bindingName]`.

     The object has the follwing API:
     - `binding.send(json)` - a method to send messages over the remote debugging protocol
     - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses. *)
  module ExposeDevToolsProtocol = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "No description provided"]
        bindingName : string option;
            [@key "bindingName"]
            [@yojson.option]
            [@ocaml.doc "Binding name, 'cdp' if not specified."]
      }
      [@@deriving yojson]

      let make ~targetId ?bindingName () = { targetId; bindingName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.exposeDevToolsProtocol"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
     one. *)
  module CreateBrowserContext = struct
    module Response : sig
      type result = {
        browserContextId : Types.Browser.BrowserContextID.t;
            [@key "browserContextId"]
            [@ocaml.doc "The id of the context created."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        browserContextId : Types.Browser.BrowserContextID.t;
            [@key "browserContextId"]
            [@ocaml.doc "The id of the context created."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        disposeOnDetach : bool option;
            [@key "disposeOnDetach"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, disposes this context when debugging session \
               disconnects."]
        proxyServer : string option;
            [@key "proxyServer"]
            [@yojson.option]
            [@ocaml.doc
              "Proxy server, similar to the one passed to --proxy-server"]
        proxyBypassList : string option;
            [@key "proxyBypassList"]
            [@yojson.option]
            [@ocaml.doc
              "Proxy bypass list, similar to the one passed to \
               --proxy-bypass-list"]
        originsWithUniversalNetworkAccess : string list option;
            [@key "originsWithUniversalNetworkAccess"]
            [@yojson.option]
            [@ocaml.doc
              "An optional list of origins to grant unlimited cross-origin \
               access to.\n\
               Parts of the URL other than those constituting origin are \
               ignored."]
      }
      [@@deriving yojson]

      let make ?disposeOnDetach ?proxyServer ?proxyBypassList
          ?originsWithUniversalNetworkAccess () =
        {
          disposeOnDetach;
          proxyServer;
          proxyBypassList;
          originsWithUniversalNetworkAccess;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.createBrowserContext"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns all browser contexts created with `Target.createBrowserContext` method. *)
  module GetBrowserContexts = struct
    module Response : sig
      type result = {
        browserContextIds : Types.Browser.BrowserContextID.t list;
            [@key "browserContextIds"]
            [@ocaml.doc "An array of browser context ids."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        browserContextIds : Types.Browser.BrowserContextID.t list;
            [@key "browserContextIds"]
            [@ocaml.doc "An array of browser context ids."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Target.getBrowserContexts"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Creates a new page. *)
  module CreateTarget = struct
    module Response : sig
      type result = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "The id of the page opened."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "The id of the page opened."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        url : string;
            [@key "url"]
            [@ocaml.doc
              "The initial URL the page will be navigated to. An empty string \
               indicates about:blank."]
        width : Types.number option;
            [@key "width"]
            [@yojson.option]
            [@ocaml.doc "Frame width in DIP (headless chrome only)."]
        height : Types.number option;
            [@key "height"]
            [@yojson.option]
            [@ocaml.doc "Frame height in DIP (headless chrome only)."]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc "The browser context to create the page in."]
        enableBeginFrameControl : bool option;
            [@key "enableBeginFrameControl"]
            [@yojson.option]
            [@ocaml.doc
              "Whether BeginFrames for this target will be controlled via \
               DevTools (headless chrome only,\n\
               not supported on MacOS yet, false by default)."]
        newWindow : bool option;
            [@key "newWindow"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to create a new Window or Tab (chrome-only, false by \
               default)."]
        background : bool option;
            [@key "background"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to create the target in background or foreground \
               (chrome-only,\n\
               false by default)."]
        forTab : bool option;
            [@key "forTab"]
            [@yojson.option]
            [@ocaml.doc "Whether to create the target of type \"tab\"."]
      }
      [@@deriving yojson]

      let make ~url ?width ?height ?browserContextId ?enableBeginFrameControl
          ?newWindow ?background ?forTab () =
        {
          url;
          width;
          height;
          browserContextId;
          enableBeginFrameControl;
          newWindow;
          background;
          forTab;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.createTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Detaches session with given id. *)
  module DetachFromTarget = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sessionId : Types.Target.SessionID.t option;
            [@key "sessionId"]
            [@yojson.option]
            [@ocaml.doc "Session to detach."]
        targetId : Types.Target.TargetID.t option;
            [@key "targetId"] [@yojson.option] [@ocaml.doc "Deprecated."]
      }
      [@@deriving yojson]

      let make ?sessionId ?targetId () = { sessionId; targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.detachFromTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Deletes a BrowserContext. All the belonging pages will be closed without calling their
     beforeunload hooks. *)
  module DisposeBrowserContext = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        browserContextId : Types.Browser.BrowserContextID.t;
            [@key "browserContextId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~browserContextId () = { browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.disposeBrowserContext"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns information about a target. *)
  module GetTargetInfo = struct
    module Response : sig
      type result = {
        targetInfo : Types.Target.TargetInfo.t;
            [@key "targetInfo"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        targetInfo : Types.Target.TargetInfo.t;
            [@key "targetInfo"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t option;
            [@key "targetId"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ?targetId () = { targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.getTargetInfo"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Retrieves a list of available targets. *)
  module GetTargets = struct
    module Response : sig
      type result = {
        targetInfos : Types.Target.TargetInfo.t list;
            [@key "targetInfos"] [@ocaml.doc "The list of targets."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        targetInfos : Types.Target.TargetInfo.t list;
            [@key "targetInfos"] [@ocaml.doc "The list of targets."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        filter : Types.Target.TargetFilter.t option;
            [@key "filter"]
            [@yojson.option]
            [@ocaml.doc
              "Only targets matching filter will be reported. If filter is not \
               specified\n\
               and target discovery is currently enabled, a filter used for \
               target discovery\n\
               is used for consistency."]
      }
      [@@deriving yojson]

      let make ?filter () = { filter }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.getTargets"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sends protocol message over session with given id.
     Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
     and crbug.com/991325. *)
  module SendMessageToTarget = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        message : string;
            [@key "message"] [@ocaml.doc "No description provided"]
        sessionId : Types.Target.SessionID.t option;
            [@key "sessionId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the session."]
        targetId : Types.Target.TargetID.t option;
            [@key "targetId"] [@yojson.option] [@ocaml.doc "Deprecated."]
      }
      [@@deriving yojson]

      let make ~message ?sessionId ?targetId () =
        { message; sessionId; targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.sendMessageToTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Controls whether to automatically attach to new targets which are considered to be related to
     this one. When turned on, attaches to all existing related targets as well. When turned off,
     automatically detaches from all currently attached targets.
     This also clears all targets added by `autoAttachRelated` from the list of targets to watch
     for creation of related targets. *)
  module SetAutoAttach = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        autoAttach : bool;
            [@key "autoAttach"]
            [@ocaml.doc "Whether to auto-attach to related targets."]
        waitForDebuggerOnStart : bool;
            [@key "waitForDebuggerOnStart"]
            [@ocaml.doc
              "Whether to pause new targets when attaching to them. Use \
               `Runtime.runIfWaitingForDebugger`\n\
               to run paused targets."]
        flatten : bool option;
            [@key "flatten"]
            [@yojson.option]
            [@ocaml.doc
              "Enables \"flat\" access to the session via specifying sessionId \
               attribute in the commands.\n\
               We plan to make this the default, deprecate non-flattened mode,\n\
               and eventually retire it. See crbug.com/991325."]
        filter : Types.Target.TargetFilter.t option;
            [@key "filter"]
            [@yojson.option]
            [@ocaml.doc "Only targets matching filter will be attached."]
      }
      [@@deriving yojson]

      let make ~autoAttach ~waitForDebuggerOnStart ?flatten ?filter () =
        { autoAttach; waitForDebuggerOnStart; flatten; filter }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.setAutoAttach"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Adds the specified target to the list of targets that will be monitored for any related target
     creation (such as child frames, child workers and new versions of service worker) and reported
     through `attachedToTarget`. The specified target is also auto-attached.
     This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent
     `setAutoAttach`. Only available at the Browser target. *)
  module AutoAttachRelated = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "No description provided"]
        waitForDebuggerOnStart : bool;
            [@key "waitForDebuggerOnStart"]
            [@ocaml.doc
              "Whether to pause new targets when attaching to them. Use \
               `Runtime.runIfWaitingForDebugger`\n\
               to run paused targets."]
        filter : Types.Target.TargetFilter.t option;
            [@key "filter"]
            [@yojson.option]
            [@ocaml.doc "Only targets matching filter will be attached."]
      }
      [@@deriving yojson]

      let make ~targetId ~waitForDebuggerOnStart ?filter () =
        { targetId; waitForDebuggerOnStart; filter }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.autoAttachRelated"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Controls whether to discover available targets and notify via
     `targetCreated/targetInfoChanged/targetDestroyed` events. *)
  module SetDiscoverTargets = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        discover : bool;
            [@key "discover"]
            [@ocaml.doc "Whether to discover available targets."]
        filter : Types.Target.TargetFilter.t option;
            [@key "filter"]
            [@yojson.option]
            [@ocaml.doc
              "Only targets matching filter will be attached. If `discover` is \
               false,\n\
               `filter` must be omitted or empty."]
      }
      [@@deriving yojson]

      let make ~discover ?filter () = { discover; filter }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.setDiscoverTargets"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
     `true`. *)
  module SetRemoteLocations = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        locations : Types.Target.RemoteLocation.t list;
            [@key "locations"] [@ocaml.doc "List of remote locations."]
      }
      [@@deriving yojson]

      let make ~locations () = { locations }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.setRemoteLocations"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Tethering = struct
  (* Request browser port binding. *)
  module Bind = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        port : Types.number; [@key "port"] [@ocaml.doc "Port number to bind."]
      }
      [@@deriving yojson]

      let make ~port () = { port }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Tethering.bind"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Request browser port unbinding. *)
  module Unbind = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        port : Types.number; [@key "port"] [@ocaml.doc "Port number to unbind."]
      }
      [@@deriving yojson]

      let make ~port () = { port }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Tethering.unbind"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Tracing = struct
  (* Stop trace events collection. *)
  module End = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Tracing.end"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Gets supported tracing categories. *)
  module GetCategories = struct
    module Response : sig
      type result = {
        categories : string list;
            [@key "categories"]
            [@ocaml.doc "A list of supported tracing categories."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        categories : string list;
            [@key "categories"]
            [@ocaml.doc "A list of supported tracing categories."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Tracing.getCategories"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Record a clock sync marker in the trace. *)
  module RecordClockSyncMarker = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        syncId : string;
            [@key "syncId"] [@ocaml.doc "The ID of this clock sync marker"]
      }
      [@@deriving yojson]

      let make ~syncId () = { syncId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Tracing.recordClockSyncMarker"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Request a global memory dump. *)
  module RequestMemoryDump = struct
    module Response : sig
      type result = {
        dumpGuid : string;
            [@key "dumpGuid"]
            [@ocaml.doc "GUID of the resulting global memory dump."]
        success : bool;
            [@key "success"]
            [@ocaml.doc "True iff the global memory dump succeeded."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        dumpGuid : string;
            [@key "dumpGuid"]
            [@ocaml.doc "GUID of the resulting global memory dump."]
        success : bool;
            [@key "success"]
            [@ocaml.doc "True iff the global memory dump succeeded."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        deterministic : bool option;
            [@key "deterministic"]
            [@yojson.option]
            [@ocaml.doc
              "Enables more deterministic results by forcing garbage collection"]
        levelOfDetail : Types.Tracing.MemoryDumpLevelOfDetail.t option;
            [@key "levelOfDetail"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies level of details in memory dump. Defaults to \
               \"detailed\"."]
      }
      [@@deriving yojson]

      let make ?deterministic ?levelOfDetail () =
        { deterministic; levelOfDetail }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Tracing.requestMemoryDump"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Start trace events collection. *)
  module Start = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type start_transfermode = [ `ReportEvents | `ReturnAsStream ]

      let start_transfermode_of_yojson = function
        | `String "ReportEvents" -> `ReportEvents
        | `String "ReturnAsStream" -> `ReturnAsStream
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_start_transfermode = function
        | `ReportEvents -> `String "ReportEvents"
        | `ReturnAsStream -> `String "ReturnAsStream"

      type t = {
        categories : string option;
            [@key "categories"]
            [@yojson.option]
            [@ocaml.doc "Category/tag filter"]
        options : string option;
            [@key "options"] [@yojson.option] [@ocaml.doc "Tracing options"]
        bufferUsageReportingInterval : Types.number option;
            [@key "bufferUsageReportingInterval"]
            [@yojson.option]
            [@ocaml.doc
              "If set, the agent will issue bufferUsage events at this \
               interval, specified in milliseconds"]
        transferMode : start_transfermode option;
            [@key "transferMode"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to report trace events as series of dataCollected \
               events or to save trace to a\n\
               stream (defaults to `ReportEvents`)."]
        streamFormat : Types.Tracing.StreamFormat.t option;
            [@key "streamFormat"]
            [@yojson.option]
            [@ocaml.doc
              "Trace data format to use. This only applies when using \
               `ReturnAsStream`\n\
               transfer mode (defaults to `json`)."]
        streamCompression : Types.Tracing.StreamCompression.t option;
            [@key "streamCompression"]
            [@yojson.option]
            [@ocaml.doc
              "Compression format to use. This only applies when using \
               `ReturnAsStream`\n\
               transfer mode (defaults to `none`)"]
        traceConfig : Types.Tracing.TraceConfig.t option;
            [@key "traceConfig"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        perfettoConfig : string option;
            [@key "perfettoConfig"]
            [@yojson.option]
            [@ocaml.doc
              "Base64-encoded serialized perfetto.protos.TraceConfig protobuf \
               message\n\
               When specified, the parameters `categories`, `options`, \
               `traceConfig`\n\
               are ignored. (Encoded as a base64 string when passed over JSON)"]
        tracingBackend : Types.Tracing.TracingBackend.t option;
            [@key "tracingBackend"]
            [@yojson.option]
            [@ocaml.doc "Backend type (defaults to `auto`)"]
      }
      [@@deriving yojson]

      let make ?categories ?options ?bufferUsageReportingInterval ?transferMode
          ?streamFormat ?streamCompression ?traceConfig ?perfettoConfig
          ?tracingBackend () =
        {
          categories;
          options;
          bufferUsageReportingInterval;
          transferMode;
          streamFormat;
          streamCompression;
          traceConfig;
          perfettoConfig;
          tracingBackend;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Tracing.start"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Fetch = struct
  (* Disables the fetch domain. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Fetch.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables issuing of requestPaused events. A request will be paused until client
     calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        patterns : Types.Fetch.RequestPattern.t list option;
            [@key "patterns"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, only requests matching any of these patterns will \
               produce\n\
               fetchRequested event and will be paused until clients response. \
               If not set,\n\
               all requests will be affected."]
        handleAuthRequests : bool option;
            [@key "handleAuthRequests"]
            [@yojson.option]
            [@ocaml.doc
              "If true, authRequired events will be issued and requests will \
               be paused\n\
               expecting a call to continueWithAuth."]
      }
      [@@deriving yojson]

      let make ?patterns ?handleAuthRequests () =
        { patterns; handleAuthRequests }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Causes the request to fail with specified reason. *)
  module FailRequest = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "An id the client received in requestPaused event."]
        errorReason : Types.Network.ErrorReason.t;
            [@key "errorReason"]
            [@ocaml.doc "Causes the request to fail with the given reason."]
      }
      [@@deriving yojson]

      let make ~requestId ~errorReason () = { requestId; errorReason }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.failRequest"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Provides response to the request. *)
  module FulfillRequest = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "An id the client received in requestPaused event."]
        responseCode : Types.number;
            [@key "responseCode"] [@ocaml.doc "An HTTP response code."]
        responseHeaders : Types.Fetch.HeaderEntry.t list option;
            [@key "responseHeaders"]
            [@yojson.option]
            [@ocaml.doc "Response headers."]
        binaryResponseHeaders : string option;
            [@key "binaryResponseHeaders"]
            [@yojson.option]
            [@ocaml.doc
              "Alternative way of specifying response headers as a \\0-separated\n\
               series of name: value pairs. Prefer the above method unless you\n\
               need to represent some non-UTF8 values that can't be transmitted\n\
               over the protocol as text. (Encoded as a base64 string when \
               passed over JSON)"]
        body : string option;
            [@key "body"]
            [@yojson.option]
            [@ocaml.doc
              "A response body. If absent, original response body will be used \
               if\n\
               the request is intercepted at the response stage and empty body\n\
               will be used if the request is intercepted at the request \
               stage. (Encoded as a base64 string when passed over JSON)"]
        responsePhrase : string option;
            [@key "responsePhrase"]
            [@yojson.option]
            [@ocaml.doc
              "A textual representation of responseCode.\n\
               If absent, a standard phrase matching responseCode is used."]
      }
      [@@deriving yojson]

      let make ~requestId ~responseCode ?responseHeaders ?binaryResponseHeaders
          ?body ?responsePhrase () =
        {
          requestId;
          responseCode;
          responseHeaders;
          binaryResponseHeaders;
          body;
          responsePhrase;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.fulfillRequest"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Continues the request, optionally modifying some of its parameters. *)
  module ContinueRequest = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "An id the client received in requestPaused event."]
        url : string option;
            [@key "url"]
            [@yojson.option]
            [@ocaml.doc
              "If set, the request url will be modified in a way that's not \
               observable by page."]
        method_ : string option;
            [@key "method"]
            [@yojson.option]
            [@ocaml.doc "If set, the request method is overridden."]
        postData : string option;
            [@key "postData"]
            [@yojson.option]
            [@ocaml.doc
              "If set, overrides the post data in the request. (Encoded as a \
               base64 string when passed over JSON)"]
        headers : Types.Fetch.HeaderEntry.t list option;
            [@key "headers"]
            [@yojson.option]
            [@ocaml.doc
              "If set, overrides the request headers. Note that the overrides \
               do not\n\
               extend to subsequent redirect hops, if a redirect happens. \
               Another override\n\
               may be applied to a different request produced by a redirect."]
        interceptResponse : bool option;
            [@key "interceptResponse"]
            [@yojson.option]
            [@ocaml.doc
              "If set, overrides response interception behavior for this \
               request."]
      }
      [@@deriving yojson]

      let make ~requestId ?url ?method_ ?postData ?headers ?interceptResponse ()
          =
        { requestId; url; method_; postData; headers; interceptResponse }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.continueRequest"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Continues a request supplying authChallengeResponse following authRequired event. *)
  module ContinueWithAuth = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "An id the client received in authRequired event."]
        authChallengeResponse : Types.Fetch.AuthChallengeResponse.t;
            [@key "authChallengeResponse"]
            [@ocaml.doc "Response to  with an authChallenge."]
      }
      [@@deriving yojson]

      let make ~requestId ~authChallengeResponse () =
        { requestId; authChallengeResponse }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.continueWithAuth"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Continues loading of the paused response, optionally modifying the
     response headers. If either responseCode or headers are modified, all of them
     must be present. *)
  module ContinueResponse = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "An id the client received in requestPaused event."]
        responseCode : Types.number option;
            [@key "responseCode"]
            [@yojson.option]
            [@ocaml.doc
              "An HTTP response code. If absent, original response code will \
               be used."]
        responsePhrase : string option;
            [@key "responsePhrase"]
            [@yojson.option]
            [@ocaml.doc
              "A textual representation of responseCode.\n\
               If absent, a standard phrase matching responseCode is used."]
        responseHeaders : Types.Fetch.HeaderEntry.t list option;
            [@key "responseHeaders"]
            [@yojson.option]
            [@ocaml.doc
              "Response headers. If absent, original response headers will be \
               used."]
        binaryResponseHeaders : string option;
            [@key "binaryResponseHeaders"]
            [@yojson.option]
            [@ocaml.doc
              "Alternative way of specifying response headers as a \\0-separated\n\
               series of name: value pairs. Prefer the above method unless you\n\
               need to represent some non-UTF8 values that can't be transmitted\n\
               over the protocol as text. (Encoded as a base64 string when \
               passed over JSON)"]
      }
      [@@deriving yojson]

      let make ~requestId ?responseCode ?responsePhrase ?responseHeaders
          ?binaryResponseHeaders () =
        {
          requestId;
          responseCode;
          responsePhrase;
          responseHeaders;
          binaryResponseHeaders;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.continueResponse"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Causes the body of the response to be received from the server and
     returned as a single string. May only be issued for a request that
     is paused in the Response stage and is mutually exclusive with
     takeResponseBodyForInterceptionAsStream. Calling other methods that
     affect the request or disabling fetch domain before body is received
     results in an undefined behavior. *)
  module GetResponseBody = struct
    module Response : sig
      type result = {
        body : string; [@key "body"] [@ocaml.doc "Response body."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        body : string; [@key "body"] [@ocaml.doc "Response body."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc
              "Identifier for the intercepted request to get body for."]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.getResponseBody"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns a handle to the stream representing the response body.
     The request must be paused in the HeadersReceived stage.
     Note that after this command the request can't be continued
     as is -- client either needs to cancel it or to provide the
     response body.
     The stream only supports sequential read, IO.read will fail if the position
     is specified.
     This method is mutually exclusive with getResponseBody.
     Calling other methods that affect the request or disabling fetch
     domain before body is received results in an undefined behavior. *)
  module TakeResponseBodyAsStream = struct
    module Response : sig
      type result = {
        stream : Types.IO.StreamHandle.t;
            [@key "stream"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        stream : Types.IO.StreamHandle.t;
            [@key "stream"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.takeResponseBodyAsStream"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module WebAudio = struct
  (* Enables the WebAudio domain and starts sending context lifetime events. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "WebAudio.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables the WebAudio domain. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "WebAudio.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Fetch the realtime data from the registered contexts. *)
  module GetRealtimeData = struct
    module Response : sig
      type result = {
        realtimeData : Types.WebAudio.ContextRealtimeData.t;
            [@key "realtimeData"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        realtimeData : Types.WebAudio.ContextRealtimeData.t;
            [@key "realtimeData"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        contextId : Types.WebAudio.GraphObjectId.t;
            [@key "contextId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~contextId () = { contextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAudio.getRealtimeData"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module WebAuthn = struct
  (* Enable the WebAuthn domain and start intercepting credential storage and
     retrieval with a virtual authenticator. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enableUI : bool option;
            [@key "enableUI"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to enable the WebAuthn user interface. Enabling the UI is\n\
               recommended for debugging and demo purposes, as it is closer to \
               the real\n\
               experience. Disabling the UI is recommended for automated \
               testing.\n\
               Supported at the embedder's discretion if UI is available.\n\
               Defaults to false."]
      }
      [@@deriving yojson]

      let make ?enableUI () = { enableUI }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disable the WebAuthn domain. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "WebAuthn.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Creates and adds a virtual authenticator. *)
  module AddVirtualAuthenticator = struct
    module Response : sig
      type result = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        options : Types.WebAuthn.VirtualAuthenticatorOptions.t;
            [@key "options"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~options () = { options }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.addVirtualAuthenticator"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present. *)
  module SetResponseOverrideBits = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        isBogusSignature : bool option;
            [@key "isBogusSignature"]
            [@yojson.option]
            [@ocaml.doc
              "If isBogusSignature is set, overrides the signature in the \
               authenticator response to be zero.\n\
               Defaults to false."]
        isBadUV : bool option;
            [@key "isBadUV"]
            [@yojson.option]
            [@ocaml.doc
              "If isBadUV is set, overrides the UV bit in the flags in the \
               authenticator response to\n\
               be zero. Defaults to false."]
        isBadUP : bool option;
            [@key "isBadUP"]
            [@yojson.option]
            [@ocaml.doc
              "If isBadUP is set, overrides the UP bit in the flags in the \
               authenticator response to\n\
               be zero. Defaults to false."]
      }
      [@@deriving yojson]

      let make ~authenticatorId ?isBogusSignature ?isBadUV ?isBadUP () =
        { authenticatorId; isBogusSignature; isBadUV; isBadUP }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.setResponseOverrideBits"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Removes the given authenticator. *)
  module RemoveVirtualAuthenticator = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId () = { authenticatorId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "WebAuthn.removeVirtualAuthenticator";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Adds the credential to the specified authenticator. *)
  module AddCredential = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        credential : Types.WebAuthn.Credential.t;
            [@key "credential"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId ~credential () = { authenticatorId; credential }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.addCredential"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns a single credential stored in the given virtual authenticator that
     matches the credential ID. *)
  module GetCredential = struct
    module Response : sig
      type result = {
        credential : Types.WebAuthn.Credential.t;
            [@key "credential"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        credential : Types.WebAuthn.Credential.t;
            [@key "credential"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        credentialId : string;
            [@key "credentialId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId ~credentialId () =
        { authenticatorId; credentialId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.getCredential"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns all the credentials stored in the given virtual authenticator. *)
  module GetCredentials = struct
    module Response : sig
      type result = {
        credentials : Types.WebAuthn.Credential.t list;
            [@key "credentials"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        credentials : Types.WebAuthn.Credential.t list;
            [@key "credentials"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId () = { authenticatorId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.getCredentials"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Removes a credential from the authenticator. *)
  module RemoveCredential = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        credentialId : string;
            [@key "credentialId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId ~credentialId () =
        { authenticatorId; credentialId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.removeCredential"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Clears all the credentials from the specified device. *)
  module ClearCredentials = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId () = { authenticatorId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.clearCredentials"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets whether User Verification succeeds or fails for an authenticator.
     The default is true. *)
  module SetUserVerified = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        isUserVerified : bool;
            [@key "isUserVerified"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId ~isUserVerified () =
        { authenticatorId; isUserVerified }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.setUserVerified"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.
     The default is true. *)
  module SetAutomaticPresenceSimulation = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        enabled : bool; [@key "enabled"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId ~enabled () = { authenticatorId; enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "WebAuthn.setAutomaticPresenceSimulation";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Media = struct
  (* Enables the Media domain *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Media.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables the Media domain. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Media.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module DeviceAccess = struct
  (* Enable events in this domain. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DeviceAccess.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disable events in this domain. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DeviceAccess.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Select a device in response to a DeviceAccess.deviceRequestPrompted event. *)
  module SelectPrompt = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        id : Types.DeviceAccess.RequestId.t;
            [@key "id"] [@ocaml.doc "No description provided"]
        deviceId : Types.DeviceAccess.DeviceId.t;
            [@key "deviceId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~id ~deviceId () = { id; deviceId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DeviceAccess.selectPrompt"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Cancel a prompt in response to a DeviceAccess.deviceRequestPrompted event. *)
  module CancelPrompt = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        id : Types.DeviceAccess.RequestId.t;
            [@key "id"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~id () = { id }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DeviceAccess.cancelPrompt"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Console = struct
  (* Does nothing. *)
  module ClearMessages = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Console.clearMessages"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables console domain, prevents further console messages from being reported to the client. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Console.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables console domain, sends the messages collected so far to the client by means of the
     `messageAdded` notification. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Console.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Debugger = struct
  (* Continues execution until specific location is reached. *)
  module ContinueToLocation = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type continuetolocation_targetcallframes = [ `any | `current ]

      let continuetolocation_targetcallframes_of_yojson = function
        | `String "any" -> `any
        | `String "current" -> `current
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_continuetolocation_targetcallframes = function
        | `any -> `String "any"
        | `current -> `String "current"

      type t = {
        location : Types.Debugger.Location.t;
            [@key "location"] [@ocaml.doc "Location to continue to."]
        targetCallFrames : continuetolocation_targetcallframes option;
            [@key "targetCallFrames"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~location ?targetCallFrames () = { location; targetCallFrames }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.continueToLocation"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables debugger for given page. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Debugger.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables debugger for the given page. Clients should not assume that the debugging has been
     enabled until the result for this command is received. *)
  module Enable = struct
    module Response : sig
      type result = {
        debuggerId : Types.Runtime.UniqueDebuggerId.t;
            [@key "debuggerId"]
            [@ocaml.doc "Unique identifier of the debugger."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        debuggerId : Types.Runtime.UniqueDebuggerId.t;
            [@key "debuggerId"]
            [@ocaml.doc "Unique identifier of the debugger."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        maxScriptsCacheSize : Types.number option;
            [@key "maxScriptsCacheSize"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum size in bytes of collected scripts (not referenced \
               by other heap objects)\n\
               the debugger can hold. Puts no limit if parameter is omitted."]
      }
      [@@deriving yojson]

      let make ?maxScriptsCacheSize () = { maxScriptsCacheSize }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Evaluates expression on a given call frame. *)
  module EvaluateOnCallFrame = struct
    module Response : sig
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"]
            [@ocaml.doc "Object wrapper for the evaluation result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"]
            [@ocaml.doc "Object wrapper for the evaluation result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        callFrameId : Types.Debugger.CallFrameId.t;
            [@key "callFrameId"]
            [@ocaml.doc "Call frame identifier to evaluate on."]
        expression : string;
            [@key "expression"] [@ocaml.doc "Expression to evaluate."]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "String object group name to put result into (allows rapid \
               releasing resulting object handles\n\
               using `releaseObjectGroup`)."]
        includeCommandLineAPI : bool option;
            [@key "includeCommandLineAPI"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies whether command line API should be available to the \
               evaluated expression, defaults\n\
               to false."]
        silent : bool option;
            [@key "silent"]
            [@yojson.option]
            [@ocaml.doc
              "In silent mode exceptions thrown during evaluation are not \
               reported and do not pause\n\
               execution. Overrides `setPauseOnException` state."]
        returnByValue : bool option;
            [@key "returnByValue"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the result is expected to be a JSON object that should \
               be sent by value."]
        generatePreview : bool option;
            [@key "generatePreview"]
            [@yojson.option]
            [@ocaml.doc "Whether preview should be generated for the result."]
        throwOnSideEffect : bool option;
            [@key "throwOnSideEffect"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to throw an exception if side effect cannot be ruled \
               out during evaluation."]
        timeout : Types.Runtime.TimeDelta.t option;
            [@key "timeout"]
            [@yojson.option]
            [@ocaml.doc
              "Terminate execution after timing out (number of milliseconds)."]
      }
      [@@deriving yojson]

      let make ~callFrameId ~expression ?objectGroup ?includeCommandLineAPI
          ?silent ?returnByValue ?generatePreview ?throwOnSideEffect ?timeout ()
          =
        {
          callFrameId;
          expression;
          objectGroup;
          includeCommandLineAPI;
          silent;
          returnByValue;
          generatePreview;
          throwOnSideEffect;
          timeout;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.evaluateOnCallFrame"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns possible locations for breakpoint. scriptId in start and end range locations should be
     the same. *)
  module GetPossibleBreakpoints = struct
    module Response : sig
      type result = {
        locations : Types.Debugger.BreakLocation.t list;
            [@key "locations"]
            [@ocaml.doc "List of the possible breakpoint locations."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        locations : Types.Debugger.BreakLocation.t list;
            [@key "locations"]
            [@ocaml.doc "List of the possible breakpoint locations."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        start : Types.Debugger.Location.t;
            [@key "start"]
            [@ocaml.doc
              "Start of range to search possible breakpoint locations in."]
        end_ : Types.Debugger.Location.t option;
            [@key "end"]
            [@yojson.option]
            [@ocaml.doc
              "End of range to search possible breakpoint locations in \
               (excluding). When not specified, end\n\
               of scripts is used as end of range."]
        restrictToFunction : bool option;
            [@key "restrictToFunction"]
            [@yojson.option]
            [@ocaml.doc
              "Only consider locations which are in the same (non-nested) \
               function as start."]
      }
      [@@deriving yojson]

      let make ~start ?end_ ?restrictToFunction () =
        { start; end_; restrictToFunction }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.getPossibleBreakpoints"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns source for the script with given id. *)
  module GetScriptSource = struct
    module Response : sig
      type result = {
        scriptSource : string;
            [@key "scriptSource"]
            [@ocaml.doc "Script source (empty in case of Wasm bytecode)."]
        bytecode : string option;
            [@key "bytecode"]
            [@yojson.option]
            [@ocaml.doc
              "Wasm bytecode. (Encoded as a base64 string when passed over \
               JSON)"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        scriptSource : string;
            [@key "scriptSource"]
            [@ocaml.doc "Script source (empty in case of Wasm bytecode)."]
        bytecode : string option;
            [@key "bytecode"]
            [@yojson.option]
            [@ocaml.doc
              "Wasm bytecode. (Encoded as a base64 string when passed over \
               JSON)"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"] [@ocaml.doc "Id of the script to get source for."]
      }
      [@@deriving yojson]

      let make ~scriptId () = { scriptId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.getScriptSource"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module DisassembleWasmModule = struct
    module Response : sig
      type result = {
        streamId : string option;
            [@key "streamId"]
            [@yojson.option]
            [@ocaml.doc
              "For large modules, return a stream from which additional chunks \
               of\n\
               disassembly can be read successively."]
        totalNumberOfLines : Types.number;
            [@key "totalNumberOfLines"]
            [@ocaml.doc "The total number of lines in the disassembly text."]
        functionBodyOffsets : Types.number list;
            [@key "functionBodyOffsets"]
            [@ocaml.doc
              "The offsets of all function bodies, in the format [start1, end1,\n\
               start2, end2, ...] where all ends are exclusive."]
        chunk : Types.Debugger.WasmDisassemblyChunk.t;
            [@key "chunk"] [@ocaml.doc "The first chunk of disassembly."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        streamId : string option;
            [@key "streamId"]
            [@yojson.option]
            [@ocaml.doc
              "For large modules, return a stream from which additional chunks \
               of\n\
               disassembly can be read successively."]
        totalNumberOfLines : Types.number;
            [@key "totalNumberOfLines"]
            [@ocaml.doc "The total number of lines in the disassembly text."]
        functionBodyOffsets : Types.number list;
            [@key "functionBodyOffsets"]
            [@ocaml.doc
              "The offsets of all function bodies, in the format [start1, end1,\n\
               start2, end2, ...] where all ends are exclusive."]
        chunk : Types.Debugger.WasmDisassemblyChunk.t;
            [@key "chunk"] [@ocaml.doc "The first chunk of disassembly."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"] [@ocaml.doc "Id of the script to disassemble"]
      }
      [@@deriving yojson]

      let make ~scriptId () = { scriptId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.disassembleWasmModule"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disassemble the next chunk of lines for the module corresponding to the
     stream. If disassembly is complete, this API will invalidate the streamId
     and return an empty chunk. Any subsequent calls for the now invalid stream
     will return errors. *)
  module NextWasmDisassemblyChunk = struct
    module Response : sig
      type result = {
        chunk : Types.Debugger.WasmDisassemblyChunk.t;
            [@key "chunk"] [@ocaml.doc "The next chunk of disassembly."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        chunk : Types.Debugger.WasmDisassemblyChunk.t;
            [@key "chunk"] [@ocaml.doc "The next chunk of disassembly."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        streamId : string;
            [@key "streamId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~streamId () = { streamId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.nextWasmDisassemblyChunk"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* This command is deprecated. Use getScriptSource instead. *)
  module GetWasmBytecode = struct
    module Response : sig
      type result = {
        bytecode : string;
            [@key "bytecode"]
            [@ocaml.doc
              "Script source. (Encoded as a base64 string when passed over \
               JSON)"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        bytecode : string;
            [@key "bytecode"]
            [@ocaml.doc
              "Script source. (Encoded as a base64 string when passed over \
               JSON)"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"]
            [@ocaml.doc "Id of the Wasm script to get source for."]
      }
      [@@deriving yojson]

      let make ~scriptId () = { scriptId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.getWasmBytecode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns stack trace with given `stackTraceId`. *)
  module GetStackTrace = struct
    module Response : sig
      type result = {
        stackTrace : Types.Runtime.StackTrace.t;
            [@key "stackTrace"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        stackTrace : Types.Runtime.StackTrace.t;
            [@key "stackTrace"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        stackTraceId : Types.Runtime.StackTraceId.t;
            [@key "stackTraceId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~stackTraceId () = { stackTraceId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.getStackTrace"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Stops on the next JavaScript statement. *)
  module Pause = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Debugger.pause"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module PauseOnAsyncCall = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        parentStackTraceId : Types.Runtime.StackTraceId.t;
            [@key "parentStackTraceId"]
            [@ocaml.doc
              "Debugger will pause when async call with given stack trace is \
               started."]
      }
      [@@deriving yojson]

      let make ~parentStackTraceId () = { parentStackTraceId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.pauseOnAsyncCall"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Removes JavaScript breakpoint. *)
  module RemoveBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~breakpointId () = { breakpointId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.removeBreakpoint"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Restarts particular call frame from the beginning. The old, deprecated
     behavior of `restartFrame` is to stay paused and allow further CDP commands
     after a restart was scheduled. This can cause problems with restarting, so
     we now continue execution immediatly after it has been scheduled until we
     reach the beginning of the restarted frame.

     To stay back-wards compatible, `restartFrame` now expects a `mode`
     parameter to be present. If the `mode` parameter is missing, `restartFrame`
     errors out.

     The various return values are deprecated and `callFrames` is always empty.
     Use the call frames from the `Debugger#paused` events instead, that fires
     once V8 pauses at the beginning of the restarted function. *)
  module RestartFrame = struct
    module Response : sig
      type result = {
        callFrames : Types.Debugger.CallFrame.t list;
            [@key "callFrames"] [@ocaml.doc "New stack trace."]
        asyncStackTrace : Types.Runtime.StackTrace.t option;
            [@key "asyncStackTrace"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
        asyncStackTraceId : Types.Runtime.StackTraceId.t option;
            [@key "asyncStackTraceId"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        callFrames : Types.Debugger.CallFrame.t list;
            [@key "callFrames"] [@ocaml.doc "New stack trace."]
        asyncStackTrace : Types.Runtime.StackTrace.t option;
            [@key "asyncStackTrace"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
        asyncStackTraceId : Types.Runtime.StackTraceId.t option;
            [@key "asyncStackTraceId"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type restartframe_mode = [ `StepInto ]

      let restartframe_mode_of_yojson = function
        | `String "StepInto" -> `StepInto
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_restartframe_mode = function
        | `StepInto -> `String "StepInto"

      type t = {
        callFrameId : Types.Debugger.CallFrameId.t;
            [@key "callFrameId"]
            [@ocaml.doc "Call frame identifier to evaluate on."]
        mode : restartframe_mode option;
            [@key "mode"]
            [@yojson.option]
            [@ocaml.doc
              "The `mode` parameter must be present and set to 'StepInto', \
               otherwise\n\
               `restartFrame` will error out."]
      }
      [@@deriving yojson]

      let make ~callFrameId ?mode () = { callFrameId; mode }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.restartFrame"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Resumes JavaScript execution. *)
  module Resume = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        terminateOnResume : bool option;
            [@key "terminateOnResume"]
            [@yojson.option]
            [@ocaml.doc
              "Set to true to terminate execution upon resuming execution. In \
               contrast\n\
               to Runtime.terminateExecution, this will allows to execute \
               further\n\
               JavaScript (i.e. via evaluation) until execution of the paused \
               code\n\
               is actually resumed, at which point termination is triggered.\n\
               If execution is currently not paused, this parameter has no \
               effect."]
      }
      [@@deriving yojson]

      let make ?terminateOnResume () = { terminateOnResume }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.resume"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Searches for given string in script content. *)
  module SearchInContent = struct
    module Response : sig
      type result = {
        result : Types.Debugger.SearchMatch.t list;
            [@key "result"] [@ocaml.doc "List of search matches."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Debugger.SearchMatch.t list;
            [@key "result"] [@ocaml.doc "List of search matches."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"] [@ocaml.doc "Id of the script to search in."]
        query : string; [@key "query"] [@ocaml.doc "String to search for."]
        caseSensitive : bool option;
            [@key "caseSensitive"]
            [@yojson.option]
            [@ocaml.doc "If true, search is case sensitive."]
        isRegex : bool option;
            [@key "isRegex"]
            [@yojson.option]
            [@ocaml.doc "If true, treats string parameter as regex."]
      }
      [@@deriving yojson]

      let make ~scriptId ~query ?caseSensitive ?isRegex () =
        { scriptId; query; caseSensitive; isRegex }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.searchInContent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables or disables async call stacks tracking. *)
  module SetAsyncCallStackDepth = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        maxDepth : Types.number;
            [@key "maxDepth"]
            [@ocaml.doc
              "Maximum depth of async call stacks. Setting to `0` will \
               effectively disable collecting async\n\
               call stacks (default)."]
      }
      [@@deriving yojson]

      let make ~maxDepth () = { maxDepth }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setAsyncCallStackDepth"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
     scripts with url matching one of the patterns. VM will try to leave blackboxed script by
     performing 'step in' several times, finally resorting to 'step out' if unsuccessful. *)
  module SetBlackboxPatterns = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        patterns : string list;
            [@key "patterns"]
            [@ocaml.doc
              "Array of regexps that will be used to check script url for \
               blackbox state."]
      }
      [@@deriving yojson]

      let make ~patterns () = { patterns }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setBlackboxPatterns"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
     scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
     Positions array contains positions where blackbox state is changed. First interval isn't
     blackboxed. Array should be sorted. *)
  module SetBlackboxedRanges = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"] [@ocaml.doc "Id of the script."]
        positions : Types.Debugger.ScriptPosition.t list;
            [@key "positions"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scriptId ~positions () = { scriptId; positions }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setBlackboxedRanges"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets JavaScript breakpoint at a given location. *)
  module SetBreakpoint = struct
    module Response : sig
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
        actualLocation : Types.Debugger.Location.t;
            [@key "actualLocation"]
            [@ocaml.doc "Location this breakpoint resolved into."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
        actualLocation : Types.Debugger.Location.t;
            [@key "actualLocation"]
            [@ocaml.doc "Location this breakpoint resolved into."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        location : Types.Debugger.Location.t;
            [@key "location"] [@ocaml.doc "Location to set breakpoint in."]
        condition : string option;
            [@key "condition"]
            [@yojson.option]
            [@ocaml.doc
              "Expression to use as a breakpoint condition. When specified, \
               debugger will only stop on the\n\
               breakpoint if this expression evaluates to true."]
      }
      [@@deriving yojson]

      let make ~location ?condition () = { location; condition }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setBreakpoint"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets instrumentation breakpoint. *)
  module SetInstrumentationBreakpoint = struct
    module Response : sig
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setinstrumentationbreakpoint_instrumentation =
        [ `beforeScriptExecution | `beforeScriptWithSourceMapExecution ]

      let setinstrumentationbreakpoint_instrumentation_of_yojson = function
        | `String "beforeScriptExecution" -> `beforeScriptExecution
        | `String "beforeScriptWithSourceMapExecution" ->
            `beforeScriptWithSourceMapExecution
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setinstrumentationbreakpoint_instrumentation = function
        | `beforeScriptExecution -> `String "beforeScriptExecution"
        | `beforeScriptWithSourceMapExecution ->
            `String "beforeScriptWithSourceMapExecution"

      type t = {
        instrumentation : setinstrumentationbreakpoint_instrumentation;
            [@key "instrumentation"] [@ocaml.doc "Instrumentation name."]
      }
      [@@deriving yojson]

      let make ~instrumentation () = { instrumentation }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Debugger.setInstrumentationBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
     command is issued, all existing parsed scripts will have breakpoints resolved and returned in
     `locations` property. Further matching script parsing will result in subsequent
     `breakpointResolved` events issued. This logical breakpoint will survive page reloads. *)
  module SetBreakpointByUrl = struct
    module Response : sig
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
        locations : Types.Debugger.Location.t list;
            [@key "locations"]
            [@ocaml.doc
              "List of the locations this breakpoint resolved into upon \
               addition."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
        locations : Types.Debugger.Location.t list;
            [@key "locations"]
            [@ocaml.doc
              "List of the locations this breakpoint resolved into upon \
               addition."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        lineNumber : Types.number;
            [@key "lineNumber"] [@ocaml.doc "Line number to set breakpoint at."]
        url : string option;
            [@key "url"]
            [@yojson.option]
            [@ocaml.doc "URL of the resources to set breakpoint on."]
        urlRegex : string option;
            [@key "urlRegex"]
            [@yojson.option]
            [@ocaml.doc
              "Regex pattern for the URLs of the resources to set breakpoints \
               on. Either `url` or\n\
               `urlRegex` must be specified."]
        scriptHash : string option;
            [@key "scriptHash"]
            [@yojson.option]
            [@ocaml.doc "Script hash of the resources to set breakpoint on."]
        columnNumber : Types.number option;
            [@key "columnNumber"]
            [@yojson.option]
            [@ocaml.doc "Offset in the line to set breakpoint at."]
        condition : string option;
            [@key "condition"]
            [@yojson.option]
            [@ocaml.doc
              "Expression to use as a breakpoint condition. When specified, \
               debugger will only stop on the\n\
               breakpoint if this expression evaluates to true."]
      }
      [@@deriving yojson]

      let make ~lineNumber ?url ?urlRegex ?scriptHash ?columnNumber ?condition
          () =
        { lineNumber; url; urlRegex; scriptHash; columnNumber; condition }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setBreakpointByUrl"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Sets JavaScript breakpoint before each call to the given function.
     If another function was created from the same source as a given one,
     calling it will also trigger the breakpoint. *)
  module SetBreakpointOnFunctionCall = struct
    module Response : sig
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"] [@ocaml.doc "Function object id."]
        condition : string option;
            [@key "condition"]
            [@yojson.option]
            [@ocaml.doc
              "Expression to use as a breakpoint condition. When specified, \
               debugger will\n\
               stop on the breakpoint if this expression evaluates to true."]
      }
      [@@deriving yojson]

      let make ~objectId ?condition () = { objectId; condition }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Debugger.setBreakpointOnFunctionCall";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Activates / deactivates all breakpoints on the page. *)
  module SetBreakpointsActive = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        active : bool;
            [@key "active"]
            [@ocaml.doc "New value for breakpoints active state."]
      }
      [@@deriving yojson]

      let make ~active () = { active }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setBreakpointsActive"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
     or caught exceptions, no exceptions. Initial pause on exceptions state is `none`. *)
  module SetPauseOnExceptions = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setpauseonexceptions_state = [ `none | `caught | `uncaught | `all ]

      let setpauseonexceptions_state_of_yojson = function
        | `String "none" -> `none
        | `String "caught" -> `caught
        | `String "uncaught" -> `uncaught
        | `String "all" -> `all
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setpauseonexceptions_state = function
        | `none -> `String "none"
        | `caught -> `String "caught"
        | `uncaught -> `String "uncaught"
        | `all -> `String "all"

      type t = {
        state : setpauseonexceptions_state;
            [@key "state"] [@ocaml.doc "Pause on exceptions mode."]
      }
      [@@deriving yojson]

      let make ~state () = { state }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setPauseOnExceptions"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Changes return value in top frame. Available only at return break position. *)
  module SetReturnValue = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        newValue : Types.Runtime.CallArgument.t;
            [@key "newValue"] [@ocaml.doc "New return value."]
      }
      [@@deriving yojson]

      let make ~newValue () = { newValue }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setReturnValue"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Edits JavaScript source live.

     In general, functions that are currently on the stack can not be edited with
     a single exception: If the edited function is the top-most stack frame and
     that is the only activation of that function on the stack. In this case
     the live edit will be successful and a `Debugger.restartFrame` for the
     top-most function is automatically triggered. *)
  module SetScriptSource = struct
    module Response : sig
      type setscriptsource_status =
        [ `Ok
        | `CompileError
        | `BlockedByActiveGenerator
        | `BlockedByActiveFunction
        | `BlockedByTopLevelEsModuleChange ]

      val setscriptsource_status_of_yojson :
        Yojson.Basic.t -> setscriptsource_status

      val yojson_of_setscriptsource_status :
        setscriptsource_status -> Yojson.Basic.t

      type result = {
        callFrames : Types.Debugger.CallFrame.t list option;
            [@key "callFrames"]
            [@yojson.option]
            [@ocaml.doc
              "New stack trace in case editing has happened while VM was \
               stopped."]
        stackChanged : bool option;
            [@key "stackChanged"]
            [@yojson.option]
            [@ocaml.doc
              "Whether current call stack  was modified after applying the \
               changes."]
        asyncStackTrace : Types.Runtime.StackTrace.t option;
            [@key "asyncStackTrace"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
        asyncStackTraceId : Types.Runtime.StackTraceId.t option;
            [@key "asyncStackTraceId"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
        status : setscriptsource_status;
            [@key "status"]
            [@ocaml.doc
              "Whether the operation was successful or not. Only `Ok` denotes a\n\
               successful live edit while the other enum variants denote why\n\
               the live edit failed."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc
              "Exception details if any. Only present when `status` is \
               `CompileError`."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type setscriptsource_status =
        [ `Ok
        | `CompileError
        | `BlockedByActiveGenerator
        | `BlockedByActiveFunction
        | `BlockedByTopLevelEsModuleChange ]

      let setscriptsource_status_of_yojson = function
        | `String "Ok" -> `Ok
        | `String "CompileError" -> `CompileError
        | `String "BlockedByActiveGenerator" -> `BlockedByActiveGenerator
        | `String "BlockedByActiveFunction" -> `BlockedByActiveFunction
        | `String "BlockedByTopLevelEsModuleChange" ->
            `BlockedByTopLevelEsModuleChange
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setscriptsource_status = function
        | `Ok -> `String "Ok"
        | `CompileError -> `String "CompileError"
        | `BlockedByActiveGenerator -> `String "BlockedByActiveGenerator"
        | `BlockedByActiveFunction -> `String "BlockedByActiveFunction"
        | `BlockedByTopLevelEsModuleChange ->
            `String "BlockedByTopLevelEsModuleChange"

      type result = {
        callFrames : Types.Debugger.CallFrame.t list option;
            [@key "callFrames"]
            [@yojson.option]
            [@ocaml.doc
              "New stack trace in case editing has happened while VM was \
               stopped."]
        stackChanged : bool option;
            [@key "stackChanged"]
            [@yojson.option]
            [@ocaml.doc
              "Whether current call stack  was modified after applying the \
               changes."]
        asyncStackTrace : Types.Runtime.StackTrace.t option;
            [@key "asyncStackTrace"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
        asyncStackTraceId : Types.Runtime.StackTraceId.t option;
            [@key "asyncStackTraceId"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
        status : setscriptsource_status;
            [@key "status"]
            [@ocaml.doc
              "Whether the operation was successful or not. Only `Ok` denotes a\n\
               successful live edit while the other enum variants denote why\n\
               the live edit failed."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc
              "Exception details if any. Only present when `status` is \
               `CompileError`."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"] [@ocaml.doc "Id of the script to edit."]
        scriptSource : string;
            [@key "scriptSource"] [@ocaml.doc "New content of the script."]
        dryRun : bool option;
            [@key "dryRun"]
            [@yojson.option]
            [@ocaml.doc
              "If true the change will not actually be applied. Dry run may be \
               used to get result\n\
               description without actually modifying the code."]
        allowTopFrameEditing : bool option;
            [@key "allowTopFrameEditing"]
            [@yojson.option]
            [@ocaml.doc
              "If true, then `scriptSource` is allowed to change the function \
               on top of the stack\n\
               as long as the top-most stack frame is the only activation of \
               that function."]
      }
      [@@deriving yojson]

      let make ~scriptId ~scriptSource ?dryRun ?allowTopFrameEditing () =
        { scriptId; scriptSource; dryRun; allowTopFrameEditing }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setScriptSource"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc). *)
  module SetSkipAllPauses = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        skip : bool;
            [@key "skip"] [@ocaml.doc "New value for skip pauses state."]
      }
      [@@deriving yojson]

      let make ~skip () = { skip }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setSkipAllPauses"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Changes value of variable in a callframe. Object-based scopes are not supported and must be
     mutated manually. *)
  module SetVariableValue = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scopeNumber : Types.number;
            [@key "scopeNumber"]
            [@ocaml.doc
              "0-based number of scope as was listed in scope chain. Only \
               'local', 'closure' and 'catch'\n\
               scope types are allowed. Other scopes could be manipulated \
               manually."]
        variableName : string;
            [@key "variableName"] [@ocaml.doc "Variable name."]
        newValue : Types.Runtime.CallArgument.t;
            [@key "newValue"] [@ocaml.doc "New variable value."]
        callFrameId : Types.Debugger.CallFrameId.t;
            [@key "callFrameId"]
            [@ocaml.doc "Id of callframe that holds variable."]
      }
      [@@deriving yojson]

      let make ~scopeNumber ~variableName ~newValue ~callFrameId () =
        { scopeNumber; variableName; newValue; callFrameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setVariableValue"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Steps into the function call. *)
  module StepInto = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        breakOnAsyncCall : bool option;
            [@key "breakOnAsyncCall"]
            [@yojson.option]
            [@ocaml.doc
              "Debugger will pause on the execution of the first async task \
               which was scheduled\n\
               before next pause."]
        skipList : Types.Debugger.LocationRange.t list option;
            [@key "skipList"]
            [@yojson.option]
            [@ocaml.doc
              "The skipList specifies location ranges that should be skipped \
               on step into."]
      }
      [@@deriving yojson]

      let make ?breakOnAsyncCall ?skipList () = { breakOnAsyncCall; skipList }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.stepInto"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Steps out of the function call. *)
  module StepOut = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Debugger.stepOut"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Steps over the statement. *)
  module StepOver = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        skipList : Types.Debugger.LocationRange.t list option;
            [@key "skipList"]
            [@yojson.option]
            [@ocaml.doc
              "The skipList specifies location ranges that should be skipped \
               on step over."]
      }
      [@@deriving yojson]

      let make ?skipList () = { skipList }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.stepOver"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module HeapProfiler = struct
  (* Enables console to refer to the node with given id via $x (see Command Line API for more details
     $x functions). *)
  module AddInspectedHeapObject = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        heapObjectId : Types.HeapProfiler.HeapSnapshotObjectId.t;
            [@key "heapObjectId"]
            [@ocaml.doc
              "Heap snapshot object id to be accessible by means of $x command \
               line API."]
      }
      [@@deriving yojson]

      let make ~heapObjectId () = { heapObjectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "HeapProfiler.addInspectedHeapObject";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module CollectGarbage = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeapProfiler.collectGarbage"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeapProfiler.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeapProfiler.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module GetHeapObjectId = struct
    module Response : sig
      type result = {
        heapSnapshotObjectId : Types.HeapProfiler.HeapSnapshotObjectId.t;
            [@key "heapSnapshotObjectId"]
            [@ocaml.doc
              "Id of the heap snapshot object corresponding to the passed \
               remote object id."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        heapSnapshotObjectId : Types.HeapProfiler.HeapSnapshotObjectId.t;
            [@key "heapSnapshotObjectId"]
            [@ocaml.doc
              "Id of the heap snapshot object corresponding to the passed \
               remote object id."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"]
            [@ocaml.doc "Identifier of the object to get heap object id for."]
      }
      [@@deriving yojson]

      let make ~objectId () = { objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "HeapProfiler.getHeapObjectId"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module GetObjectByHeapObjectId = struct
    module Response : sig
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Evaluation result."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Evaluation result."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.HeapProfiler.HeapSnapshotObjectId.t;
            [@key "objectId"] [@ocaml.doc "No description provided"]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "Symbolic group name that can be used to release multiple \
               objects."]
      }
      [@@deriving yojson]

      let make ~objectId ?objectGroup () = { objectId; objectGroup }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "HeapProfiler.getObjectByHeapObjectId";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module GetSamplingProfile = struct
    module Response : sig
      type result = {
        profile : Types.HeapProfiler.SamplingHeapProfile.t;
            [@key "profile"]
            [@ocaml.doc "Return the sampling profile being collected."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        profile : Types.HeapProfiler.SamplingHeapProfile.t;
            [@key "profile"]
            [@ocaml.doc "Return the sampling profile being collected."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeapProfiler.getSamplingProfile"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module StartSampling = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        samplingInterval : Types.number option;
            [@key "samplingInterval"]
            [@yojson.option]
            [@ocaml.doc
              "Average sample interval in bytes. Poisson distribution is used \
               for the intervals. The\n\
               default value is 32768 bytes."]
        includeObjectsCollectedByMajorGC : bool option;
            [@key "includeObjectsCollectedByMajorGC"]
            [@yojson.option]
            [@ocaml.doc
              "By default, the sampling heap profiler reports only objects \
               which are\n\
               still alive when the profile is returned via getSamplingProfile \
               or\n\
               stopSampling, which is useful for determining what functions \
               contribute\n\
               the most to steady-state memory usage. This flag instructs the \
               sampling\n\
               heap profiler to also include information about objects \
               discarded by\n\
               major GC, which will show which functions cause large temporary \
               memory\n\
               usage or long GC pauses."]
        includeObjectsCollectedByMinorGC : bool option;
            [@key "includeObjectsCollectedByMinorGC"]
            [@yojson.option]
            [@ocaml.doc
              "By default, the sampling heap profiler reports only objects \
               which are\n\
               still alive when the profile is returned via getSamplingProfile \
               or\n\
               stopSampling, which is useful for determining what functions \
               contribute\n\
               the most to steady-state memory usage. This flag instructs the \
               sampling\n\
               heap profiler to also include information about objects \
               discarded by\n\
               minor GC, which is useful when tuning a latency-sensitive \
               application\n\
               for minimal GC activity."]
      }
      [@@deriving yojson]

      let make ?samplingInterval ?includeObjectsCollectedByMajorGC
          ?includeObjectsCollectedByMinorGC () =
        {
          samplingInterval;
          includeObjectsCollectedByMajorGC;
          includeObjectsCollectedByMinorGC;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "HeapProfiler.startSampling"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module StartTrackingHeapObjects = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        trackAllocations : bool option;
            [@key "trackAllocations"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ?trackAllocations () = { trackAllocations }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "HeapProfiler.startTrackingHeapObjects";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module StopSampling = struct
    module Response : sig
      type result = {
        profile : Types.HeapProfiler.SamplingHeapProfile.t;
            [@key "profile"] [@ocaml.doc "Recorded sampling heap profile."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        profile : Types.HeapProfiler.SamplingHeapProfile.t;
            [@key "profile"] [@ocaml.doc "Recorded sampling heap profile."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeapProfiler.stopSampling"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module StopTrackingHeapObjects = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        reportProgress : bool option;
            [@key "reportProgress"]
            [@yojson.option]
            [@ocaml.doc
              "If true 'reportHeapSnapshotProgress' events will be generated \
               while snapshot is being taken\n\
               when the tracking is stopped."]
        treatGlobalObjectsAsRoots : bool option;
            [@key "treatGlobalObjectsAsRoots"]
            [@yojson.option]
            [@ocaml.doc "Deprecated in favor of `exposeInternals`."]
        captureNumericValue : bool option;
            [@key "captureNumericValue"]
            [@yojson.option]
            [@ocaml.doc
              "If true, numerical values are included in the snapshot"]
        exposeInternals : bool option;
            [@key "exposeInternals"]
            [@yojson.option]
            [@ocaml.doc "If true, exposes internals of the snapshot."]
      }
      [@@deriving yojson]

      let make ?reportProgress ?treatGlobalObjectsAsRoots ?captureNumericValue
          ?exposeInternals () =
        {
          reportProgress;
          treatGlobalObjectsAsRoots;
          captureNumericValue;
          exposeInternals;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "HeapProfiler.stopTrackingHeapObjects";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module TakeHeapSnapshot = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        reportProgress : bool option;
            [@key "reportProgress"]
            [@yojson.option]
            [@ocaml.doc
              "If true 'reportHeapSnapshotProgress' events will be generated \
               while snapshot is being taken."]
        treatGlobalObjectsAsRoots : bool option;
            [@key "treatGlobalObjectsAsRoots"]
            [@yojson.option]
            [@ocaml.doc
              "If true, a raw snapshot without artificial roots will be \
               generated.\n\
               Deprecated in favor of `exposeInternals`."]
        captureNumericValue : bool option;
            [@key "captureNumericValue"]
            [@yojson.option]
            [@ocaml.doc
              "If true, numerical values are included in the snapshot"]
        exposeInternals : bool option;
            [@key "exposeInternals"]
            [@yojson.option]
            [@ocaml.doc "If true, exposes internals of the snapshot."]
      }
      [@@deriving yojson]

      let make ?reportProgress ?treatGlobalObjectsAsRoots ?captureNumericValue
          ?exposeInternals () =
        {
          reportProgress;
          treatGlobalObjectsAsRoots;
          captureNumericValue;
          exposeInternals;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "HeapProfiler.takeHeapSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Profiler = struct
  (* No description provided *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Collect coverage data for the current isolate. The coverage data may be incomplete due to
     garbage collection. *)
  module GetBestEffortCoverage = struct
    module Response : sig
      type result = {
        result : Types.Profiler.ScriptCoverage.t list;
            [@key "result"]
            [@ocaml.doc "Coverage data for the current isolate."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Profiler.ScriptCoverage.t list;
            [@key "result"]
            [@ocaml.doc "Coverage data for the current isolate."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.getBestEffortCoverage"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Changes CPU profiler sampling interval. Must be called before CPU profiles recording started. *)
  module SetSamplingInterval = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        interval : Types.number;
            [@key "interval"]
            [@ocaml.doc "New sampling interval in microseconds."]
      }
      [@@deriving yojson]

      let make ~interval () = { interval }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Profiler.setSamplingInterval"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module Start = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.start"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
     coverage may be incomplete. Enabling prevents running optimized code and resets execution
     counters. *)
  module StartPreciseCoverage = struct
    module Response : sig
      type result = {
        timestamp : Types.number;
            [@key "timestamp"]
            [@ocaml.doc
              "Monotonically increasing time (in seconds) when the coverage \
               update was taken in the backend."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        timestamp : Types.number;
            [@key "timestamp"]
            [@ocaml.doc
              "Monotonically increasing time (in seconds) when the coverage \
               update was taken in the backend."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        callCount : bool option;
            [@key "callCount"]
            [@yojson.option]
            [@ocaml.doc
              "Collect accurate call counts beyond simple 'covered' or 'not \
               covered'."]
        detailed : bool option;
            [@key "detailed"]
            [@yojson.option]
            [@ocaml.doc "Collect block-based coverage."]
        allowTriggeredUpdates : bool option;
            [@key "allowTriggeredUpdates"]
            [@yojson.option]
            [@ocaml.doc
              "Allow the backend to send updates on its own initiative"]
      }
      [@@deriving yojson]

      let make ?callCount ?detailed ?allowTriggeredUpdates () =
        { callCount; detailed; allowTriggeredUpdates }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Profiler.startPreciseCoverage"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module Stop = struct
    module Response : sig
      type result = {
        profile : Types.Profiler.Profile.t;
            [@key "profile"] [@ocaml.doc "Recorded profile."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        profile : Types.Profiler.Profile.t;
            [@key "profile"] [@ocaml.doc "Recorded profile."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.stop"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disable precise code coverage. Disabling releases unnecessary execution count records and allows
     executing optimized code. *)
  module StopPreciseCoverage = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.stopPreciseCoverage"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Collect coverage data for the current isolate, and resets execution counters. Precise code
     coverage needs to have started. *)
  module TakePreciseCoverage = struct
    module Response : sig
      type result = {
        result : Types.Profiler.ScriptCoverage.t list;
            [@key "result"]
            [@ocaml.doc "Coverage data for the current isolate."]
        timestamp : Types.number;
            [@key "timestamp"]
            [@ocaml.doc
              "Monotonically increasing time (in seconds) when the coverage \
               update was taken in the backend."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Profiler.ScriptCoverage.t list;
            [@key "result"]
            [@ocaml.doc "Coverage data for the current isolate."]
        timestamp : Types.number;
            [@key "timestamp"]
            [@ocaml.doc
              "Monotonically increasing time (in seconds) when the coverage \
               update was taken in the backend."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.takePreciseCoverage"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Runtime = struct
  (* Add handler to promise with given promise object id. *)
  module AwaitPromise = struct
    module Response : sig
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"]
            [@ocaml.doc
              "Promise result. Will contain rejected value if promise was \
               rejected."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details if stack strace is available."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"]
            [@ocaml.doc
              "Promise result. Will contain rejected value if promise was \
               rejected."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details if stack strace is available."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        promiseObjectId : Types.Runtime.RemoteObjectId.t;
            [@key "promiseObjectId"] [@ocaml.doc "Identifier of the promise."]
        returnByValue : bool option;
            [@key "returnByValue"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the result is expected to be a JSON object that should \
               be sent by value."]
        generatePreview : bool option;
            [@key "generatePreview"]
            [@yojson.option]
            [@ocaml.doc "Whether preview should be generated for the result."]
      }
      [@@deriving yojson]

      let make ~promiseObjectId ?returnByValue ?generatePreview () =
        { promiseObjectId; returnByValue; generatePreview }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.awaitPromise"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Calls function with given declaration on the given object. Object group of the result is
     inherited from the target object. *)
  module CallFunctionOn = struct
    module Response : sig
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Call result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Call result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        functionDeclaration : string;
            [@key "functionDeclaration"]
            [@ocaml.doc "Declaration of the function to call."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc
              "Identifier of the object to call function on. Either objectId \
               or executionContextId should\n\
               be specified."]
        arguments : Types.Runtime.CallArgument.t list option;
            [@key "arguments"]
            [@yojson.option]
            [@ocaml.doc
              "Call arguments. All call arguments must belong to the same \
               JavaScript world as the target\n\
               object."]
        silent : bool option;
            [@key "silent"]
            [@yojson.option]
            [@ocaml.doc
              "In silent mode exceptions thrown during evaluation are not \
               reported and do not pause\n\
               execution. Overrides `setPauseOnException` state."]
        returnByValue : bool option;
            [@key "returnByValue"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the result is expected to be a JSON object which should \
               be sent by value."]
        generatePreview : bool option;
            [@key "generatePreview"]
            [@yojson.option]
            [@ocaml.doc "Whether preview should be generated for the result."]
        userGesture : bool option;
            [@key "userGesture"]
            [@yojson.option]
            [@ocaml.doc
              "Whether execution should be treated as initiated by user in the \
               UI."]
        awaitPromise : bool option;
            [@key "awaitPromise"]
            [@yojson.option]
            [@ocaml.doc
              "Whether execution should `await` for resulting value and return \
               once awaited promise is\n\
               resolved."]
        executionContextId : Types.Runtime.ExecutionContextId.t option;
            [@key "executionContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies execution context which global object will be used to \
               call function on. Either\n\
               executionContextId or objectId should be specified."]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "Symbolic group name that can be used to release multiple \
               objects. If objectGroup is not\n\
               specified and objectId is, objectGroup will be inherited from \
               object."]
        throwOnSideEffect : bool option;
            [@key "throwOnSideEffect"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to throw an exception if side effect cannot be ruled \
               out during evaluation."]
        uniqueContextId : string option;
            [@key "uniqueContextId"]
            [@yojson.option]
            [@ocaml.doc
              "An alternative way to specify the execution context to call \
               function on.\n\
               Compared to contextId that may be reused across processes, this \
               is guaranteed to be\n\
               system-unique, so it can be used to prevent accidental function \
               call\n\
               in context different than intended (e.g. as a result of \
               navigation across process\n\
               boundaries).\n\
               This is mutually exclusive with `executionContextId`."]
        generateWebDriverValue : bool option;
            [@key "generateWebDriverValue"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the result should contain `webDriverValue`, serialized \
               according to\n\
               https://w3c.github.io/webdriver-bidi. This is mutually \
               exclusive with `returnByValue`, but\n\
               resulting `objectId` is still provided."]
      }
      [@@deriving yojson]

      let make ~functionDeclaration ?objectId ?arguments ?silent ?returnByValue
          ?generatePreview ?userGesture ?awaitPromise ?executionContextId
          ?objectGroup ?throwOnSideEffect ?uniqueContextId
          ?generateWebDriverValue () =
        {
          functionDeclaration;
          objectId;
          arguments;
          silent;
          returnByValue;
          generatePreview;
          userGesture;
          awaitPromise;
          executionContextId;
          objectGroup;
          throwOnSideEffect;
          uniqueContextId;
          generateWebDriverValue;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.callFunctionOn"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Compiles expression. *)
  module CompileScript = struct
    module Response : sig
      type result = {
        scriptId : Types.Runtime.ScriptId.t option;
            [@key "scriptId"] [@yojson.option] [@ocaml.doc "Id of the script."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        scriptId : Types.Runtime.ScriptId.t option;
            [@key "scriptId"] [@yojson.option] [@ocaml.doc "Id of the script."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        expression : string;
            [@key "expression"] [@ocaml.doc "Expression to compile."]
        sourceURL : string;
            [@key "sourceURL"]
            [@ocaml.doc "Source url to be set for the script."]
        persistScript : bool;
            [@key "persistScript"]
            [@ocaml.doc
              "Specifies whether the compiled script should be persisted."]
        executionContextId : Types.Runtime.ExecutionContextId.t option;
            [@key "executionContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies in which execution context to perform script run. If \
               the parameter is omitted the\n\
               evaluation will be performed in the context of the inspected \
               page."]
      }
      [@@deriving yojson]

      let make ~expression ~sourceURL ~persistScript ?executionContextId () =
        { expression; sourceURL; persistScript; executionContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.compileScript"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Disables reporting of execution contexts creation. *)
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Discards collected exceptions and console API calls. *)
  module DiscardConsoleEntries = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.discardConsoleEntries"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables reporting of execution contexts creation by means of `executionContextCreated` event.
     When the reporting gets enabled the event will be sent immediately for each existing execution
     context. *)
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Evaluates expression on global object. *)
  module Evaluate = struct
    module Response : sig
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Evaluation result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Evaluation result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        expression : string;
            [@key "expression"] [@ocaml.doc "Expression to evaluate."]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "Symbolic group name that can be used to release multiple \
               objects."]
        includeCommandLineAPI : bool option;
            [@key "includeCommandLineAPI"]
            [@yojson.option]
            [@ocaml.doc
              "Determines whether Command Line API should be available during \
               the evaluation."]
        silent : bool option;
            [@key "silent"]
            [@yojson.option]
            [@ocaml.doc
              "In silent mode exceptions thrown during evaluation are not \
               reported and do not pause\n\
               execution. Overrides `setPauseOnException` state."]
        contextId : Types.Runtime.ExecutionContextId.t option;
            [@key "contextId"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies in which execution context to perform evaluation. If \
               the parameter is omitted the\n\
               evaluation will be performed in the context of the inspected \
               page.\n\
               This is mutually exclusive with `uniqueContextId`, which offers \
               an\n\
               alternative way to identify the execution context that is more \
               reliable\n\
               in a multi-process environment."]
        returnByValue : bool option;
            [@key "returnByValue"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the result is expected to be a JSON object that should \
               be sent by value."]
        generatePreview : bool option;
            [@key "generatePreview"]
            [@yojson.option]
            [@ocaml.doc "Whether preview should be generated for the result."]
        userGesture : bool option;
            [@key "userGesture"]
            [@yojson.option]
            [@ocaml.doc
              "Whether execution should be treated as initiated by user in the \
               UI."]
        awaitPromise : bool option;
            [@key "awaitPromise"]
            [@yojson.option]
            [@ocaml.doc
              "Whether execution should `await` for resulting value and return \
               once awaited promise is\n\
               resolved."]
        throwOnSideEffect : bool option;
            [@key "throwOnSideEffect"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to throw an exception if side effect cannot be ruled \
               out during evaluation.\n\
               This implies `disableBreaks` below."]
        timeout : Types.Runtime.TimeDelta.t option;
            [@key "timeout"]
            [@yojson.option]
            [@ocaml.doc
              "Terminate execution after timing out (number of milliseconds)."]
        disableBreaks : bool option;
            [@key "disableBreaks"]
            [@yojson.option]
            [@ocaml.doc "Disable breakpoints during execution."]
        replMode : bool option;
            [@key "replMode"]
            [@yojson.option]
            [@ocaml.doc
              "Setting this flag to true enables `let` re-declaration and \
               top-level `await`.\n\
               Note that `let` variables can only be re-declared if they \
               originate from\n\
               `replMode` themselves."]
        allowUnsafeEvalBlockedByCSP : bool option;
            [@key "allowUnsafeEvalBlockedByCSP"]
            [@yojson.option]
            [@ocaml.doc
              "The Content Security Policy (CSP) for the target might block \
               'unsafe-eval'\n\
               which includes eval(), Function(), setTimeout() and setInterval()\n\
               when called with non-callable arguments. This flag bypasses CSP \
               for this\n\
               evaluation and allows unsafe-eval. Defaults to true."]
        uniqueContextId : string option;
            [@key "uniqueContextId"]
            [@yojson.option]
            [@ocaml.doc
              "An alternative way to specify the execution context to evaluate \
               in.\n\
               Compared to contextId that may be reused across processes, this \
               is guaranteed to be\n\
               system-unique, so it can be used to prevent accidental \
               evaluation of the expression\n\
               in context different than intended (e.g. as a result of \
               navigation across process\n\
               boundaries).\n\
               This is mutually exclusive with `contextId`."]
        generateWebDriverValue : bool option;
            [@key "generateWebDriverValue"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the result should be serialized according to \
               https://w3c.github.io/webdriver-bidi."]
      }
      [@@deriving yojson]

      let make ~expression ?objectGroup ?includeCommandLineAPI ?silent
          ?contextId ?returnByValue ?generatePreview ?userGesture ?awaitPromise
          ?throwOnSideEffect ?timeout ?disableBreaks ?replMode
          ?allowUnsafeEvalBlockedByCSP ?uniqueContextId ?generateWebDriverValue
          () =
        {
          expression;
          objectGroup;
          includeCommandLineAPI;
          silent;
          contextId;
          returnByValue;
          generatePreview;
          userGesture;
          awaitPromise;
          throwOnSideEffect;
          timeout;
          disableBreaks;
          replMode;
          allowUnsafeEvalBlockedByCSP;
          uniqueContextId;
          generateWebDriverValue;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.evaluate"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the isolate id. *)
  module GetIsolateId = struct
    module Response : sig
      type result = { id : string [@key "id"] [@ocaml.doc "The isolate id."] }
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = { id : string [@key "id"] [@ocaml.doc "The isolate id."] }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.getIsolateId"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns the JavaScript heap usage.
     It is the total usage of the corresponding isolate not scoped to a particular Runtime. *)
  module GetHeapUsage = struct
    module Response : sig
      type result = {
        usedSize : Types.number;
            [@key "usedSize"] [@ocaml.doc "Used heap size in bytes."]
        totalSize : Types.number;
            [@key "totalSize"] [@ocaml.doc "Allocated heap size in bytes."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        usedSize : Types.number;
            [@key "usedSize"] [@ocaml.doc "Used heap size in bytes."]
        totalSize : Types.number;
            [@key "totalSize"] [@ocaml.doc "Allocated heap size in bytes."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.getHeapUsage"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns properties of a given object. Object group of the result is inherited from the target
     object. *)
  module GetProperties = struct
    module Response : sig
      type result = {
        result : Types.Runtime.PropertyDescriptor.t list;
            [@key "result"] [@ocaml.doc "Object properties."]
        internalProperties :
          Types.Runtime.InternalPropertyDescriptor.t list option;
            [@key "internalProperties"]
            [@yojson.option]
            [@ocaml.doc
              "Internal object properties (only of the element itself)."]
        privateProperties :
          Types.Runtime.PrivatePropertyDescriptor.t list option;
            [@key "privateProperties"]
            [@yojson.option]
            [@ocaml.doc "Object private properties."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.PropertyDescriptor.t list;
            [@key "result"] [@ocaml.doc "Object properties."]
        internalProperties :
          Types.Runtime.InternalPropertyDescriptor.t list option;
            [@key "internalProperties"]
            [@yojson.option]
            [@ocaml.doc
              "Internal object properties (only of the element itself)."]
        privateProperties :
          Types.Runtime.PrivatePropertyDescriptor.t list option;
            [@key "privateProperties"]
            [@yojson.option]
            [@ocaml.doc "Object private properties."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"]
            [@ocaml.doc "Identifier of the object to return properties for."]
        ownProperties : bool option;
            [@key "ownProperties"]
            [@yojson.option]
            [@ocaml.doc
              "If true, returns properties belonging only to the element \
               itself, not to its prototype\n\
               chain."]
        accessorPropertiesOnly : bool option;
            [@key "accessorPropertiesOnly"]
            [@yojson.option]
            [@ocaml.doc
              "If true, returns accessor properties (with getter/setter) only; \
               internal properties are not\n\
               returned either."]
        generatePreview : bool option;
            [@key "generatePreview"]
            [@yojson.option]
            [@ocaml.doc "Whether preview should be generated for the results."]
        nonIndexedPropertiesOnly : bool option;
            [@key "nonIndexedPropertiesOnly"]
            [@yojson.option]
            [@ocaml.doc "If true, returns non-indexed properties only."]
      }
      [@@deriving yojson]

      let make ~objectId ?ownProperties ?accessorPropertiesOnly ?generatePreview
          ?nonIndexedPropertiesOnly () =
        {
          objectId;
          ownProperties;
          accessorPropertiesOnly;
          generatePreview;
          nonIndexedPropertiesOnly;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.getProperties"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Returns all let, const and class variables from global scope. *)
  module GlobalLexicalScopeNames = struct
    module Response : sig
      type result = {
        names : string list;
            [@key "names"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        names : string list;
            [@key "names"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        executionContextId : Types.Runtime.ExecutionContextId.t option;
            [@key "executionContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies in which execution context to lookup global scope \
               variables."]
      }
      [@@deriving yojson]

      let make ?executionContextId () = { executionContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.globalLexicalScopeNames"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module QueryObjects = struct
    module Response : sig
      type result = {
        objects : Types.Runtime.RemoteObject.t;
            [@key "objects"] [@ocaml.doc "Array with objects."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        objects : Types.Runtime.RemoteObject.t;
            [@key "objects"] [@ocaml.doc "Array with objects."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        prototypeObjectId : Types.Runtime.RemoteObjectId.t;
            [@key "prototypeObjectId"]
            [@ocaml.doc "Identifier of the prototype to return objects for."]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "Symbolic group name that can be used to release the results."]
      }
      [@@deriving yojson]

      let make ~prototypeObjectId ?objectGroup () =
        { prototypeObjectId; objectGroup }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.queryObjects"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Releases remote object with given id. *)
  module ReleaseObject = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"]
            [@ocaml.doc "Identifier of the object to release."]
      }
      [@@deriving yojson]

      let make ~objectId () = { objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.releaseObject"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Releases all remote objects that belong to a given group. *)
  module ReleaseObjectGroup = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectGroup : string;
            [@key "objectGroup"] [@ocaml.doc "Symbolic object group name."]
      }
      [@@deriving yojson]

      let make ~objectGroup () = { objectGroup }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.releaseObjectGroup"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Tells inspected instance to run if it was waiting for debugger to attach. *)
  module RunIfWaitingForDebugger = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.runIfWaitingForDebugger"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Runs script with given id in a given context. *)
  module RunScript = struct
    module Response : sig
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Run result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Run result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"] [@ocaml.doc "Id of the script to run."]
        executionContextId : Types.Runtime.ExecutionContextId.t option;
            [@key "executionContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies in which execution context to perform script run. If \
               the parameter is omitted the\n\
               evaluation will be performed in the context of the inspected \
               page."]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "Symbolic group name that can be used to release multiple \
               objects."]
        silent : bool option;
            [@key "silent"]
            [@yojson.option]
            [@ocaml.doc
              "In silent mode exceptions thrown during evaluation are not \
               reported and do not pause\n\
               execution. Overrides `setPauseOnException` state."]
        includeCommandLineAPI : bool option;
            [@key "includeCommandLineAPI"]
            [@yojson.option]
            [@ocaml.doc
              "Determines whether Command Line API should be available during \
               the evaluation."]
        returnByValue : bool option;
            [@key "returnByValue"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the result is expected to be a JSON object which should \
               be sent by value."]
        generatePreview : bool option;
            [@key "generatePreview"]
            [@yojson.option]
            [@ocaml.doc "Whether preview should be generated for the result."]
        awaitPromise : bool option;
            [@key "awaitPromise"]
            [@yojson.option]
            [@ocaml.doc
              "Whether execution should `await` for resulting value and return \
               once awaited promise is\n\
               resolved."]
      }
      [@@deriving yojson]

      let make ~scriptId ?executionContextId ?objectGroup ?silent
          ?includeCommandLineAPI ?returnByValue ?generatePreview ?awaitPromise
          () =
        {
          scriptId;
          executionContextId;
          objectGroup;
          silent;
          includeCommandLineAPI;
          returnByValue;
          generatePreview;
          awaitPromise;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.runScript"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Enables or disables async call stacks tracking. *)
  module SetAsyncCallStackDepth = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        maxDepth : Types.number;
            [@key "maxDepth"]
            [@ocaml.doc
              "Maximum depth of async call stacks. Setting to `0` will \
               effectively disable collecting async\n\
               call stacks (default)."]
      }
      [@@deriving yojson]

      let make ~maxDepth () = { maxDepth }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.setAsyncCallStackDepth"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetCustomObjectFormatterEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool; [@key "enabled"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Runtime.setCustomObjectFormatterEnabled";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* No description provided *)
  module SetMaxCallStackSizeToCapture = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        size : Types.number; [@key "size"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~size () = { size }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Runtime.setMaxCallStackSizeToCapture";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* Terminate current or next JavaScript execution.
     Will cancel the termination when the outer-most script execution ends. *)
  module TerminateExecution = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.terminateExecution"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* If executionContextId is empty, adds binding with the given name on the
     global objects of all inspected contexts, including those created later,
     bindings survive reloads.
     Binding function takes exactly one argument, this argument should be string,
     in case of any other input, function throws an exception.
     Each binding function call produces Runtime.bindingCalled notification. *)
  module AddBinding = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        name : string; [@key "name"] [@ocaml.doc "No description provided"]
        executionContextId : Types.Runtime.ExecutionContextId.t option;
            [@key "executionContextId"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, the binding would only be exposed to the specified\n\
               execution context. If omitted and `executionContextName` is not \
               set,\n\
               the binding is exposed to all execution contexts of the target.\n\
               This parameter is mutually exclusive with `executionContextName`.\n\
               Deprecated in favor of `executionContextName` due to an unclear \
               use case\n\
               and bugs in implementation (crbug.com/1169639). \
               `executionContextId` will be\n\
               removed in the future."]
        executionContextName : string option;
            [@key "executionContextName"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, the binding is exposed to the executionContext with\n\
               matching name, even for contexts created after the binding is \
               added.\n\
               See also `ExecutionContext.name` and `worldName` parameter to\n\
               `Page.addScriptToEvaluateOnNewDocument`.\n\
               This parameter is mutually exclusive with `executionContextId`."]
      }
      [@@deriving yojson]

      let make ~name ?executionContextId ?executionContextName () =
        { name; executionContextId; executionContextName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.addBinding"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* This method does not remove binding function from global object but
     unsubscribes current runtime agent from Runtime.bindingCalled notifications. *)
  module RemoveBinding = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        name : string; [@key "name"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~name () = { name }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.removeBinding"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end

  (* This method tries to lookup and populate exception details for a
     JavaScript Error object.
     Note that the stackTrace portion of the resulting exceptionDetails will
     only be populated if the Runtime domain was enabled at the time when the
     Error was thrown. *)
  module GetExceptionDetails = struct
    module Response : sig
      type result = {
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        errorObjectId : Types.Runtime.RemoteObjectId.t;
            [@key "errorObjectId"]
            [@ocaml.doc
              "The error object for which to resolve the exception details."]
      }
      [@@deriving yojson]

      let make ~errorObjectId () = { errorObjectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.getExceptionDetails"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end

module Schema = struct
  (* Returns supported domains. *)
  module GetDomains = struct
    module Response : sig
      type result = {
        domains : Types.Schema.Domain.t list;
            [@key "domains"] [@ocaml.doc "List of supported domains."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        domains : Types.Schema.Domain.t list;
            [@key "domains"] [@ocaml.doc "List of supported domains."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Schema.getDomains"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
end
