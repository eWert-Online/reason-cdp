open Ppx_yojson_conv_lib.Yojson_conv.Primitives

module Accessibility = struct
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Accessibility.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables the accessibility domain. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Accessibility.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
This turns on accessibility for the page, which can impact performance until accessibility is disabled. |desc}]

  module GetPartialAXTree = struct
    module Response : sig
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"]
            [@ocaml.doc
              "The `Accessibility.AXNode` for this DOM node, if it exists, \
               plus its ancestors, siblings and\n\
               children, if requested."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"]
            [@ocaml.doc
              "The `Accessibility.AXNode` for this DOM node, if it exists, \
               plus its ancestors, siblings and\n\
               children, if requested."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Identifier of the node to get the partial accessibility tree \
               for."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Identifier of the backend node to get the partial accessibility \
               tree for."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc
              "JavaScript object id of the node wrapper to get the partial \
               accessibility tree for."]
        fetchRelatives : bool option;
            [@key "fetchRelatives"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to fetch this node's ancestors, siblings and children. \
               Defaults to true."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId ?fetchRelatives () =
        { nodeId; backendNodeId; objectId; fetchRelatives }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Accessibility.getPartialAXTree"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists. |desc}]

  module GetFullAXTree = struct
    module Response : sig
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        depth : Types.number option;
            [@key "depth"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum depth at which descendants of the root node should \
               be retrieved.\n\
               If omitted, the full tree is returned."]
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc
              "The frame for whose document the AX tree should be retrieved.\n\
               If omitted, the root frame is used."]
      }
      [@@deriving yojson]

      let make ?depth ?frameId () = { depth; frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Accessibility.getFullAXTree"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Fetches the entire accessibility tree for the root Document |desc}]

  module GetRootAXNode = struct
    module Response : sig
      type result = {
        node : Types.Accessibility.AXNode.t;
            [@key "node"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        node : Types.Accessibility.AXNode.t;
            [@key "node"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc
              "The frame in whose document the node resides.\n\
               If omitted, the root frame is used."]
      }
      [@@deriving yojson]

      let make ?frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Accessibility.getRootAXNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Fetches the root node.
Requires `enable()` to have been called previously. |desc}]

  module GetAXNodeAndAncestors = struct
    module Response : sig
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node to get."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node to get."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper to get."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId () =
        { nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Accessibility.getAXNodeAndAncestors";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Fetches a node and all ancestors up to and including the root.
Requires `enable()` to have been called previously. |desc}]

  module GetChildAXNodes = struct
    module Response : sig
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        id : Types.Accessibility.AXNodeId.t;
            [@key "id"] [@ocaml.doc "No description provided"]
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc
              "The frame in whose document the node resides.\n\
               If omitted, the root frame is used."]
      }
      [@@deriving yojson]

      let make ~id ?frameId () = { id; frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Accessibility.getChildAXNodes"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Fetches a particular accessibility node by AXNodeId.
Requires `enable()` to have been called previously. |desc}]

  module QueryAXTree = struct
    module Response : sig
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"]
            [@ocaml.doc
              "A list of `Accessibility.AXNode` matching the specified \
               attributes,\n\
               including nodes that are ignored for accessibility."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodes : Types.Accessibility.AXNode.t list;
            [@key "nodes"]
            [@ocaml.doc
              "A list of `Accessibility.AXNode` matching the specified \
               attributes,\n\
               including nodes that are ignored for accessibility."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node for the root to query."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node for the root to query."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc
              "JavaScript object id of the node wrapper for the root to query."]
        accessibleName : string option;
            [@key "accessibleName"]
            [@yojson.option]
            [@ocaml.doc "Find nodes with this computed name."]
        role : string option;
            [@key "role"]
            [@yojson.option]
            [@ocaml.doc "Find nodes with this computed role."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId ?accessibleName ?role () =
        { nodeId; backendNodeId; objectId; accessibleName; role }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Accessibility.queryAXTree"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Query a DOM node's accessibility subtree for accessible name and role.
This command computes the name and role for all nodes in the subtree, including those that are
ignored for accessibility, and returns those that match the specified name and role. If no DOM
node is specified, or the DOM node does not exist, the command returns an error. If neither
`accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree. |desc}]
end

module Animation = struct
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Animation.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables animation domain notifications. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Animation.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables animation domain notifications. |desc}]

  module GetCurrentTime = struct
    module Response : sig
      type result = {
        currentTime : Types.number;
            [@key "currentTime"] [@ocaml.doc "Current time of the page."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        currentTime : Types.number;
            [@key "currentTime"] [@ocaml.doc "Current time of the page."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = { id : string [@key "id"] [@ocaml.doc "Id of animation."] }
      [@@deriving yojson]

      let make ~id () = { id }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.getCurrentTime"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns the current time of the an animation. |desc}]

  module GetPlaybackRate = struct
    module Response : sig
      type result = {
        playbackRate : Types.number;
            [@key "playbackRate"]
            [@ocaml.doc "Playback rate for animations on page."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        playbackRate : Types.number;
            [@key "playbackRate"]
            [@ocaml.doc "Playback rate for animations on page."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Animation.getPlaybackRate"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Gets the playback rate of the document timeline. |desc}]

  module ReleaseAnimations = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        animations : string list;
            [@key "animations"] [@ocaml.doc "List of animation ids to seek."]
      }
      [@@deriving yojson]

      let make ~animations () = { animations }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.releaseAnimations"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Releases a set of animations to no longer be manipulated. |desc}]

  module ResolveAnimation = struct
    module Response : sig
      type result = {
        remoteObject : Types.Runtime.RemoteObject.t;
            [@key "remoteObject"] [@ocaml.doc "Corresponding remote object."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        remoteObject : Types.Runtime.RemoteObject.t;
            [@key "remoteObject"] [@ocaml.doc "Corresponding remote object."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        animationId : string; [@key "animationId"] [@ocaml.doc "Animation id."]
      }
      [@@deriving yojson]

      let make ~animationId () = { animationId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.resolveAnimation"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Gets the remote object of the Animation. |desc}]

  module SeekAnimations = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        animations : string list;
            [@key "animations"] [@ocaml.doc "List of animation ids to seek."]
        currentTime : Types.number;
            [@key "currentTime"]
            [@ocaml.doc "Set the current time of each animation."]
      }
      [@@deriving yojson]

      let make ~animations ~currentTime () = { animations; currentTime }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.seekAnimations"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Seek a set of animations to a particular time within each animation. |desc}]

  module SetPaused = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        animations : string list;
            [@key "animations"]
            [@ocaml.doc "Animations to set the pause state of."]
        paused : bool; [@key "paused"] [@ocaml.doc "Paused state to set to."]
      }
      [@@deriving yojson]

      let make ~animations ~paused () = { animations; paused }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.setPaused"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets the paused state of a set of animations. |desc}]

  module SetPlaybackRate = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        playbackRate : Types.number;
            [@key "playbackRate"]
            [@ocaml.doc "Playback rate for animations on page"]
      }
      [@@deriving yojson]

      let make ~playbackRate () = { playbackRate }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.setPlaybackRate"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets the playback rate of the document timeline. |desc}]

  module SetTiming = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        animationId : string; [@key "animationId"] [@ocaml.doc "Animation id."]
        duration : Types.number;
            [@key "duration"] [@ocaml.doc "Duration of the animation."]
        delay : Types.number;
            [@key "delay"] [@ocaml.doc "Delay of the animation."]
      }
      [@@deriving yojson]

      let make ~animationId ~duration ~delay () =
        { animationId; duration; delay }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Animation.setTiming"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets the timing of an animation node. |desc}]
end

module Audits = struct
  module GetEncodedResponse = struct
    module Response : sig
      type result = {
        body : string option;
            [@key "body"]
            [@yojson.option]
            [@ocaml.doc
              "The encoded body as a base64 string. Omitted if sizeOnly is \
               true. (Encoded as a base64 string when passed over JSON)"]
        originalSize : Types.number;
            [@key "originalSize"] [@ocaml.doc "Size before re-encoding."]
        encodedSize : Types.number;
            [@key "encodedSize"] [@ocaml.doc "Size after re-encoding."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        body : string option;
            [@key "body"]
            [@yojson.option]
            [@ocaml.doc
              "The encoded body as a base64 string. Omitted if sizeOnly is \
               true. (Encoded as a base64 string when passed over JSON)"]
        originalSize : Types.number;
            [@key "originalSize"] [@ocaml.doc "Size before re-encoding."]
        encodedSize : Types.number;
            [@key "encodedSize"] [@ocaml.doc "Size after re-encoding."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type getencodedresponse_encoding = [ `webp | `jpeg | `png ]

      let getencodedresponse_encoding_of_yojson = function
        | `String "webp" -> `webp
        | `String "jpeg" -> `jpeg
        | `String "png" -> `png
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_getencodedresponse_encoding = function
        | `webp -> `String "webp"
        | `jpeg -> `String "jpeg"
        | `png -> `String "png"

      type t = {
        requestId : Types.Network.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "Identifier of the network request to get content for."]
        encoding : getencodedresponse_encoding;
            [@key "encoding"] [@ocaml.doc "The encoding to use."]
        quality : Types.number option;
            [@key "quality"]
            [@yojson.option]
            [@ocaml.doc "The quality of the encoding (0-1). (defaults to 1)"]
        sizeOnly : bool option;
            [@key "sizeOnly"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to only return the size information (defaults to false)."]
      }
      [@@deriving yojson]

      let make ~requestId ~encoding ?quality ?sizeOnly () =
        { requestId; encoding; quality; sizeOnly }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Audits.getEncodedResponse"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the response body and size if it were re-encoded with the specified settings. Only
applies to images. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Audits.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Disables issues domain, prevents further issues from being reported to the client. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Audits.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables issues domain, sends the issues collected so far to the client by means of the
`issueAdded` event. |desc}]

  module CheckContrast = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        reportAAA : bool option;
            [@key "reportAAA"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to report WCAG AAA level issues. Default is false."]
      }
      [@@deriving yojson]

      let make ?reportAAA () = { reportAAA }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Audits.checkContrast"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Runs the contrast check for the target page. Found issues are reported
using Audits.issueAdded event. |desc}]

  module CheckFormsIssues = struct
    module Response : sig
      type result = {
        formIssues : Types.Audits.GenericIssueDetails.t list;
            [@key "formIssues"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        formIssues : Types.Audits.GenericIssueDetails.t list;
            [@key "formIssues"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Audits.checkFormsIssues"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Runs the form issues check for the target page. Found issues are reported
using Audits.issueAdded event. |desc}]
end

module Autofill = struct
  module Trigger = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        fieldId : Types.DOM.BackendNodeId.t;
            [@key "fieldId"]
            [@ocaml.doc
              "Identifies a field that serves as an anchor for autofill."]
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc "Identifies the frame that field belongs to."]
        card : Types.Autofill.CreditCard.t option;
            [@key "card"]
            [@yojson.option]
            [@ocaml.doc
              "Credit card information to fill out the form. Credit card data \
               is not saved.  Mutually exclusive with `address`."]
        address : Types.Autofill.Address.t option;
            [@key "address"]
            [@yojson.option]
            [@ocaml.doc
              "Address to fill out the form. Address data is not saved. \
               Mutually exclusive with `card`."]
      }
      [@@deriving yojson]

      let make ~fieldId ?frameId ?card ?address () =
        { fieldId; frameId; card; address }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Autofill.trigger"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Trigger autofill on a form identified by the fieldId.
If the field and related form cannot be autofilled, returns an error. |desc}]

  module SetAddresses = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        addresses : Types.Autofill.Address.t list;
            [@key "addresses"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~addresses () = { addresses }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Autofill.setAddresses"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Set addresses so that developers can verify their forms implementation. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Autofill.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables autofill domain notifications. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Autofill.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables autofill domain notifications. |desc}]
end

module BackgroundService = struct
  module StartObserving = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        service : Types.BackgroundService.ServiceName.t;
            [@key "service"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~service () = { service }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "BackgroundService.startObserving"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables event updates for the service. |desc}]

  module StopObserving = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        service : Types.BackgroundService.ServiceName.t;
            [@key "service"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~service () = { service }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "BackgroundService.stopObserving"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables event updates for the service. |desc}]

  module SetRecording = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        shouldRecord : bool;
            [@key "shouldRecord"] [@ocaml.doc "No description provided"]
        service : Types.BackgroundService.ServiceName.t;
            [@key "service"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~shouldRecord ~service () = { shouldRecord; service }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "BackgroundService.setRecording"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Set the recording state for the service. |desc}]

  module ClearEvents = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        service : Types.BackgroundService.ServiceName.t;
            [@key "service"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~service () = { service }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "BackgroundService.clearEvents"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears all stored data for the service. |desc}]
end

module BluetoothEmulation = struct
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        state : Types.BluetoothEmulation.CentralState.t;
            [@key "state"] [@ocaml.doc "State of the simulated central."]
        leSupported : bool;
            [@key "leSupported"]
            [@ocaml.doc "If the simulated central supports low-energy."]
      }
      [@@deriving yojson]

      let make ~state ~leSupported () = { state; leSupported }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "BluetoothEmulation.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enable the BluetoothEmulation domain. |desc}]

  module SetSimulatedCentralState = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        state : Types.BluetoothEmulation.CentralState.t;
            [@key "state"] [@ocaml.doc "State of the simulated central."]
      }
      [@@deriving yojson]

      let make ~state () = { state }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "BluetoothEmulation.setSimulatedCentralState";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Set the state of the simulated central. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "BluetoothEmulation.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disable the BluetoothEmulation domain. |desc}]

  module SimulatePreconnectedPeripheral = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        address : string;
            [@key "address"] [@ocaml.doc "No description provided"]
        name : string; [@key "name"] [@ocaml.doc "No description provided"]
        manufacturerData : Types.BluetoothEmulation.ManufacturerData.t list;
            [@key "manufacturerData"] [@ocaml.doc "No description provided"]
        knownServiceUuids : string list;
            [@key "knownServiceUuids"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~address ~name ~manufacturerData ~knownServiceUuids () =
        { address; name; manufacturerData; knownServiceUuids }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "BluetoothEmulation.simulatePreconnectedPeripheral";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Simulates a peripheral with |address|, |name| and |knownServiceUuids|
that has already been connected to the system. |desc}]

  module SimulateAdvertisement = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        entry : Types.BluetoothEmulation.ScanEntry.t;
            [@key "entry"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~entry () = { entry }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "BluetoothEmulation.simulateAdvertisement";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Simulates an advertisement packet described in |entry| being received by
the central. |desc}]

  module SimulateGATTOperationResponse = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        address : string;
            [@key "address"] [@ocaml.doc "No description provided"]
        type_ : Types.BluetoothEmulation.GATTOperationType.t;
            [@key "type"] [@ocaml.doc "No description provided"]
        code : Types.number; [@key "code"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~address ~type_ ~code () = { address; type_; code }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "BluetoothEmulation.simulateGATTOperationResponse";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Simulates the response code from the peripheral with |address| for a
GATT operation of |type|. The |code| value follows the HCI Error Codes from
Bluetooth Core Specification Vol 2 Part D 1.3 List Of Error Codes. |desc}]

  module SimulateCharacteristicOperationResponse = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        characteristicId : string;
            [@key "characteristicId"] [@ocaml.doc "No description provided"]
        type_ : Types.BluetoothEmulation.CharacteristicOperationType.t;
            [@key "type"] [@ocaml.doc "No description provided"]
        code : Types.number;
            [@key "code"] [@ocaml.doc "No description provided"]
        data : string option;
            [@key "data"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~characteristicId ~type_ ~code ?data () =
        { characteristicId; type_; code; data }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "BluetoothEmulation.simulateCharacteristicOperationResponse";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Simulates the response from the characteristic with |characteristicId| for a
characteristic operation of |type|. The |code| value follows the Error
Codes from Bluetooth Core Specification Vol 3 Part F 3.4.1.1 Error Response.
The |data| is expected to exist when simulating a successful read operation
response. |desc}]

  module SimulateDescriptorOperationResponse = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        descriptorId : string;
            [@key "descriptorId"] [@ocaml.doc "No description provided"]
        type_ : Types.BluetoothEmulation.DescriptorOperationType.t;
            [@key "type"] [@ocaml.doc "No description provided"]
        code : Types.number;
            [@key "code"] [@ocaml.doc "No description provided"]
        data : string option;
            [@key "data"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~descriptorId ~type_ ~code ?data () =
        { descriptorId; type_; code; data }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "BluetoothEmulation.simulateDescriptorOperationResponse";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Simulates the response from the descriptor with |descriptorId| for a
descriptor operation of |type|. The |code| value follows the Error
Codes from Bluetooth Core Specification Vol 3 Part F 3.4.1.1 Error Response.
The |data| is expected to exist when simulating a successful read operation
response. |desc}]

  module AddService = struct
    module Response : sig
      type result = {
        serviceId : string;
            [@key "serviceId"]
            [@ocaml.doc "An identifier that uniquely represents this service."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        serviceId : string;
            [@key "serviceId"]
            [@ocaml.doc "An identifier that uniquely represents this service."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        address : string;
            [@key "address"] [@ocaml.doc "No description provided"]
        serviceUuid : string;
            [@key "serviceUuid"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~address ~serviceUuid () = { address; serviceUuid }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "BluetoothEmulation.addService"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Adds a service with |serviceUuid| to the peripheral with |address|. |desc}]

  module RemoveService = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        serviceId : string;
            [@key "serviceId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~serviceId () = { serviceId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "BluetoothEmulation.removeService"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Removes the service respresented by |serviceId| from the simulated central. |desc}]

  module AddCharacteristic = struct
    module Response : sig
      type result = {
        characteristicId : string;
            [@key "characteristicId"]
            [@ocaml.doc
              "An identifier that uniquely represents this characteristic."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        characteristicId : string;
            [@key "characteristicId"]
            [@ocaml.doc
              "An identifier that uniquely represents this characteristic."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        serviceId : string;
            [@key "serviceId"] [@ocaml.doc "No description provided"]
        characteristicUuid : string;
            [@key "characteristicUuid"] [@ocaml.doc "No description provided"]
        properties : Types.BluetoothEmulation.CharacteristicProperties.t;
            [@key "properties"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~serviceId ~characteristicUuid ~properties () =
        { serviceId; characteristicUuid; properties }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "BluetoothEmulation.addCharacteristic";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Adds a characteristic with |characteristicUuid| and |properties| to the
service represented by |serviceId|. |desc}]

  module RemoveCharacteristic = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        characteristicId : string;
            [@key "characteristicId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~characteristicId () = { characteristicId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "BluetoothEmulation.removeCharacteristic";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Removes the characteristic respresented by |characteristicId| from the
simulated central. |desc}]

  module AddDescriptor = struct
    module Response : sig
      type result = {
        descriptorId : string;
            [@key "descriptorId"]
            [@ocaml.doc
              "An identifier that uniquely represents this descriptor."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        descriptorId : string;
            [@key "descriptorId"]
            [@ocaml.doc
              "An identifier that uniquely represents this descriptor."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        characteristicId : string;
            [@key "characteristicId"] [@ocaml.doc "No description provided"]
        descriptorUuid : string;
            [@key "descriptorUuid"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~characteristicId ~descriptorUuid () =
        { characteristicId; descriptorUuid }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "BluetoothEmulation.addDescriptor"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Adds a descriptor with |descriptorUuid| to the characteristic respresented
by |characteristicId|. |desc}]

  module RemoveDescriptor = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        descriptorId : string;
            [@key "descriptorId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~descriptorId () = { descriptorId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "BluetoothEmulation.removeDescriptor";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Removes the descriptor with |descriptorId| from the simulated central. |desc}]

  module SimulateGATTDisconnection = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        address : string; [@key "address"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~address () = { address }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "BluetoothEmulation.simulateGATTDisconnection";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Simulates a GATT disconnection from the peripheral with |address|. |desc}]
end

module Browser = struct
  module SetPermission = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        permission : Types.Browser.PermissionDescriptor.t;
            [@key "permission"]
            [@ocaml.doc "Descriptor of permission to override."]
        setting : Types.Browser.PermissionSetting.t;
            [@key "setting"] [@ocaml.doc "Setting of the permission."]
        origin : string option;
            [@key "origin"]
            [@yojson.option]
            [@ocaml.doc
              "Embedding origin the permission applies to, all origins if not \
               specified."]
        embeddedOrigin : string option;
            [@key "embeddedOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "Embedded origin the permission applies to. It is ignored unless \
               the embedding origin is\n\
               present and valid. If the embedding origin is provided but the \
               embedded origin isn't, the\n\
               embedding origin is used as the embedded origin."]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Context to override. When omitted, default browser context is \
               used."]
      }
      [@@deriving yojson]

      let make ~permission ~setting ?origin ?embeddedOrigin ?browserContextId ()
          =
        { permission; setting; origin; embeddedOrigin; browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.setPermission"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Set permission settings for given embedding and embedded origins. |desc}]

  module GrantPermissions = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        permissions : Types.Browser.PermissionType.t list;
            [@key "permissions"] [@ocaml.doc "No description provided"]
        origin : string option;
            [@key "origin"]
            [@yojson.option]
            [@ocaml.doc
              "Origin the permission applies to, all origins if not specified."]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "BrowserContext to override permissions. When omitted, default \
               browser context is used."]
      }
      [@@deriving yojson]

      let make ~permissions ?origin ?browserContextId () =
        { permissions; origin; browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.grantPermissions"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Grant specific permissions to the given origin and reject all others. Deprecated. Use
setPermission instead. |desc}]

  module ResetPermissions = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "BrowserContext to reset permissions. When omitted, default \
               browser context is used."]
      }
      [@@deriving yojson]

      let make ?browserContextId () = { browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.resetPermissions"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Reset all permission management for all origins. |desc}]

  module SetDownloadBehavior = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setdownloadbehavior_behavior =
        [ `deny | `allow | `allowAndName | `default ]

      let setdownloadbehavior_behavior_of_yojson = function
        | `String "deny" -> `deny
        | `String "allow" -> `allow
        | `String "allowAndName" -> `allowAndName
        | `String "default" -> `default
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setdownloadbehavior_behavior = function
        | `deny -> `String "deny"
        | `allow -> `String "allow"
        | `allowAndName -> `String "allowAndName"
        | `default -> `String "default"

      type t = {
        behavior : setdownloadbehavior_behavior;
            [@key "behavior"]
            [@ocaml.doc
              "Whether to allow all or deny all download requests, or use \
               default Chrome behavior if\n\
               available (otherwise deny). |allowAndName| allows download and \
               names files according to\n\
               their download guids."]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "BrowserContext to set download behavior. When omitted, default \
               browser context is used."]
        downloadPath : string option;
            [@key "downloadPath"]
            [@yojson.option]
            [@ocaml.doc
              "The default path to save downloaded files to. This is required \
               if behavior is set to 'allow'\n\
               or 'allowAndName'."]
        eventsEnabled : bool option;
            [@key "eventsEnabled"]
            [@yojson.option]
            [@ocaml.doc "Whether to emit download events (defaults to false)."]
      }
      [@@deriving yojson]

      let make ~behavior ?browserContextId ?downloadPath ?eventsEnabled () =
        { behavior; browserContextId; downloadPath; eventsEnabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.setDownloadBehavior"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Set the behavior when downloading a file. |desc}]

  module CancelDownload = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        guid : string;
            [@key "guid"]
            [@ocaml.doc "Global unique identifier of the download."]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "BrowserContext to perform the action in. When omitted, default \
               browser context is used."]
      }
      [@@deriving yojson]

      let make ~guid ?browserContextId () = { guid; browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.cancelDownload"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Cancel a download if in progress |desc}]

  module Close = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Browser.close"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Close browser gracefully. |desc}]

  module Crash = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Browser.crash"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Crashes browser on the main thread. |desc}]

  module CrashGpuProcess = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Browser.crashGpuProcess"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Crashes GPU process. |desc}]

  module GetVersion = struct
    module Response : sig
      type result = {
        protocolVersion : string;
            [@key "protocolVersion"] [@ocaml.doc "Protocol version."]
        product : string; [@key "product"] [@ocaml.doc "Product name."]
        revision : string; [@key "revision"] [@ocaml.doc "Product revision."]
        userAgent : string; [@key "userAgent"] [@ocaml.doc "User-Agent."]
        jsVersion : string; [@key "jsVersion"] [@ocaml.doc "V8 version."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        protocolVersion : string;
            [@key "protocolVersion"] [@ocaml.doc "Protocol version."]
        product : string; [@key "product"] [@ocaml.doc "Product name."]
        revision : string; [@key "revision"] [@ocaml.doc "Product revision."]
        userAgent : string; [@key "userAgent"] [@ocaml.doc "User-Agent."]
        jsVersion : string; [@key "jsVersion"] [@ocaml.doc "V8 version."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Browser.getVersion"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns version information. |desc}]

  module GetBrowserCommandLine = struct
    module Response : sig
      type result = {
        arguments : string list;
            [@key "arguments"] [@ocaml.doc "Commandline parameters"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        arguments : string list;
            [@key "arguments"] [@ocaml.doc "Commandline parameters"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Browser.getBrowserCommandLine"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the command line switches for the browser process if, and only if
--enable-automation is on the commandline. |desc}]

  module GetHistograms = struct
    module Response : sig
      type result = {
        histograms : Types.Browser.Histogram.t list;
            [@key "histograms"] [@ocaml.doc "Histograms."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        histograms : Types.Browser.Histogram.t list;
            [@key "histograms"] [@ocaml.doc "Histograms."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        query : string option;
            [@key "query"]
            [@yojson.option]
            [@ocaml.doc
              "Requested substring in name. Only histograms which have query \
               as a\n\
               substring in their name are extracted. An empty or absent query \
               returns\n\
               all histograms."]
        delta : bool option;
            [@key "delta"]
            [@yojson.option]
            [@ocaml.doc "If true, retrieve delta since last delta call."]
      }
      [@@deriving yojson]

      let make ?query ?delta () = { query; delta }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.getHistograms"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Get Chrome histograms. |desc}]

  module GetHistogram = struct
    module Response : sig
      type result = {
        histogram : Types.Browser.Histogram.t;
            [@key "histogram"] [@ocaml.doc "Histogram."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        histogram : Types.Browser.Histogram.t;
            [@key "histogram"] [@ocaml.doc "Histogram."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        name : string; [@key "name"] [@ocaml.doc "Requested histogram name."]
        delta : bool option;
            [@key "delta"]
            [@yojson.option]
            [@ocaml.doc "If true, retrieve delta since last delta call."]
      }
      [@@deriving yojson]

      let make ~name ?delta () = { name; delta }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.getHistogram"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Get a Chrome histogram by name. |desc}]

  module GetWindowBounds = struct
    module Response : sig
      type result = {
        bounds : Types.Browser.Bounds.t;
            [@key "bounds"]
            [@ocaml.doc
              "Bounds information of the window. When window state is \
               'minimized', the restored window\n\
               position and size are returned."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        bounds : Types.Browser.Bounds.t;
            [@key "bounds"]
            [@ocaml.doc
              "Bounds information of the window. When window state is \
               'minimized', the restored window\n\
               position and size are returned."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        windowId : Types.Browser.WindowID.t;
            [@key "windowId"] [@ocaml.doc "Browser window id."]
      }
      [@@deriving yojson]

      let make ~windowId () = { windowId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.getWindowBounds"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Get position and size of the browser window. |desc}]

  module GetWindowForTarget = struct
    module Response : sig
      type result = {
        windowId : Types.Browser.WindowID.t;
            [@key "windowId"] [@ocaml.doc "Browser window id."]
        bounds : Types.Browser.Bounds.t;
            [@key "bounds"]
            [@ocaml.doc
              "Bounds information of the window. When window state is \
               'minimized', the restored window\n\
               position and size are returned."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        windowId : Types.Browser.WindowID.t;
            [@key "windowId"] [@ocaml.doc "Browser window id."]
        bounds : Types.Browser.Bounds.t;
            [@key "bounds"]
            [@ocaml.doc
              "Bounds information of the window. When window state is \
               'minimized', the restored window\n\
               position and size are returned."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t option;
            [@key "targetId"]
            [@yojson.option]
            [@ocaml.doc
              "Devtools agent host id. If called as a part of the session, \
               associated targetId is used."]
      }
      [@@deriving yojson]

      let make ?targetId () = { targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.getWindowForTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Get the browser window that contains the devtools target. |desc}]

  module SetWindowBounds = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        windowId : Types.Browser.WindowID.t;
            [@key "windowId"] [@ocaml.doc "Browser window id."]
        bounds : Types.Browser.Bounds.t;
            [@key "bounds"]
            [@ocaml.doc
              "New window bounds. The 'minimized', 'maximized' and \
               'fullscreen' states cannot be combined\n\
               with 'left', 'top', 'width' or 'height'. Leaves unspecified \
               fields unchanged."]
      }
      [@@deriving yojson]

      let make ~windowId ~bounds () = { windowId; bounds }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.setWindowBounds"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Set position and/or size of the browser window. |desc}]

  module SetContentsSize = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        windowId : Types.Browser.WindowID.t;
            [@key "windowId"] [@ocaml.doc "Browser window id."]
        width : Types.number option;
            [@key "width"]
            [@yojson.option]
            [@ocaml.doc
              "The window contents width in DIP. Assumes current width if \
               omitted.\n\
               Must be specified if 'height' is omitted."]
        height : Types.number option;
            [@key "height"]
            [@yojson.option]
            [@ocaml.doc
              "The window contents height in DIP. Assumes current height if \
               omitted.\n\
               Must be specified if 'width' is omitted."]
      }
      [@@deriving yojson]

      let make ~windowId ?width ?height () = { windowId; width; height }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.setContentsSize"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Set size of the browser contents resizing browser window as necessary. |desc}]

  module SetDockTile = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        badgeLabel : string option;
            [@key "badgeLabel"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        image : string option;
            [@key "image"]
            [@yojson.option]
            [@ocaml.doc
              "Png encoded image. (Encoded as a base64 string when passed over \
               JSON)"]
      }
      [@@deriving yojson]

      let make ?badgeLabel ?image () = { badgeLabel; image }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.setDockTile"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Set dock tile details, platform-specific. |desc}]

  module ExecuteBrowserCommand = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        commandId : Types.Browser.BrowserCommandId.t;
            [@key "commandId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~commandId () = { commandId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Browser.executeBrowserCommand"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Invoke custom browser commands used by telemetry. |desc}]

  module AddPrivacySandboxEnrollmentOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        url : string; [@key "url"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~url () = { url }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Browser.addPrivacySandboxEnrollmentOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Allows a site to use privacy sandbox features that require enrollment
without the site actually being enrolled. Only supported on page targets. |desc}]

  module AddPrivacySandboxCoordinatorKeyConfig = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        api : Types.Browser.PrivacySandboxAPI.t;
            [@key "api"] [@ocaml.doc "No description provided"]
        coordinatorOrigin : string;
            [@key "coordinatorOrigin"] [@ocaml.doc "No description provided"]
        keyConfig : string;
            [@key "keyConfig"] [@ocaml.doc "No description provided"]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "BrowserContext to perform the action in. When omitted, default \
               browser\n\
               context is used."]
      }
      [@@deriving yojson]

      let make ~api ~coordinatorOrigin ~keyConfig ?browserContextId () =
        { api; coordinatorOrigin; keyConfig; browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Browser.addPrivacySandboxCoordinatorKeyConfig";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Configures encryption keys used with a given privacy sandbox API to talk
to a trusted coordinator.  Since this is intended for test automation only,
coordinatorOrigin must be a .test domain. No existing coordinator
configuration for the origin may exist. |desc}]
end

module CSS = struct
  module AddRule = struct
    module Response : sig
      type result = {
        rule : Types.CSS.CSSRule.t;
            [@key "rule"] [@ocaml.doc "The newly created rule."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        rule : Types.CSS.CSSRule.t;
            [@key "rule"] [@ocaml.doc "The newly created rule."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"]
            [@ocaml.doc
              "The css style sheet identifier where a new rule should be \
               inserted."]
        ruleText : string;
            [@key "ruleText"] [@ocaml.doc "The text of a new rule."]
        location : Types.CSS.SourceRange.t;
            [@key "location"]
            [@ocaml.doc
              "Text position of a new rule in the target style sheet."]
        nodeForPropertySyntaxValidation : Types.DOM.NodeId.t option;
            [@key "nodeForPropertySyntaxValidation"]
            [@yojson.option]
            [@ocaml.doc
              "NodeId for the DOM node in whose context custom property \
               declarations for registered properties should be\n\
               validated. If omitted, declarations in the new rule text can \
               only be validated statically, which may produce\n\
               incorrect results if the declaration contains a var() for \
               example."]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~ruleText ~location
          ?nodeForPropertySyntaxValidation () =
        { styleSheetId; ruleText; location; nodeForPropertySyntaxValidation }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.addRule"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
position specified by `location`. |desc}]

  module CollectClassNames = struct
    module Response : sig
      type result = {
        classNames : string list;
            [@key "classNames"] [@ocaml.doc "Class name list."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        classNames : string list;
            [@key "classNames"] [@ocaml.doc "Class name list."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId () = { styleSheetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.collectClassNames"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns all class names from specified stylesheet. |desc}]

  module CreateStyleSheet = struct
    module Response : sig
      type result = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"]
            [@ocaml.doc
              "Identifier of the created \"via-inspector\" stylesheet."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"]
            [@ocaml.doc
              "Identifier of the created \"via-inspector\" stylesheet."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"]
            [@ocaml.doc
              "Identifier of the frame where \"via-inspector\" stylesheet \
               should be created."]
        force : bool option;
            [@key "force"]
            [@yojson.option]
            [@ocaml.doc
              "If true, creates a new stylesheet for every call. If false,\n\
               returns a stylesheet previously created by a call with \
               force=false\n\
               for the frame's document if it exists or creates a new stylesheet\n\
               (default: false)."]
      }
      [@@deriving yojson]

      let make ~frameId ?force () = { frameId; force }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.createStyleSheet"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Creates a new special "via-inspector" stylesheet in the frame with given `frameId`. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables the CSS agent for the given page. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
enabled until the result of this command is received. |desc}]

  module ForcePseudoState = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "The element id for which to force the pseudo state."]
        forcedPseudoClasses : string list;
            [@key "forcedPseudoClasses"]
            [@ocaml.doc
              "Element pseudo classes to force when computing the element's \
               style."]
      }
      [@@deriving yojson]

      let make ~nodeId ~forcedPseudoClasses () = { nodeId; forcedPseudoClasses }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.forcePseudoState"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Ensures that the given node will have specified pseudo-classes whenever its style is computed by
the browser. |desc}]

  module ForceStartingStyle = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc
              "The element id for which to force the starting-style state."]
        forced : bool;
            [@key "forced"]
            [@ocaml.doc "Boolean indicating if this is on or off."]
      }
      [@@deriving yojson]

      let make ~nodeId ~forced () = { nodeId; forced }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.forceStartingStyle"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Ensures that the given node is in its starting-style state. |desc}]

  module GetBackgroundColors = struct
    module Response : sig
      type result = {
        backgroundColors : string list option;
            [@key "backgroundColors"]
            [@yojson.option]
            [@ocaml.doc
              "The range of background colors behind this element, if it \
               contains any visible text. If no\n\
               visible text is present, this will be undefined. In the case of \
               a flat background color,\n\
               this will consist of simply that color. In the case of a \
               gradient, this will consist of each\n\
               of the color stops. For anything more complicated, this will be \
               an empty array. Images will\n\
               be ignored (as if the image had failed to load)."]
        computedFontSize : string option;
            [@key "computedFontSize"]
            [@yojson.option]
            [@ocaml.doc
              "The computed font size for this node, as a CSS computed value \
               string (e.g. '12px')."]
        computedFontWeight : string option;
            [@key "computedFontWeight"]
            [@yojson.option]
            [@ocaml.doc
              "The computed font weight for this node, as a CSS computed value \
               string (e.g. 'normal' or\n\
               '100')."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        backgroundColors : string list option;
            [@key "backgroundColors"]
            [@yojson.option]
            [@ocaml.doc
              "The range of background colors behind this element, if it \
               contains any visible text. If no\n\
               visible text is present, this will be undefined. In the case of \
               a flat background color,\n\
               this will consist of simply that color. In the case of a \
               gradient, this will consist of each\n\
               of the color stops. For anything more complicated, this will be \
               an empty array. Images will\n\
               be ignored (as if the image had failed to load)."]
        computedFontSize : string option;
            [@key "computedFontSize"]
            [@yojson.option]
            [@ocaml.doc
              "The computed font size for this node, as a CSS computed value \
               string (e.g. '12px')."]
        computedFontWeight : string option;
            [@key "computedFontWeight"]
            [@yojson.option]
            [@ocaml.doc
              "The computed font weight for this node, as a CSS computed value \
               string (e.g. 'normal' or\n\
               '100')."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the node to get background colors for."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getBackgroundColors"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module GetComputedStyleForNode = struct
    module Response : sig
      type result = {
        computedStyle : Types.CSS.CSSComputedStyleProperty.t list;
            [@key "computedStyle"]
            [@ocaml.doc "Computed style for the specified DOM node."]
        extraFields : Types.CSS.ComputedStyleExtraFields.t;
            [@key "extraFields"]
            [@ocaml.doc
              "A list of non-standard \"extra fields\" which blink stores \
               alongside each\n\
               computed style."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        computedStyle : Types.CSS.CSSComputedStyleProperty.t list;
            [@key "computedStyle"]
            [@ocaml.doc "Computed style for the specified DOM node."]
        extraFields : Types.CSS.ComputedStyleExtraFields.t;
            [@key "extraFields"]
            [@ocaml.doc
              "A list of non-standard \"extra fields\" which blink stores \
               alongside each\n\
               computed style."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getComputedStyleForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the computed style for a DOM node identified by `nodeId`. |desc}]

  module ResolveValues = struct
    module Response : sig
      type result = {
        results : string list;
            [@key "results"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        results : string list;
            [@key "results"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        values : string list;
            [@key "values"]
            [@ocaml.doc
              "Cascade-dependent keywords (revert/revert-layer) do not work."]
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc
              "Id of the node in whose context the expression is evaluated"]
        propertyName : string option;
            [@key "propertyName"]
            [@yojson.option]
            [@ocaml.doc
              "Only longhands and custom property names are accepted."]
        pseudoType : Types.DOM.PseudoType.t option;
            [@key "pseudoType"]
            [@yojson.option]
            [@ocaml.doc
              "Pseudo element type, only works for pseudo elements that generate\n\
               elements in the tree, such as ::before and ::after."]
        pseudoIdentifier : string option;
            [@key "pseudoIdentifier"]
            [@yojson.option]
            [@ocaml.doc "Pseudo element custom ident."]
      }
      [@@deriving yojson]

      let make ~values ~nodeId ?propertyName ?pseudoType ?pseudoIdentifier () =
        { values; nodeId; propertyName; pseudoType; pseudoIdentifier }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.resolveValues"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Resolve the specified values in the context of the provided element.
For example, a value of '1em' is evaluated according to the computed
'font-size' of the element and a value 'calc(1px + 2px)' will be
resolved to '3px'.
If the `propertyName` was specified the `values` are resolved as if
they were property's declaration. If a value cannot be parsed according
to the provided property syntax, the value is parsed using combined
syntax as if null `propertyName` was provided. If the value cannot be
resolved even then, return the provided value without any changes.
Note: this function currently does not resolve CSS random() function,
it returns unmodified random() function parts.` |desc}]

  module GetLonghandProperties = struct
    module Response : sig
      type result = {
        longhandProperties : Types.CSS.CSSProperty.t list;
            [@key "longhandProperties"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        longhandProperties : Types.CSS.CSSProperty.t list;
            [@key "longhandProperties"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        shorthandName : string;
            [@key "shorthandName"] [@ocaml.doc "No description provided"]
        value : string; [@key "value"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~shorthandName ~value () = { shorthandName; value }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getLonghandProperties"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module GetInlineStylesForNode = struct
    module Response : sig
      type result = {
        inlineStyle : Types.CSS.CSSStyle.t option;
            [@key "inlineStyle"]
            [@yojson.option]
            [@ocaml.doc "Inline style for the specified DOM node."]
        attributesStyle : Types.CSS.CSSStyle.t option;
            [@key "attributesStyle"]
            [@yojson.option]
            [@ocaml.doc
              "Attribute-defined element style (e.g. resulting from \"width=20 \
               height=100%\")."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        inlineStyle : Types.CSS.CSSStyle.t option;
            [@key "inlineStyle"]
            [@yojson.option]
            [@ocaml.doc "Inline style for the specified DOM node."]
        attributesStyle : Types.CSS.CSSStyle.t option;
            [@key "attributesStyle"]
            [@yojson.option]
            [@ocaml.doc
              "Attribute-defined element style (e.g. resulting from \"width=20 \
               height=100%\")."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getInlineStylesForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
attributes) for a DOM node identified by `nodeId`. |desc}]

  module GetAnimatedStylesForNode = struct
    module Response : sig
      type result = {
        animationStyles : Types.CSS.CSSAnimationStyle.t list option;
            [@key "animationStyles"]
            [@yojson.option]
            [@ocaml.doc "Styles coming from animations."]
        transitionsStyle : Types.CSS.CSSStyle.t option;
            [@key "transitionsStyle"]
            [@yojson.option]
            [@ocaml.doc "Style coming from transitions."]
        inherited : Types.CSS.InheritedAnimatedStyleEntry.t list option;
            [@key "inherited"]
            [@yojson.option]
            [@ocaml.doc
              "Inherited style entries for animationsStyle and \
               transitionsStyle from\n\
               the inheritance chain of the element."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        animationStyles : Types.CSS.CSSAnimationStyle.t list option;
            [@key "animationStyles"]
            [@yojson.option]
            [@ocaml.doc "Styles coming from animations."]
        transitionsStyle : Types.CSS.CSSStyle.t option;
            [@key "transitionsStyle"]
            [@yojson.option]
            [@ocaml.doc "Style coming from transitions."]
        inherited : Types.CSS.InheritedAnimatedStyleEntry.t list option;
            [@key "inherited"]
            [@yojson.option]
            [@ocaml.doc
              "Inherited style entries for animationsStyle and \
               transitionsStyle from\n\
               the inheritance chain of the element."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getAnimatedStylesForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the styles coming from animations & transitions
including the animation & transition styles coming from inheritance chain. |desc}]

  module GetMatchedStylesForNode = struct
    module Response : sig
      type result = {
        inlineStyle : Types.CSS.CSSStyle.t option;
            [@key "inlineStyle"]
            [@yojson.option]
            [@ocaml.doc "Inline style for the specified DOM node."]
        attributesStyle : Types.CSS.CSSStyle.t option;
            [@key "attributesStyle"]
            [@yojson.option]
            [@ocaml.doc
              "Attribute-defined element style (e.g. resulting from \"width=20 \
               height=100%\")."]
        matchedCSSRules : Types.CSS.RuleMatch.t list option;
            [@key "matchedCSSRules"]
            [@yojson.option]
            [@ocaml.doc
              "CSS rules matching this node, from all applicable stylesheets."]
        pseudoElements : Types.CSS.PseudoElementMatches.t list option;
            [@key "pseudoElements"]
            [@yojson.option]
            [@ocaml.doc "Pseudo style matches for this node."]
        inherited : Types.CSS.InheritedStyleEntry.t list option;
            [@key "inherited"]
            [@yojson.option]
            [@ocaml.doc
              "A chain of inherited styles (from the immediate node parent up \
               to the DOM tree root)."]
        inheritedPseudoElements :
          Types.CSS.InheritedPseudoElementMatches.t list option;
            [@key "inheritedPseudoElements"]
            [@yojson.option]
            [@ocaml.doc
              "A chain of inherited pseudo element styles (from the immediate \
               node parent up to the DOM tree root)."]
        cssKeyframesRules : Types.CSS.CSSKeyframesRule.t list option;
            [@key "cssKeyframesRules"]
            [@yojson.option]
            [@ocaml.doc
              "A list of CSS keyframed animations matching this node."]
        cssPositionTryRules : Types.CSS.CSSPositionTryRule.t list option;
            [@key "cssPositionTryRules"]
            [@yojson.option]
            [@ocaml.doc
              "A list of CSS @position-try rules matching this node, based on \
               the position-try-fallbacks property."]
        activePositionFallbackIndex : Types.number option;
            [@key "activePositionFallbackIndex"]
            [@yojson.option]
            [@ocaml.doc
              "Index of the active fallback in the applied \
               position-try-fallback property,\n\
               will not be set if there is no active position-try fallback."]
        cssPropertyRules : Types.CSS.CSSPropertyRule.t list option;
            [@key "cssPropertyRules"]
            [@yojson.option]
            [@ocaml.doc "A list of CSS at-property rules matching this node."]
        cssPropertyRegistrations :
          Types.CSS.CSSPropertyRegistration.t list option;
            [@key "cssPropertyRegistrations"]
            [@yojson.option]
            [@ocaml.doc
              "A list of CSS property registrations matching this node."]
        cssAtRules : Types.CSS.CSSAtRule.t list option;
            [@key "cssAtRules"]
            [@yojson.option]
            [@ocaml.doc
              "A list of simple @rules matching this node or its \
               pseudo-elements."]
        parentLayoutNodeId : Types.DOM.NodeId.t option;
            [@key "parentLayoutNodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Id of the first parent element that does not have display: \
               contents."]
        cssFunctionRules : Types.CSS.CSSFunctionRule.t list option;
            [@key "cssFunctionRules"]
            [@yojson.option]
            [@ocaml.doc
              "A list of CSS at-function rules referenced by styles of this \
               node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        inlineStyle : Types.CSS.CSSStyle.t option;
            [@key "inlineStyle"]
            [@yojson.option]
            [@ocaml.doc "Inline style for the specified DOM node."]
        attributesStyle : Types.CSS.CSSStyle.t option;
            [@key "attributesStyle"]
            [@yojson.option]
            [@ocaml.doc
              "Attribute-defined element style (e.g. resulting from \"width=20 \
               height=100%\")."]
        matchedCSSRules : Types.CSS.RuleMatch.t list option;
            [@key "matchedCSSRules"]
            [@yojson.option]
            [@ocaml.doc
              "CSS rules matching this node, from all applicable stylesheets."]
        pseudoElements : Types.CSS.PseudoElementMatches.t list option;
            [@key "pseudoElements"]
            [@yojson.option]
            [@ocaml.doc "Pseudo style matches for this node."]
        inherited : Types.CSS.InheritedStyleEntry.t list option;
            [@key "inherited"]
            [@yojson.option]
            [@ocaml.doc
              "A chain of inherited styles (from the immediate node parent up \
               to the DOM tree root)."]
        inheritedPseudoElements :
          Types.CSS.InheritedPseudoElementMatches.t list option;
            [@key "inheritedPseudoElements"]
            [@yojson.option]
            [@ocaml.doc
              "A chain of inherited pseudo element styles (from the immediate \
               node parent up to the DOM tree root)."]
        cssKeyframesRules : Types.CSS.CSSKeyframesRule.t list option;
            [@key "cssKeyframesRules"]
            [@yojson.option]
            [@ocaml.doc
              "A list of CSS keyframed animations matching this node."]
        cssPositionTryRules : Types.CSS.CSSPositionTryRule.t list option;
            [@key "cssPositionTryRules"]
            [@yojson.option]
            [@ocaml.doc
              "A list of CSS @position-try rules matching this node, based on \
               the position-try-fallbacks property."]
        activePositionFallbackIndex : Types.number option;
            [@key "activePositionFallbackIndex"]
            [@yojson.option]
            [@ocaml.doc
              "Index of the active fallback in the applied \
               position-try-fallback property,\n\
               will not be set if there is no active position-try fallback."]
        cssPropertyRules : Types.CSS.CSSPropertyRule.t list option;
            [@key "cssPropertyRules"]
            [@yojson.option]
            [@ocaml.doc "A list of CSS at-property rules matching this node."]
        cssPropertyRegistrations :
          Types.CSS.CSSPropertyRegistration.t list option;
            [@key "cssPropertyRegistrations"]
            [@yojson.option]
            [@ocaml.doc
              "A list of CSS property registrations matching this node."]
        cssAtRules : Types.CSS.CSSAtRule.t list option;
            [@key "cssAtRules"]
            [@yojson.option]
            [@ocaml.doc
              "A list of simple @rules matching this node or its \
               pseudo-elements."]
        parentLayoutNodeId : Types.DOM.NodeId.t option;
            [@key "parentLayoutNodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Id of the first parent element that does not have display: \
               contents."]
        cssFunctionRules : Types.CSS.CSSFunctionRule.t list option;
            [@key "cssFunctionRules"]
            [@yojson.option]
            [@ocaml.doc
              "A list of CSS at-function rules referenced by styles of this \
               node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getMatchedStylesForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns requested styles for a DOM node identified by `nodeId`. |desc}]

  module GetEnvironmentVariables = struct
    module Response : sig
      type result = {
        environmentVariables : Types.assoc;
            [@key "environmentVariables"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        environmentVariables : Types.assoc;
            [@key "environmentVariables"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.getEnvironmentVariables"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the values of the default UA-defined environment variables used in env() |desc}]

  module GetMediaQueries = struct
    module Response : sig
      type result = {
        medias : Types.CSS.CSSMedia.t list;
            [@key "medias"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        medias : Types.CSS.CSSMedia.t list;
            [@key "medias"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.getMediaQueries"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns all media queries parsed by the rendering engine. |desc}]

  module GetPlatformFontsForNode = struct
    module Response : sig
      type result = {
        fonts : Types.CSS.PlatformFontUsage.t list;
            [@key "fonts"]
            [@ocaml.doc "Usage statistics for every employed platform font."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        fonts : Types.CSS.PlatformFontUsage.t list;
            [@key "fonts"]
            [@ocaml.doc "Usage statistics for every employed platform font."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getPlatformFontsForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Requests information about platform fonts which we used to render child TextNodes in the given
node. |desc}]

  module GetStyleSheetText = struct
    module Response : sig
      type result = {
        text : string; [@key "text"] [@ocaml.doc "The stylesheet text."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        text : string; [@key "text"] [@ocaml.doc "The stylesheet text."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId () = { styleSheetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getStyleSheetText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the current textual content for a stylesheet. |desc}]

  module GetLayersForNode = struct
    module Response : sig
      type result = {
        rootLayer : Types.CSS.CSSLayerData.t;
            [@key "rootLayer"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        rootLayer : Types.CSS.CSSLayerData.t;
            [@key "rootLayer"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getLayersForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns all layers parsed by the rendering engine for the tree scope of a node.
Given a DOM element identified by nodeId, getLayersForNode returns the root
layer for the nearest ancestor document or shadow root. The layer root contains
the full layer tree for the tree scope and their ordering. |desc}]

  module GetLocationForSelector = struct
    module Response : sig
      type result = {
        ranges : Types.CSS.SourceRange.t list;
            [@key "ranges"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        ranges : Types.CSS.SourceRange.t list;
            [@key "ranges"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        selectorText : string;
            [@key "selectorText"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~selectorText () = { styleSheetId; selectorText }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.getLocationForSelector"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Given a CSS selector text and a style sheet ID, getLocationForSelector
returns an array of locations of the CSS selector in the style sheet. |desc}]

  module TrackComputedStyleUpdatesForNode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ?nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "CSS.trackComputedStyleUpdatesForNode";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Starts tracking the given node for the computed style updates
and whenever the computed style is updated for node, it queues
a `computedStyleUpdated` event with throttling.
There can only be 1 node tracked for computed style updates
so passing a new node id removes tracking from the previous node.
Pass `undefined` to disable tracking. |desc}]

  module TrackComputedStyleUpdates = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        propertiesToTrack : Types.CSS.CSSComputedStyleProperty.t list;
            [@key "propertiesToTrack"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~propertiesToTrack () = { propertiesToTrack }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.trackComputedStyleUpdates"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Starts tracking the given computed styles for updates. The specified array of properties
replaces the one previously specified. Pass empty array to disable tracking.
Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
The changes to computed style properties are only tracked for nodes pushed to the front-end
by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
to the front-end, no updates will be issued for the node. |desc}]

  module TakeComputedStyleUpdates = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "The list of node Ids that have their tracked computed styles \
               updated."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "The list of node Ids that have their tracked computed styles \
               updated."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.takeComputedStyleUpdates"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Polls the next batch of computed style updates. |desc}]

  module SetEffectivePropertyValueForNode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "The element id for which to set property."]
        propertyName : string;
            [@key "propertyName"] [@ocaml.doc "No description provided"]
        value : string; [@key "value"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId ~propertyName ~value () = { nodeId; propertyName; value }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "CSS.setEffectivePropertyValueForNode";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Find a rule with the given active property for the given node and set the new value for this
property |desc}]

  module SetPropertyRulePropertyName = struct
    module Response : sig
      type result = {
        propertyName : Types.CSS.Value.t;
            [@key "propertyName"]
            [@ocaml.doc "The resulting key text after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        propertyName : Types.CSS.Value.t;
            [@key "propertyName"]
            [@ocaml.doc "The resulting key text after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        propertyName : string;
            [@key "propertyName"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~propertyName () =
        { styleSheetId; range; propertyName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setPropertyRulePropertyName"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Modifies the property rule property name. |desc}]

  module SetKeyframeKey = struct
    module Response : sig
      type result = {
        keyText : Types.CSS.Value.t;
            [@key "keyText"]
            [@ocaml.doc "The resulting key text after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        keyText : Types.CSS.Value.t;
            [@key "keyText"]
            [@ocaml.doc "The resulting key text after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        keyText : string; [@key "keyText"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~keyText () =
        { styleSheetId; range; keyText }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setKeyframeKey"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Modifies the keyframe rule key text. |desc}]

  module SetMediaText = struct
    module Response : sig
      type result = {
        media : Types.CSS.CSSMedia.t;
            [@key "media"]
            [@ocaml.doc "The resulting CSS media rule after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        media : Types.CSS.CSSMedia.t;
            [@key "media"]
            [@ocaml.doc "The resulting CSS media rule after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        text : string; [@key "text"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~text () = { styleSheetId; range; text }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setMediaText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Modifies the rule selector. |desc}]

  module SetContainerQueryText = struct
    module Response : sig
      type result = {
        containerQuery : Types.CSS.CSSContainerQuery.t;
            [@key "containerQuery"]
            [@ocaml.doc
              "The resulting CSS container query rule after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        containerQuery : Types.CSS.CSSContainerQuery.t;
            [@key "containerQuery"]
            [@ocaml.doc
              "The resulting CSS container query rule after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        text : string; [@key "text"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~text () = { styleSheetId; range; text }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setContainerQueryText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Modifies the expression of a container query. |desc}]

  module SetSupportsText = struct
    module Response : sig
      type result = {
        supports : Types.CSS.CSSSupports.t;
            [@key "supports"]
            [@ocaml.doc "The resulting CSS Supports rule after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        supports : Types.CSS.CSSSupports.t;
            [@key "supports"]
            [@ocaml.doc "The resulting CSS Supports rule after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        text : string; [@key "text"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~text () = { styleSheetId; range; text }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setSupportsText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Modifies the expression of a supports at-rule. |desc}]

  module SetScopeText = struct
    module Response : sig
      type result = {
        scope : Types.CSS.CSSScope.t;
            [@key "scope"]
            [@ocaml.doc "The resulting CSS Scope rule after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        scope : Types.CSS.CSSScope.t;
            [@key "scope"]
            [@ocaml.doc "The resulting CSS Scope rule after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        text : string; [@key "text"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~text () = { styleSheetId; range; text }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setScopeText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Modifies the expression of a scope at-rule. |desc}]

  module SetRuleSelector = struct
    module Response : sig
      type result = {
        selectorList : Types.CSS.SelectorList.t;
            [@key "selectorList"]
            [@ocaml.doc "The resulting selector list after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        selectorList : Types.CSS.SelectorList.t;
            [@key "selectorList"]
            [@ocaml.doc "The resulting selector list after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        range : Types.CSS.SourceRange.t;
            [@key "range"] [@ocaml.doc "No description provided"]
        selector : string;
            [@key "selector"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~range ~selector () =
        { styleSheetId; range; selector }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setRuleSelector"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Modifies the rule selector. |desc}]

  module SetStyleSheetText = struct
    module Response : sig
      type result = {
        sourceMapURL : string option;
            [@key "sourceMapURL"]
            [@yojson.option]
            [@ocaml.doc "URL of source map associated with script (if any)."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        sourceMapURL : string option;
            [@key "sourceMapURL"]
            [@yojson.option]
            [@ocaml.doc "URL of source map associated with script (if any)."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        styleSheetId : Types.DOM.StyleSheetId.t;
            [@key "styleSheetId"] [@ocaml.doc "No description provided"]
        text : string; [@key "text"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~styleSheetId ~text () = { styleSheetId; text }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setStyleSheetText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets the new stylesheet text. |desc}]

  module SetStyleTexts = struct
    module Response : sig
      type result = {
        styles : Types.CSS.CSSStyle.t list;
            [@key "styles"]
            [@ocaml.doc "The resulting styles after modification."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        styles : Types.CSS.CSSStyle.t list;
            [@key "styles"]
            [@ocaml.doc "The resulting styles after modification."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        edits : Types.CSS.StyleDeclarationEdit.t list;
            [@key "edits"] [@ocaml.doc "No description provided"]
        nodeForPropertySyntaxValidation : Types.DOM.NodeId.t option;
            [@key "nodeForPropertySyntaxValidation"]
            [@yojson.option]
            [@ocaml.doc
              "NodeId for the DOM node in whose context custom property \
               declarations for registered properties should be\n\
               validated. If omitted, declarations in the new rule text can \
               only be validated statically, which may produce\n\
               incorrect results if the declaration contains a var() for \
               example."]
      }
      [@@deriving yojson]

      let make ~edits ?nodeForPropertySyntaxValidation () =
        { edits; nodeForPropertySyntaxValidation }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setStyleTexts"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Applies specified style edits one after another in the given order. |desc}]

  module StartRuleUsageTracking = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.startRuleUsageTracking"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables the selector recording. |desc}]

  module StopRuleUsageTracking = struct
    module Response : sig
      type result = {
        ruleUsage : Types.CSS.RuleUsage.t list;
            [@key "ruleUsage"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        ruleUsage : Types.CSS.RuleUsage.t list;
            [@key "ruleUsage"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.stopRuleUsageTracking"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Stop tracking rule usage and return the list of rules that were used since last call to
`takeCoverageDelta` (or since start of coverage instrumentation). |desc}]

  module TakeCoverageDelta = struct
    module Response : sig
      type result = {
        coverage : Types.CSS.RuleUsage.t list;
            [@key "coverage"] [@ocaml.doc "No description provided"]
        timestamp : Types.number;
            [@key "timestamp"]
            [@ocaml.doc "Monotonically increasing time, in seconds."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        coverage : Types.CSS.RuleUsage.t list;
            [@key "coverage"] [@ocaml.doc "No description provided"]
        timestamp : Types.number;
            [@key "timestamp"]
            [@ocaml.doc "Monotonically increasing time, in seconds."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "CSS.takeCoverageDelta"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Obtain list of rules that became used since last call to this method (or since start of coverage
instrumentation). |desc}]

  module SetLocalFontsEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc "Whether rendering of local fonts is enabled."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CSS.setLocalFontsEnabled"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables/disables rendering of local CSS fonts (enabled by default). |desc}]
end

module CacheStorage = struct
  module DeleteCache = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cacheId : Types.CacheStorage.CacheId.t;
            [@key "cacheId"] [@ocaml.doc "Id of cache for deletion."]
      }
      [@@deriving yojson]

      let make ~cacheId () = { cacheId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CacheStorage.deleteCache"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Deletes a cache. |desc}]

  module DeleteEntry = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cacheId : Types.CacheStorage.CacheId.t;
            [@key "cacheId"]
            [@ocaml.doc "Id of cache where the entry will be deleted."]
        request : string;
            [@key "request"] [@ocaml.doc "URL spec of the request."]
      }
      [@@deriving yojson]

      let make ~cacheId ~request () = { cacheId; request }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CacheStorage.deleteEntry"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Deletes a cache entry. |desc}]

  module RequestCacheNames = struct
    module Response : sig
      type result = {
        caches : Types.CacheStorage.Cache.t list;
            [@key "caches"] [@ocaml.doc "Caches for the security origin."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        caches : Types.CacheStorage.Cache.t list;
            [@key "caches"] [@ocaml.doc "Caches for the security origin."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey, \
               storageBucket must be specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        storageBucket : Types.Storage.StorageBucket.t option;
            [@key "storageBucket"]
            [@yojson.option]
            [@ocaml.doc
              "Storage bucket. If not specified, it uses the default bucket."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ?storageBucket () =
        { securityOrigin; storageKey; storageBucket }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CacheStorage.requestCacheNames"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Requests cache names. |desc}]

  module RequestCachedResponse = struct
    module Response : sig
      type result = {
        response : Types.CacheStorage.CachedResponse.t;
            [@key "response"] [@ocaml.doc "Response read from the cache."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        response : Types.CacheStorage.CachedResponse.t;
            [@key "response"] [@ocaml.doc "Response read from the cache."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cacheId : Types.CacheStorage.CacheId.t;
            [@key "cacheId"] [@ocaml.doc "Id of cache that contains the entry."]
        requestURL : string;
            [@key "requestURL"] [@ocaml.doc "URL spec of the request."]
        requestHeaders : Types.CacheStorage.Header.t list;
            [@key "requestHeaders"] [@ocaml.doc "headers of the request."]
      }
      [@@deriving yojson]

      let make ~cacheId ~requestURL ~requestHeaders () =
        { cacheId; requestURL; requestHeaders }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "CacheStorage.requestCachedResponse";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Fetches cache entry. |desc}]

  module RequestEntries = struct
    module Response : sig
      type result = {
        cacheDataEntries : Types.CacheStorage.DataEntry.t list;
            [@key "cacheDataEntries"]
            [@ocaml.doc "Array of object store data entries."]
        returnCount : Types.number;
            [@key "returnCount"]
            [@ocaml.doc
              "Count of returned entries from this storage. If pathFilter is \
               empty, it\n\
               is the count of all entries from this storage."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        cacheDataEntries : Types.CacheStorage.DataEntry.t list;
            [@key "cacheDataEntries"]
            [@ocaml.doc "Array of object store data entries."]
        returnCount : Types.number;
            [@key "returnCount"]
            [@ocaml.doc
              "Count of returned entries from this storage. If pathFilter is \
               empty, it\n\
               is the count of all entries from this storage."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cacheId : Types.CacheStorage.CacheId.t;
            [@key "cacheId"] [@ocaml.doc "ID of cache to get entries from."]
        skipCount : Types.number option;
            [@key "skipCount"]
            [@yojson.option]
            [@ocaml.doc "Number of records to skip."]
        pageSize : Types.number option;
            [@key "pageSize"]
            [@yojson.option]
            [@ocaml.doc "Number of records to fetch."]
        pathFilter : string option;
            [@key "pathFilter"]
            [@yojson.option]
            [@ocaml.doc
              "If present, only return the entries containing this substring \
               in the path"]
      }
      [@@deriving yojson]

      let make ~cacheId ?skipCount ?pageSize ?pathFilter () =
        { cacheId; skipCount; pageSize; pathFilter }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "CacheStorage.requestEntries"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Requests data from cache. |desc}]
end

module Cast = struct
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        presentationUrl : string option;
            [@key "presentationUrl"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ?presentationUrl () = { presentationUrl }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Cast.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Starts observing for sinks that can be used for tab mirroring, and if set,
sinks compatible with |presentationUrl| as well. When sinks are found, a
|sinksUpdated| event is fired.
Also starts observing for issue messages. When an issue is added or removed,
an |issueUpdated| event is fired. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Cast.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Stops observing for sinks and issues. |desc}]

  module SetSinkToUse = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sinkName : string;
            [@key "sinkName"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~sinkName () = { sinkName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Cast.setSinkToUse"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets a sink to be used when the web page requests the browser to choose a
sink via Presentation API, Remote Playback API, or Cast SDK. |desc}]

  module StartDesktopMirroring = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sinkName : string;
            [@key "sinkName"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~sinkName () = { sinkName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Cast.startDesktopMirroring"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Starts mirroring the desktop to the sink. |desc}]

  module StartTabMirroring = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sinkName : string;
            [@key "sinkName"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~sinkName () = { sinkName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Cast.startTabMirroring"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Starts mirroring the tab to the sink. |desc}]

  module StopCasting = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sinkName : string;
            [@key "sinkName"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~sinkName () = { sinkName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Cast.stopCasting"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Stops the active Cast session on the sink. |desc}]
end

module DOM = struct
  module CollectClassNamesFromSubtree = struct
    module Response : sig
      type result = {
        classNames : string list;
            [@key "classNames"] [@ocaml.doc "Class name list."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        classNames : string list;
            [@key "classNames"] [@ocaml.doc "Class name list."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the node to collect class names."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.collectClassNamesFromSubtree"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Collects class names for the node with given id and all of it's child nodes. |desc}]

  module CopyTo = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node clone."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node clone."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to copy."]
        targetNodeId : Types.DOM.NodeId.t;
            [@key "targetNodeId"]
            [@ocaml.doc "Id of the element to drop the copy into."]
        insertBeforeNodeId : Types.DOM.NodeId.t option;
            [@key "insertBeforeNodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Drop the copy before this node (if absent, the copy becomes the \
               last child of\n\
               `targetNodeId`)."]
      }
      [@@deriving yojson]

      let make ~nodeId ~targetNodeId ?insertBeforeNodeId () =
        { nodeId; targetNodeId; insertBeforeNodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.copyTo"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Creates a deep copy of the specified node and places it into the target container before the
given anchor. |desc}]

  module DescribeNode = struct
    module Response : sig
      type result = {
        node : Types.DOM.Node.t; [@key "node"] [@ocaml.doc "Node description."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        node : Types.DOM.Node.t; [@key "node"] [@ocaml.doc "Node description."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
        depth : Types.number option;
            [@key "depth"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum depth at which children should be retrieved, \
               defaults to 1. Use -1 for the\n\
               entire subtree or provide an integer larger than 0."]
        pierce : bool option;
            [@key "pierce"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not iframes and shadow roots should be traversed \
               when returning the subtree\n\
               (default is false)."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId ?depth ?pierce () =
        { nodeId; backendNodeId; objectId; depth; pierce }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.describeNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Describes node given its id, does not require domain to be enabled. Does not start tracking any
objects, can be used for automation. |desc}]

  module ScrollIntoViewIfNeeded = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
        rect : Types.DOM.Rect.t option;
            [@key "rect"]
            [@yojson.option]
            [@ocaml.doc
              "The rect to be scrolled into view, relative to the node's \
               border box, in CSS pixels.\n\
               When omitted, center of the node will be used, similar to \
               Element.scrollIntoView."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId ?rect () =
        { nodeId; backendNodeId; objectId; rect }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.scrollIntoViewIfNeeded"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Scrolls the specified rect of the given node into view if not already visible.
Note: exactly one between nodeId, backendNodeId and objectId should be passed
to identify the node. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables DOM agent for the given page. |desc}]

  module DiscardSearchResults = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        searchId : string;
            [@key "searchId"] [@ocaml.doc "Unique search session identifier."]
      }
      [@@deriving yojson]

      let make ~searchId () = { searchId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.discardSearchResults"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Discards search results from the session with the given id. `getSearchResults` should no longer
be called for that search. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type enable_includewhitespace = [ `none | `all ]

      let enable_includewhitespace_of_yojson = function
        | `String "none" -> `none
        | `String "all" -> `all
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_enable_includewhitespace = function
        | `none -> `String "none"
        | `all -> `String "all"

      type t = {
        includeWhitespace : enable_includewhitespace option;
            [@key "includeWhitespace"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include whitespaces in the children array of \
               returned Nodes."]
      }
      [@@deriving yojson]

      let make ?includeWhitespace () = { includeWhitespace }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables DOM agent for the given page. |desc}]

  module Focus = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId () =
        { nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.focus"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Focuses the given element. |desc}]

  module GetAttributes = struct
    module Response : sig
      type result = {
        attributes : string list;
            [@key "attributes"]
            [@ocaml.doc
              "An interleaved array of node attribute names and values."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        attributes : string list;
            [@key "attributes"]
            [@ocaml.doc
              "An interleaved array of node attribute names and values."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the node to retrieve attributes for."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getAttributes"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns attributes for the specified node. |desc}]

  module GetBoxModel = struct
    module Response : sig
      type result = {
        model : Types.DOM.BoxModel.t;
            [@key "model"] [@ocaml.doc "Box model for the node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        model : Types.DOM.BoxModel.t;
            [@key "model"] [@ocaml.doc "Box model for the node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId () =
        { nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getBoxModel"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns boxes for the given node. |desc}]

  module GetContentQuads = struct
    module Response : sig
      type result = {
        quads : Types.DOM.Quad.t list;
            [@key "quads"]
            [@ocaml.doc "Quads that describe node layout relative to viewport."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        quads : Types.DOM.Quad.t list;
            [@key "quads"]
            [@ocaml.doc "Quads that describe node layout relative to viewport."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId () =
        { nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getContentQuads"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns quads that describe node position on the page. This method
might return multiple quads for inline nodes. |desc}]

  module GetDocument = struct
    module Response : sig
      type result = {
        root : Types.DOM.Node.t; [@key "root"] [@ocaml.doc "Resulting node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        root : Types.DOM.Node.t; [@key "root"] [@ocaml.doc "Resulting node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        depth : Types.number option;
            [@key "depth"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum depth at which children should be retrieved, \
               defaults to 1. Use -1 for the\n\
               entire subtree or provide an integer larger than 0."]
        pierce : bool option;
            [@key "pierce"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not iframes and shadow roots should be traversed \
               when returning the subtree\n\
               (default is false)."]
      }
      [@@deriving yojson]

      let make ?depth ?pierce () = { depth; pierce }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getDocument"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the root DOM node (and optionally the subtree) to the caller.
Implicitly enables the DOM domain events for the current target. |desc}]

  module GetFlattenedDocument = struct
    module Response : sig
      type result = {
        nodes : Types.DOM.Node.t list;
            [@key "nodes"] [@ocaml.doc "Resulting node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodes : Types.DOM.Node.t list;
            [@key "nodes"] [@ocaml.doc "Resulting node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        depth : Types.number option;
            [@key "depth"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum depth at which children should be retrieved, \
               defaults to 1. Use -1 for the\n\
               entire subtree or provide an integer larger than 0."]
        pierce : bool option;
            [@key "pierce"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not iframes and shadow roots should be traversed \
               when returning the subtree\n\
               (default is false)."]
      }
      [@@deriving yojson]

      let make ?depth ?pierce () = { depth; pierce }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getFlattenedDocument"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the root DOM node (and optionally the subtree) to the caller.
Deprecated, as it is not designed to work well with the rest of the DOM agent.
Use DOMSnapshot.captureSnapshot instead. |desc}]

  module GetNodesForSubtreeByStyle = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "Resulting nodes."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "Resulting nodes."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Node ID pointing to the root of a subtree."]
        computedStyles : Types.DOM.CSSComputedStyleProperty.t list;
            [@key "computedStyles"]
            [@ocaml.doc
              "The style to filter nodes by (includes nodes if any of \
               properties matches)."]
        pierce : bool option;
            [@key "pierce"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not iframes and shadow roots in the same target \
               should be traversed when returning the\n\
               results (default is false)."]
      }
      [@@deriving yojson]

      let make ~nodeId ~computedStyles ?pierce () =
        { nodeId; computedStyles; pierce }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getNodesForSubtreeByStyle"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Finds nodes with a given computed style in a subtree. |desc}]

  module GetNodeForLocation = struct
    module Response : sig
      type result = {
        backendNodeId : Types.DOM.BackendNodeId.t;
            [@key "backendNodeId"] [@ocaml.doc "Resulting node."]
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "Frame this node belongs to."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Id of the node at given coordinates, only when enabled and \
               requested document."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        backendNodeId : Types.DOM.BackendNodeId.t;
            [@key "backendNodeId"] [@ocaml.doc "Resulting node."]
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "Frame this node belongs to."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Id of the node at given coordinates, only when enabled and \
               requested document."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        x : Types.number; [@key "x"] [@ocaml.doc "X coordinate."]
        y : Types.number; [@key "y"] [@ocaml.doc "Y coordinate."]
        includeUserAgentShadowDOM : bool option;
            [@key "includeUserAgentShadowDOM"]
            [@yojson.option]
            [@ocaml.doc
              "False to skip to the nearest non-UA shadow root ancestor \
               (default: false)."]
        ignorePointerEventsNone : bool option;
            [@key "ignorePointerEventsNone"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to ignore pointer-events: none on elements and hit test \
               them."]
      }
      [@@deriving yojson]

      let make ~x ~y ?includeUserAgentShadowDOM ?ignorePointerEventsNone () =
        { x; y; includeUserAgentShadowDOM; ignorePointerEventsNone }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getNodeForLocation"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
either returned or not. |desc}]

  module GetOuterHTML = struct
    module Response : sig
      type result = {
        outerHTML : string; [@key "outerHTML"] [@ocaml.doc "Outer HTML markup."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        outerHTML : string; [@key "outerHTML"] [@ocaml.doc "Outer HTML markup."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
        includeShadowDOM : bool option;
            [@key "includeShadowDOM"]
            [@yojson.option]
            [@ocaml.doc
              "Include all shadow roots. Equals to false if not specified."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectId ?includeShadowDOM () =
        { nodeId; backendNodeId; objectId; includeShadowDOM }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getOuterHTML"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns node's HTML markup. |desc}]

  module GetRelayoutBoundary = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Relayout boundary node id for the given node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Relayout boundary node id for the given node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getRelayoutBoundary"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the id of the nearest ancestor that is a relayout boundary. |desc}]

  module GetSearchResults = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "Ids of the search result nodes."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "Ids of the search result nodes."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        searchId : string;
            [@key "searchId"] [@ocaml.doc "Unique search session identifier."]
        fromIndex : Types.number;
            [@key "fromIndex"]
            [@ocaml.doc "Start index of the search result to be returned."]
        toIndex : Types.number;
            [@key "toIndex"]
            [@ocaml.doc "End index of the search result to be returned."]
      }
      [@@deriving yojson]

      let make ~searchId ~fromIndex ~toIndex () =
        { searchId; fromIndex; toIndex }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getSearchResults"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns search results from given `fromIndex` to given `toIndex` from the search with the given
identifier. |desc}]

  module HideHighlight = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.hideHighlight"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Hides any highlight. |desc}]

  module HighlightNode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.highlightNode"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Highlights DOM node. |desc}]

  module HighlightRect = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.highlightRect"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Highlights given rectangle. |desc}]

  module MarkUndoableState = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.markUndoableState"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Marks last undoable state. |desc}]

  module MoveTo = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "New id of the moved node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "New id of the moved node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to move."]
        targetNodeId : Types.DOM.NodeId.t;
            [@key "targetNodeId"]
            [@ocaml.doc "Id of the element to drop the moved node into."]
        insertBeforeNodeId : Types.DOM.NodeId.t option;
            [@key "insertBeforeNodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Drop node before this one (if absent, the moved node becomes \
               the last child of\n\
               `targetNodeId`)."]
      }
      [@@deriving yojson]

      let make ~nodeId ~targetNodeId ?insertBeforeNodeId () =
        { nodeId; targetNodeId; insertBeforeNodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.moveTo"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Moves node into the new container, places it before the given anchor. |desc}]

  module PerformSearch = struct
    module Response : sig
      type result = {
        searchId : string;
            [@key "searchId"] [@ocaml.doc "Unique search session identifier."]
        resultCount : Types.number;
            [@key "resultCount"] [@ocaml.doc "Number of search results."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        searchId : string;
            [@key "searchId"] [@ocaml.doc "Unique search session identifier."]
        resultCount : Types.number;
            [@key "resultCount"] [@ocaml.doc "Number of search results."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        query : string;
            [@key "query"]
            [@ocaml.doc "Plain text or query selector or XPath search query."]
        includeUserAgentShadowDOM : bool option;
            [@key "includeUserAgentShadowDOM"]
            [@yojson.option]
            [@ocaml.doc "True to search in user agent shadow DOM."]
      }
      [@@deriving yojson]

      let make ~query ?includeUserAgentShadowDOM () =
        { query; includeUserAgentShadowDOM }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.performSearch"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
`cancelSearch` to end this search session. |desc}]

  module PushNodeByPathToFrontend = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node for given path."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node for given path."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        path : string;
            [@key "path"] [@ocaml.doc "Path to node in the proprietary format."]
      }
      [@@deriving yojson]

      let make ~path () = { path }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.pushNodeByPathToFrontend"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Requests that the node is sent to the caller given its path. // FIXME, use XPath |desc}]

  module PushNodesByBackendIdsToFrontend = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "The array of ids of pushed nodes that correspond to the backend \
               ids specified in\n\
               backendNodeIds."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "The array of ids of pushed nodes that correspond to the backend \
               ids specified in\n\
               backendNodeIds."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        backendNodeIds : Types.DOM.BackendNodeId.t list;
            [@key "backendNodeIds"]
            [@ocaml.doc "The array of backend node ids."]
      }
      [@@deriving yojson]

      let make ~backendNodeIds () = { backendNodeIds }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOM.pushNodesByBackendIdsToFrontend";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Requests that a batch of nodes is sent to the caller given their backend node ids. |desc}]

  module QuerySelector = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Query selector result."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Query selector result."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to query upon."]
        selector : string; [@key "selector"] [@ocaml.doc "Selector string."]
      }
      [@@deriving yojson]

      let make ~nodeId ~selector () = { nodeId; selector }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.querySelector"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Executes `querySelector` on a given node. |desc}]

  module QuerySelectorAll = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "Query selector result."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "Query selector result."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to query upon."]
        selector : string; [@key "selector"] [@ocaml.doc "Selector string."]
      }
      [@@deriving yojson]

      let make ~nodeId ~selector () = { nodeId; selector }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.querySelectorAll"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Executes `querySelectorAll` on a given node. |desc}]

  module GetTopLayerElements = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "NodeIds of top layer elements"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"] [@ocaml.doc "NodeIds of top layer elements"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.getTopLayerElements"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns NodeIds of current top layer elements.
Top layer is rendered closest to the user within a viewport, therefore its elements always
appear on top of all other content. |desc}]

  module GetElementByRelation = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "NodeId of the element matching the queried relation."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "NodeId of the element matching the queried relation."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type getelementbyrelation_relation =
        [ `PopoverTarget | `InterestTarget | `CommandFor ]

      let getelementbyrelation_relation_of_yojson = function
        | `String "PopoverTarget" -> `PopoverTarget
        | `String "InterestTarget" -> `InterestTarget
        | `String "CommandFor" -> `CommandFor
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_getelementbyrelation_relation = function
        | `PopoverTarget -> `String "PopoverTarget"
        | `InterestTarget -> `String "InterestTarget"
        | `CommandFor -> `String "CommandFor"

      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the node from which to query the relation."]
        relation : getelementbyrelation_relation;
            [@key "relation"] [@ocaml.doc "Type of relation to get."]
      }
      [@@deriving yojson]

      let make ~nodeId ~relation () = { nodeId; relation }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getElementByRelation"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the NodeId of the matched element according to certain relations. |desc}]

  module Redo = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.redo"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Re-does the last undone action. |desc}]

  module RemoveAttribute = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the element to remove attribute from."]
        name : string;
            [@key "name"] [@ocaml.doc "Name of the attribute to remove."]
      }
      [@@deriving yojson]

      let make ~nodeId ~name () = { nodeId; name }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.removeAttribute"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Removes attribute with given name from an element with given id. |desc}]

  module RemoveNode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to remove."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.removeNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Removes node with given id. |desc}]

  module RequestChildNodes = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to get children for."]
        depth : Types.number option;
            [@key "depth"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum depth at which children should be retrieved, \
               defaults to 1. Use -1 for the\n\
               entire subtree or provide an integer larger than 0."]
        pierce : bool option;
            [@key "pierce"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not iframes and shadow roots should be traversed \
               when returning the sub-tree\n\
               (default is false)."]
      }
      [@@deriving yojson]

      let make ~nodeId ?depth ?pierce () = { nodeId; depth; pierce }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.requestChildNodes"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Requests that children of the node with given id are returned to the caller in form of
`setChildNodes` events where not only immediate children are retrieved, but all children down to
the specified depth. |desc}]

  module RequestNode = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Node id for given object."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Node id for given object."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"]
            [@ocaml.doc "JavaScript object id to convert into node."]
      }
      [@@deriving yojson]

      let make ~objectId () = { objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.requestNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Requests that the node is sent to the caller given the JavaScript node object reference. All
nodes that form the path from the node to the root are also sent to the client as a series of
`setChildNodes` notifications. |desc}]

  module ResolveNode = struct
    module Response : sig
      type result = {
        object_ : Types.Runtime.RemoteObject.t;
            [@key "object"]
            [@ocaml.doc "JavaScript object wrapper for given node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        object_ : Types.Runtime.RemoteObject.t;
            [@key "object"]
            [@ocaml.doc "JavaScript object wrapper for given node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Id of the node to resolve."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Backend identifier of the node to resolve."]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "Symbolic group name that can be used to release multiple \
               objects."]
        executionContextId : Types.Runtime.ExecutionContextId.t option;
            [@key "executionContextId"]
            [@yojson.option]
            [@ocaml.doc "Execution context in which to resolve the node."]
      }
      [@@deriving yojson]

      let make ?nodeId ?backendNodeId ?objectGroup ?executionContextId () =
        { nodeId; backendNodeId; objectGroup; executionContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.resolveNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Resolves the JavaScript node object for a given NodeId or BackendNodeId. |desc}]

  module SetAttributeValue = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the element to set attribute for."]
        name : string; [@key "name"] [@ocaml.doc "Attribute name."]
        value : string; [@key "value"] [@ocaml.doc "Attribute value."]
      }
      [@@deriving yojson]

      let make ~nodeId ~name ~value () = { nodeId; name; value }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setAttributeValue"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets attribute for an element with given id. |desc}]

  module SetAttributesAsText = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the element to set attributes for."]
        text : string;
            [@key "text"]
            [@ocaml.doc
              "Text with a number of attributes. Will parse this text using \
               HTML parser."]
        name : string option;
            [@key "name"]
            [@yojson.option]
            [@ocaml.doc
              "Attribute name to replace with new attributes derived from text \
               in case text parsed\n\
               successfully."]
      }
      [@@deriving yojson]

      let make ~nodeId ~text ?name () = { nodeId; text; name }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setAttributesAsText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets attributes on element with given id. This method is useful when user edits some existing
attribute value and types in several attribute name/value pairs. |desc}]

  module SetFileInputFiles = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        files : string list;
            [@key "files"] [@ocaml.doc "Array of file paths to set."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
      }
      [@@deriving yojson]

      let make ~files ?nodeId ?backendNodeId ?objectId () =
        { files; nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setFileInputFiles"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets files for the given file input element. |desc}]

  module SetNodeStackTracesEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enable : bool; [@key "enable"] [@ocaml.doc "Enable or disable."]
      }
      [@@deriving yojson]

      let make ~enable () = { enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setNodeStackTracesEnabled"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled. |desc}]

  module GetNodeStackTraces = struct
    module Response : sig
      type result = {
        creation : Types.Runtime.StackTrace.t option;
            [@key "creation"]
            [@yojson.option]
            [@ocaml.doc "Creation stack trace, if available."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        creation : Types.Runtime.StackTrace.t option;
            [@key "creation"]
            [@yojson.option]
            [@ocaml.doc "Creation stack trace, if available."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the node to get stack traces for."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getNodeStackTraces"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation. |desc}]

  module GetFileInfo = struct
    module Response : sig
      type result = {
        path : string; [@key "path"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        path : string; [@key "path"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"]
            [@ocaml.doc "JavaScript object id of the node wrapper."]
      }
      [@@deriving yojson]

      let make ~objectId () = { objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getFileInfo"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns file information for the given
File wrapper. |desc}]

  module GetDetachedDomNodes = struct
    module Response : sig
      type result = {
        detachedNodes : Types.DOM.DetachedElementInfo.t list;
            [@key "detachedNodes"] [@ocaml.doc "The list of detached nodes"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        detachedNodes : Types.DOM.DetachedElementInfo.t list;
            [@key "detachedNodes"] [@ocaml.doc "The list of detached nodes"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.getDetachedDomNodes"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns list of detached nodes |desc}]

  module SetInspectedNode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc
              "DOM node id to be accessible by means of $x command line API."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setInspectedNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables console to refer to the node with given id via $x (see Command Line API for more details
$x functions). |desc}]

  module SetNodeName = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "New node's id."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "New node's id."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to set name for."]
        name : string; [@key "name"] [@ocaml.doc "New node's name."]
      }
      [@@deriving yojson]

      let make ~nodeId ~name () = { nodeId; name }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setNodeName"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets node name for a node with given id. |desc}]

  module SetNodeValue = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to set value for."]
        value : string; [@key "value"] [@ocaml.doc "New node's value."]
      }
      [@@deriving yojson]

      let make ~nodeId ~value () = { nodeId; value }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setNodeValue"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets node value for a node with given id. |desc}]

  module SetOuterHTML = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to set markup for."]
        outerHTML : string;
            [@key "outerHTML"] [@ocaml.doc "Outer HTML markup to set."]
      }
      [@@deriving yojson]

      let make ~nodeId ~outerHTML () = { nodeId; outerHTML }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.setOuterHTML"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets node HTML markup, returns new node id. |desc}]

  module Undo = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOM.undo"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Undoes the last performed action. |desc}]

  module GetFrameOwner = struct
    module Response : sig
      type result = {
        backendNodeId : Types.DOM.BackendNodeId.t;
            [@key "backendNodeId"] [@ocaml.doc "Resulting node."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Id of the node at given coordinates, only when enabled and \
               requested document."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        backendNodeId : Types.DOM.BackendNodeId.t;
            [@key "backendNodeId"] [@ocaml.doc "Resulting node."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "Id of the node at given coordinates, only when enabled and \
               requested document."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getFrameOwner"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns iframe node that owns iframe with the given domain. |desc}]

  module GetContainerForNode = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "The container node for the given node, or null if not found."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc
              "The container node for the given node, or null if not found."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "No description provided"]
        containerName : string option;
            [@key "containerName"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        physicalAxes : Types.DOM.PhysicalAxes.t option;
            [@key "physicalAxes"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        logicalAxes : Types.DOM.LogicalAxes.t option;
            [@key "logicalAxes"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        queriesScrollState : bool option;
            [@key "queriesScrollState"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        queriesAnchored : bool option;
            [@key "queriesAnchored"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~nodeId ?containerName ?physicalAxes ?logicalAxes
          ?queriesScrollState ?queriesAnchored () =
        {
          nodeId;
          containerName;
          physicalAxes;
          logicalAxes;
          queriesScrollState;
          queriesAnchored;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getContainerForNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the query container of the given node based on container query
conditions: containerName, physical and logical axes, and whether it queries
scroll-state or anchored elements. If no axes are provided and
queriesScrollState is false, the style container is returned, which is the
direct parent or the closest element with a matching container-name. |desc}]

  module GetQueryingDescendantsForContainer = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "Descendant nodes with container queries against the given \
               container."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "Descendant nodes with container queries against the given \
               container."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc
              "Id of the container node to find querying descendants from."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOM.getQueryingDescendantsForContainer";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the descendants of a container query container that have
container queries against this container. |desc}]

  module GetAnchorElement = struct
    module Response : sig
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "The anchor element of the given anchor query."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "The anchor element of the given anchor query."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc
              "Id of the positioned element from which to find the anchor."]
        anchorSpecifier : string option;
            [@key "anchorSpecifier"]
            [@yojson.option]
            [@ocaml.doc
              "An optional anchor specifier, as defined in\n\
               https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier.\n\
               If not provided, it will return the implicit anchor element for\n\
               the given positioned element."]
      }
      [@@deriving yojson]

      let make ~nodeId ?anchorSpecifier () = { nodeId; anchorSpecifier }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.getAnchorElement"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the target anchor element of the given anchor query according to
https://www.w3.org/TR/css-anchor-position-1/#target. |desc}]

  module ForceShowPopover = struct
    module Response : sig
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "List of popovers that were closed in order to respect popover \
               stacking order."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc
              "List of popovers that were closed in order to respect popover \
               stacking order."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the popover HTMLElement"]
        enable : bool;
            [@key "enable"]
            [@ocaml.doc
              "If true, opens the popover and keeps it open. If false, closes \
               the\n\
               popover if it was previously force-opened."]
      }
      [@@deriving yojson]

      let make ~nodeId ~enable () = { nodeId; enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOM.forceShowPopover"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|When enabling, this API force-opens the popover identified by nodeId
and keeps it open until disabled. |desc}]
end

module DOMDebugger = struct
  module GetEventListeners = struct
    module Response : sig
      type result = {
        listeners : Types.DOMDebugger.EventListener.t list;
            [@key "listeners"] [@ocaml.doc "Array of relevant listeners."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        listeners : Types.DOMDebugger.EventListener.t list;
            [@key "listeners"] [@ocaml.doc "Array of relevant listeners."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"]
            [@ocaml.doc "Identifier of the object to return listeners for."]
        depth : Types.number option;
            [@key "depth"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum depth at which Node children should be retrieved, \
               defaults to 1. Use -1 for the\n\
               entire subtree or provide an integer larger than 0."]
        pierce : bool option;
            [@key "pierce"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not iframes and shadow roots should be traversed \
               when returning the subtree\n\
               (default is false). Reports listeners for all contexts if \
               pierce is enabled."]
      }
      [@@deriving yojson]

      let make ~objectId ?depth ?pierce () = { objectId; depth; pierce }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMDebugger.getEventListeners"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns event listeners of the given object. |desc}]

  module RemoveDOMBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Identifier of the node to remove breakpoint from."]
        type_ : Types.DOMDebugger.DOMBreakpointType.t;
            [@key "type"] [@ocaml.doc "Type of the breakpoint to remove."]
      }
      [@@deriving yojson]

      let make ~nodeId ~type_ () = { nodeId; type_ }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMDebugger.removeDOMBreakpoint"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Removes DOM breakpoint that was set using `setDOMBreakpoint`. |desc}]

  module RemoveEventListenerBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventName : string; [@key "eventName"] [@ocaml.doc "Event name."]
        targetName : string option;
            [@key "targetName"]
            [@yojson.option]
            [@ocaml.doc "EventTarget interface name."]
      }
      [@@deriving yojson]

      let make ~eventName ?targetName () = { eventName; targetName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOMDebugger.removeEventListenerBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Removes breakpoint on particular DOM event. |desc}]

  module RemoveInstrumentationBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventName : string;
            [@key "eventName"] [@ocaml.doc "Instrumentation name to stop on."]
      }
      [@@deriving yojson]

      let make ~eventName () = { eventName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOMDebugger.removeInstrumentationBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Removes breakpoint on particular native event. |desc}]

  module RemoveXHRBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        url : string; [@key "url"] [@ocaml.doc "Resource URL substring."]
      }
      [@@deriving yojson]

      let make ~url () = { url }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMDebugger.removeXHRBreakpoint"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Removes breakpoint from XMLHttpRequest. |desc}]

  module SetBreakOnCSPViolation = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        violationTypes : Types.DOMDebugger.CSPViolationType.t list;
            [@key "violationTypes"] [@ocaml.doc "CSP Violations to stop upon."]
      }
      [@@deriving yojson]

      let make ~violationTypes () = { violationTypes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOMDebugger.setBreakOnCSPViolation";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets breakpoint on particular CSP violations. |desc}]

  module SetDOMBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Identifier of the node to set breakpoint on."]
        type_ : Types.DOMDebugger.DOMBreakpointType.t;
            [@key "type"] [@ocaml.doc "Type of the operation to stop upon."]
      }
      [@@deriving yojson]

      let make ~nodeId ~type_ () = { nodeId; type_ }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMDebugger.setDOMBreakpoint"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets breakpoint on particular operation with DOM. |desc}]

  module SetEventListenerBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventName : string;
            [@key "eventName"]
            [@ocaml.doc "DOM Event name to stop on (any DOM event will do)."]
        targetName : string option;
            [@key "targetName"]
            [@yojson.option]
            [@ocaml.doc
              "EventTarget interface name to stop on. If equal to `\"*\"` or \
               not provided, will stop on any\n\
               EventTarget."]
      }
      [@@deriving yojson]

      let make ~eventName ?targetName () = { eventName; targetName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOMDebugger.setEventListenerBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets breakpoint on particular DOM event. |desc}]

  module SetInstrumentationBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventName : string;
            [@key "eventName"] [@ocaml.doc "Instrumentation name to stop on."]
      }
      [@@deriving yojson]

      let make ~eventName () = { eventName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DOMDebugger.setInstrumentationBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets breakpoint on particular native event. |desc}]

  module SetXHRBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        url : string;
            [@key "url"]
            [@ocaml.doc
              "Resource URL substring. All XHRs having this substring in the \
               URL will get stopped upon."]
      }
      [@@deriving yojson]

      let make ~url () = { url }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMDebugger.setXHRBreakpoint"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets breakpoint on XMLHttpRequest. |desc}]
end

module DOMSnapshot = struct
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOMSnapshot.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables DOM snapshot agent for the given page. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOMSnapshot.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables DOM snapshot agent for the given page. |desc}]

  module GetSnapshot = struct
    module Response : sig
      type result = {
        domNodes : Types.DOMSnapshot.DOMNode.t list;
            [@key "domNodes"]
            [@ocaml.doc
              "The nodes in the DOM tree. The DOMNode at index 0 corresponds \
               to the root document."]
        layoutTreeNodes : Types.DOMSnapshot.LayoutTreeNode.t list;
            [@key "layoutTreeNodes"]
            [@ocaml.doc "The nodes in the layout tree."]
        computedStyles : Types.DOMSnapshot.ComputedStyle.t list;
            [@key "computedStyles"]
            [@ocaml.doc
              "Whitelisted ComputedStyle properties for each node in the \
               layout tree."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        domNodes : Types.DOMSnapshot.DOMNode.t list;
            [@key "domNodes"]
            [@ocaml.doc
              "The nodes in the DOM tree. The DOMNode at index 0 corresponds \
               to the root document."]
        layoutTreeNodes : Types.DOMSnapshot.LayoutTreeNode.t list;
            [@key "layoutTreeNodes"]
            [@ocaml.doc "The nodes in the layout tree."]
        computedStyles : Types.DOMSnapshot.ComputedStyle.t list;
            [@key "computedStyles"]
            [@ocaml.doc
              "Whitelisted ComputedStyle properties for each node in the \
               layout tree."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        computedStyleWhitelist : string list;
            [@key "computedStyleWhitelist"]
            [@ocaml.doc "Whitelist of computed styles to return."]
        includeEventListeners : bool option;
            [@key "includeEventListeners"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not to retrieve details of DOM listeners (default \
               false)."]
        includePaintOrder : bool option;
            [@key "includePaintOrder"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to determine and include the paint order index of \
               LayoutTreeNodes (default false)."]
        includeUserAgentShadowTree : bool option;
            [@key "includeUserAgentShadowTree"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include UA shadow tree in the snapshot (default \
               false)."]
      }
      [@@deriving yojson]

      let make ~computedStyleWhitelist ?includeEventListeners ?includePaintOrder
          ?includeUserAgentShadowTree () =
        {
          computedStyleWhitelist;
          includeEventListeners;
          includePaintOrder;
          includeUserAgentShadowTree;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMSnapshot.getSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns a document snapshot, including the full DOM tree of the root node (including iframes,
template contents, and imported documents) in a flattened array, as well as layout and
white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
flattened. |desc}]

  module CaptureSnapshot = struct
    module Response : sig
      type result = {
        documents : Types.DOMSnapshot.DocumentSnapshot.t list;
            [@key "documents"]
            [@ocaml.doc
              "The nodes in the DOM tree. The DOMNode at index 0 corresponds \
               to the root document."]
        strings : string list;
            [@key "strings"]
            [@ocaml.doc
              "Shared string table that all string properties refer to with \
               indexes."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        documents : Types.DOMSnapshot.DocumentSnapshot.t list;
            [@key "documents"]
            [@ocaml.doc
              "The nodes in the DOM tree. The DOMNode at index 0 corresponds \
               to the root document."]
        strings : string list;
            [@key "strings"]
            [@ocaml.doc
              "Shared string table that all string properties refer to with \
               indexes."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        computedStyles : string list;
            [@key "computedStyles"]
            [@ocaml.doc "Whitelist of computed styles to return."]
        includePaintOrder : bool option;
            [@key "includePaintOrder"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include layout object paint orders into the snapshot."]
        includeDOMRects : bool option;
            [@key "includeDOMRects"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include DOM rectangles (offsetRects, clientRects, \
               scrollRects) into the snapshot"]
        includeBlendedBackgroundColors : bool option;
            [@key "includeBlendedBackgroundColors"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include blended background colors in the snapshot \
               (default: false).\n\
               Blended background color is achieved by blending background \
               colors of all elements\n\
               that overlap with the current element."]
        includeTextColorOpacities : bool option;
            [@key "includeTextColorOpacities"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include text color opacity in the snapshot (default: \
               false).\n\
               An element might have the opacity property set that affects the \
               text color of the element.\n\
               The final text color opacity is computed based on the opacity \
               of all overlapping elements."]
      }
      [@@deriving yojson]

      let make ~computedStyles ?includePaintOrder ?includeDOMRects
          ?includeBlendedBackgroundColors ?includeTextColorOpacities () =
        {
          computedStyles;
          includePaintOrder;
          includeDOMRects;
          includeBlendedBackgroundColors;
          includeTextColorOpacities;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMSnapshot.captureSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns a document snapshot, including the full DOM tree of the root node (including iframes,
template contents, and imported documents) in a flattened array, as well as layout and
white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
flattened. |desc}]
end

module DOMStorage = struct
  module Clear = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageId : Types.DOMStorage.StorageId.t;
            [@key "storageId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~storageId () = { storageId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMStorage.clear"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOMStorage.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Disables storage tracking, prevents storage events from being sent to the client. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DOMStorage.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables storage tracking, storage events will now be delivered to the client. |desc}]

  module GetDOMStorageItems = struct
    module Response : sig
      type result = {
        entries : Types.DOMStorage.Item.t list;
            [@key "entries"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        entries : Types.DOMStorage.Item.t list;
            [@key "entries"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageId : Types.DOMStorage.StorageId.t;
            [@key "storageId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~storageId () = { storageId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMStorage.getDOMStorageItems"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module RemoveDOMStorageItem = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageId : Types.DOMStorage.StorageId.t;
            [@key "storageId"] [@ocaml.doc "No description provided"]
        key : string; [@key "key"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~storageId ~key () = { storageId; key }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMStorage.removeDOMStorageItem"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetDOMStorageItem = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageId : Types.DOMStorage.StorageId.t;
            [@key "storageId"] [@ocaml.doc "No description provided"]
        key : string; [@key "key"] [@ocaml.doc "No description provided"]
        value : string; [@key "value"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~storageId ~key ~value () = { storageId; key; value }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DOMStorage.setDOMStorageItem"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]
end

module DeviceAccess = struct
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DeviceAccess.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enable events in this domain. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "DeviceAccess.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disable events in this domain. |desc}]

  module SelectPrompt = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        id : Types.DeviceAccess.RequestId.t;
            [@key "id"] [@ocaml.doc "No description provided"]
        deviceId : Types.DeviceAccess.DeviceId.t;
            [@key "deviceId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~id ~deviceId () = { id; deviceId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DeviceAccess.selectPrompt"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Select a device in response to a DeviceAccess.deviceRequestPrompted event. |desc}]

  module CancelPrompt = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        id : Types.DeviceAccess.RequestId.t;
            [@key "id"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~id () = { id }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "DeviceAccess.cancelPrompt"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Cancel a prompt in response to a DeviceAccess.deviceRequestPrompted event. |desc}]
end

module DeviceOrientation = struct
  module ClearDeviceOrientationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        {
          id;
          method_ = "DeviceOrientation.clearDeviceOrientationOverride";
          sessionId;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears the overridden Device Orientation. |desc}]

  module SetDeviceOrientationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        alpha : Types.number; [@key "alpha"] [@ocaml.doc "Mock alpha"]
        beta : Types.number; [@key "beta"] [@ocaml.doc "Mock beta"]
        gamma : Types.number; [@key "gamma"] [@ocaml.doc "Mock gamma"]
      }
      [@@deriving yojson]

      let make ~alpha ~beta ~gamma () = { alpha; beta; gamma }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "DeviceOrientation.setDeviceOrientationOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Overrides the Device Orientation. |desc}]
end

module Emulation = struct
  module CanEmulate = struct
    module Response : sig
      type result = {
        result : bool;
            [@key "result"] [@ocaml.doc "True if emulation is supported."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : bool;
            [@key "result"] [@ocaml.doc "True if emulation is supported."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.canEmulate"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Tells whether emulation is supported. |desc}]

  module ClearDeviceMetricsOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.clearDeviceMetricsOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears the overridden device metrics. |desc}]

  module ClearGeolocationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.clearGeolocationOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Clears the overridden Geolocation Position and Error. |desc}]

  module ResetPageScaleFactor = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.resetPageScaleFactor"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Requests that page scale factor is reset to initial values. |desc}]

  module SetFocusEmulationEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc "Whether to enable to disable focus emulation."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setFocusEmulationEnabled";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables or disables simulating a focused and active page. |desc}]

  module SetAutoDarkModeOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool option;
            [@key "enabled"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to enable or disable automatic dark mode.\n\
               If not specified, any existing override will be cleared."]
      }
      [@@deriving yojson]

      let make ?enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setAutoDarkModeOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Automatically render all web contents using a dark theme. |desc}]

  module SetCPUThrottlingRate = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        rate : Types.number;
            [@key "rate"]
            [@ocaml.doc
              "Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x \
               slowdown, etc)."]
      }
      [@@deriving yojson]

      let make ~rate () = { rate }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setCPUThrottlingRate"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables CPU throttling to emulate slow CPUs. |desc}]

  module SetDefaultBackgroundColorOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        color : Types.DOM.RGBA.t option;
            [@key "color"]
            [@yojson.option]
            [@ocaml.doc
              "RGBA of the default background color. If not specified, any \
               existing override will be\n\
               cleared."]
      }
      [@@deriving yojson]

      let make ?color () = { color }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setDefaultBackgroundColorOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets or clears an override of the default background color of the frame. This override is used
if the content does not specify one. |desc}]

  module SetSafeAreaInsetsOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        insets : Types.Emulation.SafeAreaInsets.t;
            [@key "insets"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~insets () = { insets }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setSafeAreaInsetsOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Overrides the values for env(safe-area-inset-*) and env(safe-area-max-inset-*). Unset values will cause the
respective variables to be undefined, even if previously overridden. |desc}]

  module SetDeviceMetricsOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        width : Types.number;
            [@key "width"]
            [@ocaml.doc
              "Overriding width value in pixels (minimum 0, maximum 10000000). \
               0 disables the override."]
        height : Types.number;
            [@key "height"]
            [@ocaml.doc
              "Overriding height value in pixels (minimum 0, maximum \
               10000000). 0 disables the override."]
        deviceScaleFactor : Types.number;
            [@key "deviceScaleFactor"]
            [@ocaml.doc
              "Overriding device scale factor value. 0 disables the override."]
        mobile : bool;
            [@key "mobile"]
            [@ocaml.doc
              "Whether to emulate mobile device. This includes viewport meta \
               tag, overlay scrollbars, text\n\
               autosizing and more."]
        scale : Types.number option;
            [@key "scale"]
            [@yojson.option]
            [@ocaml.doc "Scale to apply to resulting view image."]
        screenWidth : Types.number option;
            [@key "screenWidth"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding screen width value in pixels (minimum 0, maximum \
               10000000)."]
        screenHeight : Types.number option;
            [@key "screenHeight"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding screen height value in pixels (minimum 0, maximum \
               10000000)."]
        positionX : Types.number option;
            [@key "positionX"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding view X position on screen in pixels (minimum 0, \
               maximum 10000000)."]
        positionY : Types.number option;
            [@key "positionY"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding view Y position on screen in pixels (minimum 0, \
               maximum 10000000)."]
        dontSetVisibleSize : bool option;
            [@key "dontSetVisibleSize"]
            [@yojson.option]
            [@ocaml.doc
              "Do not set visible view size, rely upon explicit setVisibleSize \
               call."]
        screenOrientation : Types.Emulation.ScreenOrientation.t option;
            [@key "screenOrientation"]
            [@yojson.option]
            [@ocaml.doc "Screen orientation override."]
        viewport : Types.Page.Viewport.t option;
            [@key "viewport"]
            [@yojson.option]
            [@ocaml.doc
              "If set, the visible area of the page will be overridden to this \
               viewport. This viewport\n\
               change is not observed by the page, e.g. viewport-relative \
               elements do not change positions."]
        displayFeature : Types.Emulation.DisplayFeature.t option;
            [@key "displayFeature"]
            [@yojson.option]
            [@ocaml.doc
              "If set, the display feature of a multi-segment screen. If not \
               set, multi-segment support\n\
               is turned-off.\n\
               Deprecated, use Emulation.setDisplayFeaturesOverride."]
        devicePosture : Types.Emulation.DevicePosture.t option;
            [@key "devicePosture"]
            [@yojson.option]
            [@ocaml.doc
              "If set, the posture of a foldable device. If not set the \
               posture is set\n\
               to continuous.\n\
               Deprecated, use Emulation.setDevicePostureOverride."]
      }
      [@@deriving yojson]

      let make ~width ~height ~deviceScaleFactor ~mobile ?scale ?screenWidth
          ?screenHeight ?positionX ?positionY ?dontSetVisibleSize
          ?screenOrientation ?viewport ?displayFeature ?devicePosture () =
        {
          width;
          height;
          deviceScaleFactor;
          mobile;
          scale;
          screenWidth;
          screenHeight;
          positionX;
          positionY;
          dontSetVisibleSize;
          screenOrientation;
          viewport;
          displayFeature;
          devicePosture;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setDeviceMetricsOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
query results). |desc}]

  module SetDevicePostureOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        posture : Types.Emulation.DevicePosture.t;
            [@key "posture"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~posture () = { posture }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setDevicePostureOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Start reporting the given posture value to the Device Posture API.
This override can also be set in setDeviceMetricsOverride(). |desc}]

  module ClearDevicePostureOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.clearDevicePostureOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Clears a device posture override set with either setDeviceMetricsOverride()
or setDevicePostureOverride() and starts using posture information from the
platform again.
Does nothing if no override is set. |desc}]

  module SetDisplayFeaturesOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        features : Types.Emulation.DisplayFeature.t list;
            [@key "features"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~features () = { features }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setDisplayFeaturesOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Start using the given display features to pupulate the Viewport Segments API.
This override can also be set in setDeviceMetricsOverride(). |desc}]

  module ClearDisplayFeaturesOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.clearDisplayFeaturesOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Clears the display features override set with either setDeviceMetricsOverride()
or setDisplayFeaturesOverride() and starts using display features from the
platform again.
Does nothing if no override is set. |desc}]

  module SetScrollbarsHidden = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        hidden : bool;
            [@key "hidden"]
            [@ocaml.doc "Whether scrollbars should be always hidden."]
      }
      [@@deriving yojson]

      let make ~hidden () = { hidden }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setScrollbarsHidden"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetDocumentCookieDisabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        disabled : bool;
            [@key "disabled"]
            [@ocaml.doc "Whether document.coookie API should be disabled."]
      }
      [@@deriving yojson]

      let make ~disabled () = { disabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setDocumentCookieDisabled";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetEmitTouchEventsForMouse = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setemittoucheventsformouse_configuration = [ `mobile | `desktop ]

      let setemittoucheventsformouse_configuration_of_yojson = function
        | `String "mobile" -> `mobile
        | `String "desktop" -> `desktop
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setemittoucheventsformouse_configuration = function
        | `mobile -> `String "mobile"
        | `desktop -> `String "desktop"

      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc
              "Whether touch emulation based on mouse input should be enabled."]
        configuration : setemittoucheventsformouse_configuration option;
            [@key "configuration"]
            [@yojson.option]
            [@ocaml.doc
              "Touch/gesture events configuration. Default: current platform."]
      }
      [@@deriving yojson]

      let make ~enabled ?configuration () = { enabled; configuration }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setEmitTouchEventsForMouse";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetEmulatedMedia = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        media : string option;
            [@key "media"]
            [@yojson.option]
            [@ocaml.doc
              "Media type to emulate. Empty string disables the override."]
        features : Types.Emulation.MediaFeature.t list option;
            [@key "features"]
            [@yojson.option]
            [@ocaml.doc "Media features to emulate."]
      }
      [@@deriving yojson]

      let make ?media ?features () = { media; features }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setEmulatedMedia"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Emulates the given media type or media feature for CSS media queries. |desc}]

  module SetEmulatedVisionDeficiency = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setemulatedvisiondeficiency_type =
        [ `none
        | `blurredVision
        | `reducedContrast
        | `achromatopsia
        | `deuteranopia
        | `protanopia
        | `tritanopia ]

      let setemulatedvisiondeficiency_type_of_yojson = function
        | `String "none" -> `none
        | `String "blurredVision" -> `blurredVision
        | `String "reducedContrast" -> `reducedContrast
        | `String "achromatopsia" -> `achromatopsia
        | `String "deuteranopia" -> `deuteranopia
        | `String "protanopia" -> `protanopia
        | `String "tritanopia" -> `tritanopia
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setemulatedvisiondeficiency_type = function
        | `none -> `String "none"
        | `blurredVision -> `String "blurredVision"
        | `reducedContrast -> `String "reducedContrast"
        | `achromatopsia -> `String "achromatopsia"
        | `deuteranopia -> `String "deuteranopia"
        | `protanopia -> `String "protanopia"
        | `tritanopia -> `String "tritanopia"

      type t = {
        type_ : setemulatedvisiondeficiency_type;
            [@key "type"]
            [@ocaml.doc
              "Vision deficiency to emulate. Order: best-effort emulations \
               come first, followed by any\n\
               physiologically accurate emulations for medically recognized \
               color vision deficiencies."]
      }
      [@@deriving yojson]

      let make ~type_ () = { type_ }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setEmulatedVisionDeficiency";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Emulates the given vision deficiency. |desc}]

  module SetEmulatedOSTextScale = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scale : Types.number option;
            [@key "scale"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ?scale () = { scale }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setEmulatedOSTextScale"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Emulates the given OS text scale. |desc}]

  module SetGeolocationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        latitude : Types.number option;
            [@key "latitude"] [@yojson.option] [@ocaml.doc "Mock latitude"]
        longitude : Types.number option;
            [@key "longitude"] [@yojson.option] [@ocaml.doc "Mock longitude"]
        accuracy : Types.number option;
            [@key "accuracy"] [@yojson.option] [@ocaml.doc "Mock accuracy"]
        altitude : Types.number option;
            [@key "altitude"] [@yojson.option] [@ocaml.doc "Mock altitude"]
        altitudeAccuracy : Types.number option;
            [@key "altitudeAccuracy"]
            [@yojson.option]
            [@ocaml.doc "Mock altitudeAccuracy"]
        heading : Types.number option;
            [@key "heading"] [@yojson.option] [@ocaml.doc "Mock heading"]
        speed : Types.number option;
            [@key "speed"] [@yojson.option] [@ocaml.doc "Mock speed"]
      }
      [@@deriving yojson]

      let make ?latitude ?longitude ?accuracy ?altitude ?altitudeAccuracy
          ?heading ?speed () =
        {
          latitude;
          longitude;
          accuracy;
          altitude;
          altitudeAccuracy;
          heading;
          speed;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setGeolocationOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Overrides the Geolocation Position or Error. Omitting latitude, longitude or
accuracy emulates position unavailable. |desc}]

  module GetOverriddenSensorInformation = struct
    module Response : sig
      type result = {
        requestedSamplingFrequency : Types.number;
            [@key "requestedSamplingFrequency"]
            [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        requestedSamplingFrequency : Types.number;
            [@key "requestedSamplingFrequency"]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        type_ : Types.Emulation.SensorType.t;
            [@key "type"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~type_ () = { type_ }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.getOverriddenSensorInformation";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetSensorOverrideEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool; [@key "enabled"] [@ocaml.doc "No description provided"]
        type_ : Types.Emulation.SensorType.t;
            [@key "type"] [@ocaml.doc "No description provided"]
        metadata : Types.Emulation.SensorMetadata.t option;
            [@key "metadata"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enabled ~type_ ?metadata () = { enabled; type_; metadata }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setSensorOverrideEnabled";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Overrides a platform sensor of a given type. If |enabled| is true, calls to
Sensor.start() will use a virtual sensor as backend rather than fetching
data from a real hardware sensor. Otherwise, existing virtual
sensor-backend Sensor objects will fire an error event and new calls to
Sensor.start() will attempt to use a real sensor instead. |desc}]

  module SetSensorOverrideReadings = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        type_ : Types.Emulation.SensorType.t;
            [@key "type"] [@ocaml.doc "No description provided"]
        reading : Types.Emulation.SensorReading.t;
            [@key "reading"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~type_ ~reading () = { type_; reading }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setSensorOverrideReadings";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Updates the sensor readings reported by a sensor type previously overridden
by setSensorOverrideEnabled. |desc}]

  module SetPressureSourceOverrideEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool; [@key "enabled"] [@ocaml.doc "No description provided"]
        source : Types.Emulation.PressureSource.t;
            [@key "source"] [@ocaml.doc "No description provided"]
        metadata : Types.Emulation.PressureMetadata.t option;
            [@key "metadata"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enabled ~source ?metadata () = { enabled; source; metadata }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setPressureSourceOverrideEnabled";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Overrides a pressure source of a given type, as used by the Compute
Pressure API, so that updates to PressureObserver.observe() are provided
via setPressureStateOverride instead of being retrieved from
platform-provided telemetry data. |desc}]

  module SetPressureStateOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        source : Types.Emulation.PressureSource.t;
            [@key "source"] [@ocaml.doc "No description provided"]
        state : Types.Emulation.PressureState.t;
            [@key "state"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~source ~state () = { source; state }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setPressureStateOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|TODO: OBSOLETE: To remove when setPressureDataOverride is merged.
Provides a given pressure state that will be processed and eventually be
delivered to PressureObserver users. |source| must have been previously
overridden by setPressureSourceOverrideEnabled. |desc}]

  module SetPressureDataOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        source : Types.Emulation.PressureSource.t;
            [@key "source"] [@ocaml.doc "No description provided"]
        state : Types.Emulation.PressureState.t;
            [@key "state"] [@ocaml.doc "No description provided"]
        ownContributionEstimate : Types.number option;
            [@key "ownContributionEstimate"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~source ~state ?ownContributionEstimate () =
        { source; state; ownContributionEstimate }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setPressureDataOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Provides a given pressure data set that will be processed and eventually be
delivered to PressureObserver users. |source| must have been previously
overridden by setPressureSourceOverrideEnabled. |desc}]

  module SetIdleOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        isUserActive : bool;
            [@key "isUserActive"] [@ocaml.doc "Mock isUserActive"]
        isScreenUnlocked : bool;
            [@key "isScreenUnlocked"] [@ocaml.doc "Mock isScreenUnlocked"]
      }
      [@@deriving yojson]

      let make ~isUserActive ~isScreenUnlocked () =
        { isUserActive; isScreenUnlocked }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setIdleOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Overrides the Idle state. |desc}]

  module ClearIdleOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.clearIdleOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears Idle state overrides. |desc}]

  module SetNavigatorOverrides = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        platform : string;
            [@key "platform"]
            [@ocaml.doc "The platform navigator.platform should return."]
      }
      [@@deriving yojson]

      let make ~platform () = { platform }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setNavigatorOverrides"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Overrides value returned by the javascript navigator object. |desc}]

  module SetPageScaleFactor = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        pageScaleFactor : Types.number;
            [@key "pageScaleFactor"] [@ocaml.doc "Page scale factor."]
      }
      [@@deriving yojson]

      let make ~pageScaleFactor () = { pageScaleFactor }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setPageScaleFactor"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets a specified page scale factor. |desc}]

  module SetScriptExecutionDisabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        value : bool;
            [@key "value"]
            [@ocaml.doc
              "Whether script execution should be disabled in the page."]
      }
      [@@deriving yojson]

      let make ~value () = { value }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setScriptExecutionDisabled";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Switches script execution in the page. |desc}]

  module SetTouchEmulationEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc "Whether the touch event emulation should be enabled."]
        maxTouchPoints : Types.number option;
            [@key "maxTouchPoints"]
            [@yojson.option]
            [@ocaml.doc "Maximum touch points supported. Defaults to one."]
      }
      [@@deriving yojson]

      let make ~enabled ?maxTouchPoints () = { enabled; maxTouchPoints }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setTouchEmulationEnabled";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables touch on platforms which do not support them. |desc}]

  module SetVirtualTimePolicy = struct
    module Response : sig
      type result = {
        virtualTimeTicksBase : Types.number;
            [@key "virtualTimeTicksBase"]
            [@ocaml.doc
              "Absolute timestamp at which virtual time was first enabled (up \
               time in milliseconds)."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        virtualTimeTicksBase : Types.number;
            [@key "virtualTimeTicksBase"]
            [@ocaml.doc
              "Absolute timestamp at which virtual time was first enabled (up \
               time in milliseconds)."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        policy : Types.Emulation.VirtualTimePolicy.t;
            [@key "policy"] [@ocaml.doc "No description provided"]
        budget : Types.number option;
            [@key "budget"]
            [@yojson.option]
            [@ocaml.doc
              "If set, after this many virtual milliseconds have elapsed \
               virtual time will be paused and a\n\
               virtualTimeBudgetExpired event is sent."]
        maxVirtualTimeTaskStarvationCount : Types.number option;
            [@key "maxVirtualTimeTaskStarvationCount"]
            [@yojson.option]
            [@ocaml.doc
              "If set this specifies the maximum number of tasks that can be \
               run before virtual is forced\n\
               forwards to prevent deadlock."]
        initialVirtualTime : Types.Network.TimeSinceEpoch.t option;
            [@key "initialVirtualTime"]
            [@yojson.option]
            [@ocaml.doc
              "If set, base::Time::Now will be overridden to initially return \
               this value."]
      }
      [@@deriving yojson]

      let make ~policy ?budget ?maxVirtualTimeTaskStarvationCount
          ?initialVirtualTime () =
        {
          policy;
          budget;
          maxVirtualTimeTaskStarvationCount;
          initialVirtualTime;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setVirtualTimePolicy"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
the current virtual time policy.  Note this supersedes any previous time budget. |desc}]

  module SetLocaleOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        locale : string option;
            [@key "locale"]
            [@yojson.option]
            [@ocaml.doc
              "ICU style C locale (e.g. \"en_US\"). If not specified or empty, \
               disables the override and\n\
               restores default host system locale."]
      }
      [@@deriving yojson]

      let make ?locale () = { locale }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setLocaleOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Overrides default host system locale with the specified one. |desc}]

  module SetTimezoneOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        timezoneId : string;
            [@key "timezoneId"]
            [@ocaml.doc
              "The timezone identifier. List of supported timezones:\n\
               https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt\n\
               If empty, disables the override and restores default host \
               system timezone."]
      }
      [@@deriving yojson]

      let make ~timezoneId () = { timezoneId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setTimezoneOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Overrides default host system timezone with the specified one. |desc}]

  module SetVisibleSize = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        width : Types.number; [@key "width"] [@ocaml.doc "Frame width (DIP)."]
        height : Types.number; [@key "height"] [@ocaml.doc "Frame height (DIP)."]
      }
      [@@deriving yojson]

      let make ~width ~height () = { width; height }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setVisibleSize"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Resizes the frame/viewport of the page. Note that this does not affect the frame's container
(e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
on Android. |desc}]

  module SetDisabledImageTypes = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        imageTypes : Types.Emulation.DisabledImageType.t list;
            [@key "imageTypes"] [@ocaml.doc "Image types to disable."]
      }
      [@@deriving yojson]

      let make ~imageTypes () = { imageTypes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setDisabledImageTypes"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetDataSaverOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        dataSaverEnabled : bool option;
            [@key "dataSaverEnabled"]
            [@yojson.option]
            [@ocaml.doc
              "Override value. Omitting the parameter disables the override."]
      }
      [@@deriving yojson]

      let make ?dataSaverEnabled () = { dataSaverEnabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setDataSaverOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Override the value of navigator.connection.saveData |desc}]

  module SetHardwareConcurrencyOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        hardwareConcurrency : Types.number;
            [@key "hardwareConcurrency"]
            [@ocaml.doc "Hardware concurrency to report"]
      }
      [@@deriving yojson]

      let make ~hardwareConcurrency () = { hardwareConcurrency }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setHardwareConcurrencyOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetUserAgentOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        userAgent : string; [@key "userAgent"] [@ocaml.doc "User agent to use."]
        acceptLanguage : string option;
            [@key "acceptLanguage"]
            [@yojson.option]
            [@ocaml.doc "Browser language to emulate."]
        platform : string option;
            [@key "platform"]
            [@yojson.option]
            [@ocaml.doc "The platform navigator.platform should return."]
        userAgentMetadata : Types.Emulation.UserAgentMetadata.t option;
            [@key "userAgentMetadata"]
            [@yojson.option]
            [@ocaml.doc
              "To be sent in Sec-CH-UA-* headers and returned in \
               navigator.userAgentData"]
      }
      [@@deriving yojson]

      let make ~userAgent ?acceptLanguage ?platform ?userAgentMetadata () =
        { userAgent; acceptLanguage; platform; userAgentMetadata }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setUserAgentOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Allows overriding user agent with the given string.
`userAgentMetadata` must be set for Client Hint headers to be sent. |desc}]

  module SetAutomationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc "Whether the override should be enabled."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.setAutomationOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Allows overriding the automation flag. |desc}]

  module SetSmallViewportHeightDifferenceOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        difference : Types.number;
            [@key "difference"]
            [@ocaml.doc
              "This will cause an element of size 100svh to be `difference` \
               pixels smaller than an element\n\
               of size 100lvh."]
      }
      [@@deriving yojson]

      let make ~difference () = { difference }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Emulation.setSmallViewportHeightDifferenceOverride";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Allows overriding the difference between the small and large viewport sizes, which determine the
value of the `svh` and `lvh` unit, respectively. Only supported for top-level frames. |desc}]

  module GetScreenInfos = struct
    module Response : sig
      type result = {
        screenInfos : Types.Emulation.ScreenInfo.t list;
            [@key "screenInfos"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        screenInfos : Types.Emulation.ScreenInfo.t list;
            [@key "screenInfos"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Emulation.getScreenInfos"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns device's screen configuration. |desc}]

  module AddScreen = struct
    module Response : sig
      type result = {
        screenInfo : Types.Emulation.ScreenInfo.t;
            [@key "screenInfo"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        screenInfo : Types.Emulation.ScreenInfo.t;
            [@key "screenInfo"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        left : Types.number;
            [@key "left"]
            [@ocaml.doc "Offset of the left edge of the screen in pixels."]
        top : Types.number;
            [@key "top"]
            [@ocaml.doc "Offset of the top edge of the screen in pixels."]
        width : Types.number;
            [@key "width"] [@ocaml.doc "The width of the screen in pixels."]
        height : Types.number;
            [@key "height"] [@ocaml.doc "The height of the screen in pixels."]
        workAreaInsets : Types.Emulation.WorkAreaInsets.t option;
            [@key "workAreaInsets"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies the screen's work area. Default is entire screen."]
        devicePixelRatio : Types.number option;
            [@key "devicePixelRatio"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies the screen's device pixel ratio. Default is 1."]
        rotation : Types.number option;
            [@key "rotation"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies the screen's rotation angle. Available values are 0, \
               90, 180 and 270. Default is 0."]
        colorDepth : Types.number option;
            [@key "colorDepth"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies the screen's color depth in bits. Default is 24."]
        label : string option;
            [@key "label"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies the descriptive label for the screen. Default is none."]
        isInternal : bool option;
            [@key "isInternal"]
            [@yojson.option]
            [@ocaml.doc
              "Indicates whether the screen is internal to the device or \
               external, attached to the device. Default is false."]
      }
      [@@deriving yojson]

      let make ~left ~top ~width ~height ?workAreaInsets ?devicePixelRatio
          ?rotation ?colorDepth ?label ?isInternal () =
        {
          left;
          top;
          width;
          height;
          workAreaInsets;
          devicePixelRatio;
          rotation;
          colorDepth;
          label;
          isInternal;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.addScreen"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Add a new screen to the device. Only supported in headless mode. |desc}]

  module RemoveScreen = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        screenId : Types.Emulation.ScreenId.t;
            [@key "screenId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~screenId () = { screenId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Emulation.removeScreen"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Remove screen from the device. Only supported in headless mode. |desc}]
end

module EventBreakpoints = struct
  module SetInstrumentationBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventName : string;
            [@key "eventName"] [@ocaml.doc "Instrumentation name to stop on."]
      }
      [@@deriving yojson]

      let make ~eventName () = { eventName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "EventBreakpoints.setInstrumentationBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets breakpoint on particular native event. |desc}]

  module RemoveInstrumentationBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventName : string;
            [@key "eventName"] [@ocaml.doc "Instrumentation name to stop on."]
      }
      [@@deriving yojson]

      let make ~eventName () = { eventName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "EventBreakpoints.removeInstrumentationBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Removes breakpoint on particular native event. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "EventBreakpoints.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Removes all breakpoints |desc}]
end

module Extensions = struct
  module LoadUnpacked = struct
    module Response : sig
      type result = { id : string [@key "id"] [@ocaml.doc "Extension id."] }
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = { id : string [@key "id"] [@ocaml.doc "Extension id."] }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        path : string; [@key "path"] [@ocaml.doc "Absolute file path."]
      }
      [@@deriving yojson]

      let make ~path () = { path }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Extensions.loadUnpacked"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Installs an unpacked extension from the filesystem similar to
--load-extension CLI flags. Returns extension ID once the extension
has been installed. Available if the client is connected using the
--remote-debugging-pipe flag and the --enable-unsafe-extension-debugging
flag is set. |desc}]

  module Uninstall = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = { id : string [@key "id"] [@ocaml.doc "Extension id."] }
      [@@deriving yojson]

      let make ~id () = { id }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Extensions.uninstall"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Uninstalls an unpacked extension (others not supported) from the profile.
Available if the client is connected using the --remote-debugging-pipe flag
and the --enable-unsafe-extension-debugging. |desc}]

  module GetStorageItems = struct
    module Response : sig
      type result = {
        data : Types.assoc; [@key "data"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        data : Types.assoc; [@key "data"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        id : string; [@key "id"] [@ocaml.doc "ID of extension."]
        storageArea : Types.Extensions.StorageArea.t;
            [@key "storageArea"]
            [@ocaml.doc "StorageArea to retrieve data from."]
        keys : string list option;
            [@key "keys"] [@yojson.option] [@ocaml.doc "Keys to retrieve."]
      }
      [@@deriving yojson]

      let make ~id ~storageArea ?keys () = { id; storageArea; keys }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Extensions.getStorageItems"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Gets data from extension storage in the given `storageArea`. If `keys` is
specified, these are used to filter the result. |desc}]

  module RemoveStorageItems = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        id : string; [@key "id"] [@ocaml.doc "ID of extension."]
        storageArea : Types.Extensions.StorageArea.t;
            [@key "storageArea"] [@ocaml.doc "StorageArea to remove data from."]
        keys : string list; [@key "keys"] [@ocaml.doc "Keys to remove."]
      }
      [@@deriving yojson]

      let make ~id ~storageArea ~keys () = { id; storageArea; keys }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Extensions.removeStorageItems"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Removes `keys` from extension storage in the given `storageArea`. |desc}]

  module ClearStorageItems = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        id : string; [@key "id"] [@ocaml.doc "ID of extension."]
        storageArea : Types.Extensions.StorageArea.t;
            [@key "storageArea"] [@ocaml.doc "StorageArea to remove data from."]
      }
      [@@deriving yojson]

      let make ~id ~storageArea () = { id; storageArea }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Extensions.clearStorageItems"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Clears extension storage in the given `storageArea`. |desc}]

  module SetStorageItems = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        id : string; [@key "id"] [@ocaml.doc "ID of extension."]
        storageArea : Types.Extensions.StorageArea.t;
            [@key "storageArea"] [@ocaml.doc "StorageArea to set data in."]
        values : Types.assoc; [@key "values"] [@ocaml.doc "Values to set."]
      }
      [@@deriving yojson]

      let make ~id ~storageArea ~values () = { id; storageArea; values }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Extensions.setStorageItems"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets `values` in extension storage in the given `storageArea`. The provided `values`
will be merged with existing values in the storage area. |desc}]
end

module FedCm = struct
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        disableRejectionDelay : bool option;
            [@key "disableRejectionDelay"]
            [@yojson.option]
            [@ocaml.doc
              "Allows callers to disable the promise rejection delay that would\n\
               normally happen, if this is unimportant to what's being tested.\n\
               (step 4 of \
               https://fedidcg.github.io/FedCM/#browser-api-rp-sign-in)"]
      }
      [@@deriving yojson]

      let make ?disableRejectionDelay () = { disableRejectionDelay }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "FedCm.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "FedCm.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SelectAccount = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        dialogId : string;
            [@key "dialogId"] [@ocaml.doc "No description provided"]
        accountIndex : Types.number;
            [@key "accountIndex"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~dialogId ~accountIndex () = { dialogId; accountIndex }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "FedCm.selectAccount"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module ClickDialogButton = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        dialogId : string;
            [@key "dialogId"] [@ocaml.doc "No description provided"]
        dialogButton : Types.FedCm.DialogButton.t;
            [@key "dialogButton"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~dialogId ~dialogButton () = { dialogId; dialogButton }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "FedCm.clickDialogButton"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module OpenUrl = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        dialogId : string;
            [@key "dialogId"] [@ocaml.doc "No description provided"]
        accountIndex : Types.number;
            [@key "accountIndex"] [@ocaml.doc "No description provided"]
        accountUrlType : Types.FedCm.AccountUrlType.t;
            [@key "accountUrlType"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~dialogId ~accountIndex ~accountUrlType () =
        { dialogId; accountIndex; accountUrlType }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "FedCm.openUrl"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module DismissDialog = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        dialogId : string;
            [@key "dialogId"] [@ocaml.doc "No description provided"]
        triggerCooldown : bool option;
            [@key "triggerCooldown"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~dialogId ?triggerCooldown () = { dialogId; triggerCooldown }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "FedCm.dismissDialog"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module ResetCooldown = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "FedCm.resetCooldown"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Resets the cooldown time, if any, to allow the next FedCM call to show
a dialog even if one was recently dismissed by the user. |desc}]
end

module Fetch = struct
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Fetch.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables the fetch domain. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        patterns : Types.Fetch.RequestPattern.t list option;
            [@key "patterns"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, only requests matching any of these patterns will \
               produce\n\
               fetchRequested event and will be paused until clients response. \
               If not set,\n\
               all requests will be affected."]
        handleAuthRequests : bool option;
            [@key "handleAuthRequests"]
            [@yojson.option]
            [@ocaml.doc
              "If true, authRequired events will be issued and requests will \
               be paused\n\
               expecting a call to continueWithAuth."]
      }
      [@@deriving yojson]

      let make ?patterns ?handleAuthRequests () =
        { patterns; handleAuthRequests }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables issuing of requestPaused events. A request will be paused until client
calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth. |desc}]

  module FailRequest = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "An id the client received in requestPaused event."]
        errorReason : Types.Network.ErrorReason.t;
            [@key "errorReason"]
            [@ocaml.doc "Causes the request to fail with the given reason."]
      }
      [@@deriving yojson]

      let make ~requestId ~errorReason () = { requestId; errorReason }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.failRequest"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Causes the request to fail with specified reason. |desc}]

  module FulfillRequest = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "An id the client received in requestPaused event."]
        responseCode : Types.number;
            [@key "responseCode"] [@ocaml.doc "An HTTP response code."]
        responseHeaders : Types.Fetch.HeaderEntry.t list option;
            [@key "responseHeaders"]
            [@yojson.option]
            [@ocaml.doc "Response headers."]
        binaryResponseHeaders : string option;
            [@key "binaryResponseHeaders"]
            [@yojson.option]
            [@ocaml.doc
              "Alternative way of specifying response headers as a \\0-separated\n\
               series of name: value pairs. Prefer the above method unless you\n\
               need to represent some non-UTF8 values that can't be transmitted\n\
               over the protocol as text. (Encoded as a base64 string when \
               passed over JSON)"]
        body : string option;
            [@key "body"]
            [@yojson.option]
            [@ocaml.doc
              "A response body. If absent, original response body will be used \
               if\n\
               the request is intercepted at the response stage and empty body\n\
               will be used if the request is intercepted at the request \
               stage. (Encoded as a base64 string when passed over JSON)"]
        responsePhrase : string option;
            [@key "responsePhrase"]
            [@yojson.option]
            [@ocaml.doc
              "A textual representation of responseCode.\n\
               If absent, a standard phrase matching responseCode is used."]
      }
      [@@deriving yojson]

      let make ~requestId ~responseCode ?responseHeaders ?binaryResponseHeaders
          ?body ?responsePhrase () =
        {
          requestId;
          responseCode;
          responseHeaders;
          binaryResponseHeaders;
          body;
          responsePhrase;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.fulfillRequest"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Provides response to the request. |desc}]

  module ContinueRequest = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "An id the client received in requestPaused event."]
        url : string option;
            [@key "url"]
            [@yojson.option]
            [@ocaml.doc
              "If set, the request url will be modified in a way that's not \
               observable by page."]
        method_ : string option;
            [@key "method"]
            [@yojson.option]
            [@ocaml.doc "If set, the request method is overridden."]
        postData : string option;
            [@key "postData"]
            [@yojson.option]
            [@ocaml.doc
              "If set, overrides the post data in the request. (Encoded as a \
               base64 string when passed over JSON)"]
        headers : Types.Fetch.HeaderEntry.t list option;
            [@key "headers"]
            [@yojson.option]
            [@ocaml.doc
              "If set, overrides the request headers. Note that the overrides \
               do not\n\
               extend to subsequent redirect hops, if a redirect happens. \
               Another override\n\
               may be applied to a different request produced by a redirect."]
        interceptResponse : bool option;
            [@key "interceptResponse"]
            [@yojson.option]
            [@ocaml.doc
              "If set, overrides response interception behavior for this \
               request."]
      }
      [@@deriving yojson]

      let make ~requestId ?url ?method_ ?postData ?headers ?interceptResponse ()
          =
        { requestId; url; method_; postData; headers; interceptResponse }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.continueRequest"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Continues the request, optionally modifying some of its parameters. |desc}]

  module ContinueWithAuth = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "An id the client received in authRequired event."]
        authChallengeResponse : Types.Fetch.AuthChallengeResponse.t;
            [@key "authChallengeResponse"]
            [@ocaml.doc "Response to  with an authChallenge."]
      }
      [@@deriving yojson]

      let make ~requestId ~authChallengeResponse () =
        { requestId; authChallengeResponse }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.continueWithAuth"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Continues a request supplying authChallengeResponse following authRequired event. |desc}]

  module ContinueResponse = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "An id the client received in requestPaused event."]
        responseCode : Types.number option;
            [@key "responseCode"]
            [@yojson.option]
            [@ocaml.doc
              "An HTTP response code. If absent, original response code will \
               be used."]
        responsePhrase : string option;
            [@key "responsePhrase"]
            [@yojson.option]
            [@ocaml.doc
              "A textual representation of responseCode.\n\
               If absent, a standard phrase matching responseCode is used."]
        responseHeaders : Types.Fetch.HeaderEntry.t list option;
            [@key "responseHeaders"]
            [@yojson.option]
            [@ocaml.doc
              "Response headers. If absent, original response headers will be \
               used."]
        binaryResponseHeaders : string option;
            [@key "binaryResponseHeaders"]
            [@yojson.option]
            [@ocaml.doc
              "Alternative way of specifying response headers as a \\0-separated\n\
               series of name: value pairs. Prefer the above method unless you\n\
               need to represent some non-UTF8 values that can't be transmitted\n\
               over the protocol as text. (Encoded as a base64 string when \
               passed over JSON)"]
      }
      [@@deriving yojson]

      let make ~requestId ?responseCode ?responsePhrase ?responseHeaders
          ?binaryResponseHeaders () =
        {
          requestId;
          responseCode;
          responsePhrase;
          responseHeaders;
          binaryResponseHeaders;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.continueResponse"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Continues loading of the paused response, optionally modifying the
response headers. If either responseCode or headers are modified, all of them
must be present. |desc}]

  module GetResponseBody = struct
    module Response : sig
      type result = {
        body : string; [@key "body"] [@ocaml.doc "Response body."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        body : string; [@key "body"] [@ocaml.doc "Response body."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc
              "Identifier for the intercepted request to get body for."]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.getResponseBody"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Causes the body of the response to be received from the server and
returned as a single string. May only be issued for a request that
is paused in the Response stage and is mutually exclusive with
takeResponseBodyForInterceptionAsStream. Calling other methods that
affect the request or disabling fetch domain before body is received
results in an undefined behavior.
Note that the response body is not available for redirects. Requests
paused in the _redirect received_ state may be differentiated by
`responseCode` and presence of `location` response header, see
comments to `requestPaused` for details. |desc}]

  module TakeResponseBodyAsStream = struct
    module Response : sig
      type result = {
        stream : Types.IO.StreamHandle.t;
            [@key "stream"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        stream : Types.IO.StreamHandle.t;
            [@key "stream"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Fetch.RequestId.t;
            [@key "requestId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Fetch.takeResponseBodyAsStream"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns a handle to the stream representing the response body.
The request must be paused in the HeadersReceived stage.
Note that after this command the request can't be continued
as is -- client either needs to cancel it or to provide the
response body.
The stream only supports sequential read, IO.read will fail if the position
is specified.
This method is mutually exclusive with getResponseBody.
Calling other methods that affect the request or disabling fetch
domain before body is received results in an undefined behavior. |desc}]
end

module FileSystem = struct
  module GetDirectory = struct
    module Response : sig
      type result = {
        directory : Types.FileSystem.Directory.t;
            [@key "directory"]
            [@ocaml.doc "Returns the directory object at the path."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        directory : Types.FileSystem.Directory.t;
            [@key "directory"]
            [@ocaml.doc "Returns the directory object at the path."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        bucketFileSystemLocator : Types.FileSystem.BucketFileSystemLocator.t;
            [@key "bucketFileSystemLocator"]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~bucketFileSystemLocator () = { bucketFileSystemLocator }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "FileSystem.getDirectory"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]
end

module HeadlessExperimental = struct
  module BeginFrame = struct
    module Response : sig
      type result = {
        hasDamage : bool;
            [@key "hasDamage"]
            [@ocaml.doc
              "Whether the BeginFrame resulted in damage and, thus, a new \
               frame was committed to the\n\
               display. Reported for diagnostic uses, may be removed in the \
               future."]
        screenshotData : string option;
            [@key "screenshotData"]
            [@yojson.option]
            [@ocaml.doc
              "Base64-encoded image data of the screenshot, if one was \
               requested and successfully taken. (Encoded as a base64 string \
               when passed over JSON)"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        hasDamage : bool;
            [@key "hasDamage"]
            [@ocaml.doc
              "Whether the BeginFrame resulted in damage and, thus, a new \
               frame was committed to the\n\
               display. Reported for diagnostic uses, may be removed in the \
               future."]
        screenshotData : string option;
            [@key "screenshotData"]
            [@yojson.option]
            [@ocaml.doc
              "Base64-encoded image data of the screenshot, if one was \
               requested and successfully taken. (Encoded as a base64 string \
               when passed over JSON)"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameTimeTicks : Types.number option;
            [@key "frameTimeTicks"]
            [@yojson.option]
            [@ocaml.doc
              "Timestamp of this BeginFrame in Renderer TimeTicks \
               (milliseconds of uptime). If not set,\n\
               the current time will be used."]
        interval : Types.number option;
            [@key "interval"]
            [@yojson.option]
            [@ocaml.doc
              "The interval between BeginFrames that is reported to the \
               compositor, in milliseconds.\n\
               Defaults to a 60 frames/second interval, i.e. about 16.666 \
               milliseconds."]
        noDisplayUpdates : bool option;
            [@key "noDisplayUpdates"]
            [@yojson.option]
            [@ocaml.doc
              "Whether updates should not be committed and drawn onto the \
               display. False by default. If\n\
               true, only side effects of the BeginFrame will be run, such as \
               layout and animations, but\n\
               any visual updates may not be visible on the display or in \
               screenshots."]
        screenshot : Types.HeadlessExperimental.ScreenshotParams.t option;
            [@key "screenshot"]
            [@yojson.option]
            [@ocaml.doc
              "If set, a screenshot of the frame will be captured and returned \
               in the response. Otherwise,\n\
               no screenshot will be captured. Note that capturing a \
               screenshot can fail, for example,\n\
               during renderer initialization. In such a case, no screenshot \
               data will be returned."]
      }
      [@@deriving yojson]

      let make ?frameTimeTicks ?interval ?noDisplayUpdates ?screenshot () =
        { frameTimeTicks; interval; noDisplayUpdates; screenshot }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "HeadlessExperimental.beginFrame"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
screenshot from the resulting frame. Requires that the target was created with enabled
BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
https://goo.gle/chrome-headless-rendering for more background. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeadlessExperimental.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables headless events for the target. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeadlessExperimental.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables headless events for the target. |desc}]
end

module IO = struct
  module Close = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        handle : Types.IO.StreamHandle.t;
            [@key "handle"] [@ocaml.doc "Handle of the stream to close."]
      }
      [@@deriving yojson]

      let make ~handle () = { handle }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IO.close"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Close the stream, discard any temporary backing storage. |desc}]

  module Read = struct
    module Response : sig
      type result = {
        base64Encoded : bool option;
            [@key "base64Encoded"]
            [@yojson.option]
            [@ocaml.doc "Set if the data is base64-encoded"]
        data : string; [@key "data"] [@ocaml.doc "Data that were read."]
        eof : bool;
            [@key "eof"]
            [@ocaml.doc
              "Set if the end-of-file condition occurred while reading."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        base64Encoded : bool option;
            [@key "base64Encoded"]
            [@yojson.option]
            [@ocaml.doc "Set if the data is base64-encoded"]
        data : string; [@key "data"] [@ocaml.doc "Data that were read."]
        eof : bool;
            [@key "eof"]
            [@ocaml.doc
              "Set if the end-of-file condition occurred while reading."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        handle : Types.IO.StreamHandle.t;
            [@key "handle"] [@ocaml.doc "Handle of the stream to read."]
        offset : Types.number option;
            [@key "offset"]
            [@yojson.option]
            [@ocaml.doc
              "Seek to the specified offset before reading (if not specified, \
               proceed with offset\n\
               following the last read). Some types of streams may only \
               support sequential reads."]
        size : Types.number option;
            [@key "size"]
            [@yojson.option]
            [@ocaml.doc
              "Maximum number of bytes to read (left upon the agent discretion \
               if not specified)."]
      }
      [@@deriving yojson]

      let make ~handle ?offset ?size () = { handle; offset; size }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IO.read"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Read a chunk of the stream |desc}]

  module ResolveBlob = struct
    module Response : sig
      type result = {
        uuid : string; [@key "uuid"] [@ocaml.doc "UUID of the specified Blob."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        uuid : string; [@key "uuid"] [@ocaml.doc "UUID of the specified Blob."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"] [@ocaml.doc "Object id of a Blob object wrapper."]
      }
      [@@deriving yojson]

      let make ~objectId () = { objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IO.resolveBlob"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Return UUID of Blob object specified by a remote object id. |desc}]
end

module IndexedDB = struct
  module ClearObjectStore = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey, or \
               storageBucket must be specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        storageBucket : Types.Storage.StorageBucket.t option;
            [@key "storageBucket"]
            [@yojson.option]
            [@ocaml.doc
              "Storage bucket. If not specified, it uses the default bucket."]
        databaseName : string;
            [@key "databaseName"] [@ocaml.doc "Database name."]
        objectStoreName : string;
            [@key "objectStoreName"] [@ocaml.doc "Object store name."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ?storageBucket ~databaseName
          ~objectStoreName () =
        {
          securityOrigin;
          storageKey;
          storageBucket;
          databaseName;
          objectStoreName;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IndexedDB.clearObjectStore"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears all entries from an object store. |desc}]

  module DeleteDatabase = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey, or \
               storageBucket must be specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        storageBucket : Types.Storage.StorageBucket.t option;
            [@key "storageBucket"]
            [@yojson.option]
            [@ocaml.doc
              "Storage bucket. If not specified, it uses the default bucket."]
        databaseName : string;
            [@key "databaseName"] [@ocaml.doc "Database name."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ?storageBucket ~databaseName () =
        { securityOrigin; storageKey; storageBucket; databaseName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IndexedDB.deleteDatabase"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Deletes a database. |desc}]

  module DeleteObjectStoreEntries = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey, or \
               storageBucket must be specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        storageBucket : Types.Storage.StorageBucket.t option;
            [@key "storageBucket"]
            [@yojson.option]
            [@ocaml.doc
              "Storage bucket. If not specified, it uses the default bucket."]
        databaseName : string;
            [@key "databaseName"] [@ocaml.doc "No description provided"]
        objectStoreName : string;
            [@key "objectStoreName"] [@ocaml.doc "No description provided"]
        keyRange : Types.IndexedDB.KeyRange.t;
            [@key "keyRange"] [@ocaml.doc "Range of entry keys to delete"]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ?storageBucket ~databaseName
          ~objectStoreName ~keyRange () =
        {
          securityOrigin;
          storageKey;
          storageBucket;
          databaseName;
          objectStoreName;
          keyRange;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "IndexedDB.deleteObjectStoreEntries";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Delete a range of entries from an object store |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "IndexedDB.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables events from backend. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "IndexedDB.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables events from backend. |desc}]

  module RequestData = struct
    module Response : sig
      type result = {
        objectStoreDataEntries : Types.IndexedDB.DataEntry.t list;
            [@key "objectStoreDataEntries"]
            [@ocaml.doc "Array of object store data entries."]
        hasMore : bool;
            [@key "hasMore"]
            [@ocaml.doc
              "If true, there are more entries to fetch in the given range."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        objectStoreDataEntries : Types.IndexedDB.DataEntry.t list;
            [@key "objectStoreDataEntries"]
            [@ocaml.doc "Array of object store data entries."]
        hasMore : bool;
            [@key "hasMore"]
            [@ocaml.doc
              "If true, there are more entries to fetch in the given range."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey, or \
               storageBucket must be specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        storageBucket : Types.Storage.StorageBucket.t option;
            [@key "storageBucket"]
            [@yojson.option]
            [@ocaml.doc
              "Storage bucket. If not specified, it uses the default bucket."]
        databaseName : string;
            [@key "databaseName"] [@ocaml.doc "Database name."]
        objectStoreName : string;
            [@key "objectStoreName"] [@ocaml.doc "Object store name."]
        indexName : string option;
            [@key "indexName"]
            [@yojson.option]
            [@ocaml.doc
              "Index name. If not specified, it performs an object store data \
               request."]
        skipCount : Types.number;
            [@key "skipCount"] [@ocaml.doc "Number of records to skip."]
        pageSize : Types.number;
            [@key "pageSize"] [@ocaml.doc "Number of records to fetch."]
        keyRange : Types.IndexedDB.KeyRange.t option;
            [@key "keyRange"] [@yojson.option] [@ocaml.doc "Key range."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ?storageBucket ~databaseName
          ~objectStoreName ?indexName ~skipCount ~pageSize ?keyRange () =
        {
          securityOrigin;
          storageKey;
          storageBucket;
          databaseName;
          objectStoreName;
          indexName;
          skipCount;
          pageSize;
          keyRange;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IndexedDB.requestData"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Requests data from object store or index. |desc}]

  module GetMetadata = struct
    module Response : sig
      type result = {
        entriesCount : Types.number;
            [@key "entriesCount"] [@ocaml.doc "the entries count"]
        keyGeneratorValue : Types.number;
            [@key "keyGeneratorValue"]
            [@ocaml.doc
              "the current value of key generator, to become the next inserted\n\
               key into the object store. Valid if objectStore.autoIncrement\n\
               is true."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        entriesCount : Types.number;
            [@key "entriesCount"] [@ocaml.doc "the entries count"]
        keyGeneratorValue : Types.number;
            [@key "keyGeneratorValue"]
            [@ocaml.doc
              "the current value of key generator, to become the next inserted\n\
               key into the object store. Valid if objectStore.autoIncrement\n\
               is true."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey, or \
               storageBucket must be specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        storageBucket : Types.Storage.StorageBucket.t option;
            [@key "storageBucket"]
            [@yojson.option]
            [@ocaml.doc
              "Storage bucket. If not specified, it uses the default bucket."]
        databaseName : string;
            [@key "databaseName"] [@ocaml.doc "Database name."]
        objectStoreName : string;
            [@key "objectStoreName"] [@ocaml.doc "Object store name."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ?storageBucket ~databaseName
          ~objectStoreName () =
        {
          securityOrigin;
          storageKey;
          storageBucket;
          databaseName;
          objectStoreName;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IndexedDB.getMetadata"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Gets metadata of an object store. |desc}]

  module RequestDatabase = struct
    module Response : sig
      type result = {
        databaseWithObjectStores : Types.IndexedDB.DatabaseWithObjectStores.t;
            [@key "databaseWithObjectStores"]
            [@ocaml.doc "Database with an array of object stores."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        databaseWithObjectStores : Types.IndexedDB.DatabaseWithObjectStores.t;
            [@key "databaseWithObjectStores"]
            [@ocaml.doc "Database with an array of object stores."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey, or \
               storageBucket must be specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        storageBucket : Types.Storage.StorageBucket.t option;
            [@key "storageBucket"]
            [@yojson.option]
            [@ocaml.doc
              "Storage bucket. If not specified, it uses the default bucket."]
        databaseName : string;
            [@key "databaseName"] [@ocaml.doc "Database name."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ?storageBucket ~databaseName () =
        { securityOrigin; storageKey; storageBucket; databaseName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IndexedDB.requestDatabase"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Requests database with given name in given frame. |desc}]

  module RequestDatabaseNames = struct
    module Response : sig
      type result = {
        databaseNames : string list;
            [@key "databaseNames"] [@ocaml.doc "Database names for origin."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        databaseNames : string list;
            [@key "databaseNames"] [@ocaml.doc "Database names for origin."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        securityOrigin : string option;
            [@key "securityOrigin"]
            [@yojson.option]
            [@ocaml.doc
              "At least and at most one of securityOrigin, storageKey, or \
               storageBucket must be specified.\n\
               Security origin."]
        storageKey : string option;
            [@key "storageKey"] [@yojson.option] [@ocaml.doc "Storage key."]
        storageBucket : Types.Storage.StorageBucket.t option;
            [@key "storageBucket"]
            [@yojson.option]
            [@ocaml.doc
              "Storage bucket. If not specified, it uses the default bucket."]
      }
      [@@deriving yojson]

      let make ?securityOrigin ?storageKey ?storageBucket () =
        { securityOrigin; storageKey; storageBucket }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "IndexedDB.requestDatabaseNames"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Requests database names for given security origin. |desc}]
end

module Input = struct
  module DispatchDragEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type dispatchdragevent_type =
        [ `dragEnter | `dragOver | `drop | `dragCancel ]

      let dispatchdragevent_type_of_yojson = function
        | `String "dragEnter" -> `dragEnter
        | `String "dragOver" -> `dragOver
        | `String "drop" -> `drop
        | `String "dragCancel" -> `dragCancel
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_dispatchdragevent_type = function
        | `dragEnter -> `String "dragEnter"
        | `dragOver -> `String "dragOver"
        | `drop -> `String "drop"
        | `dragCancel -> `String "dragCancel"

      type t = {
        type_ : dispatchdragevent_type;
            [@key "type"] [@ocaml.doc "Type of the drag event."]
        x : Types.number;
            [@key "x"]
            [@ocaml.doc
              "X coordinate of the event relative to the main frame's viewport \
               in CSS pixels."]
        y : Types.number;
            [@key "y"]
            [@ocaml.doc
              "Y coordinate of the event relative to the main frame's viewport \
               in CSS pixels. 0 refers to\n\
               the top of the viewport and Y increases as it proceeds towards \
               the bottom of the viewport."]
        data : Types.Input.DragData.t;
            [@key "data"] [@ocaml.doc "No description provided"]
        modifiers : Types.number option;
            [@key "modifiers"]
            [@yojson.option]
            [@ocaml.doc
              "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, \
               Meta/Command=4, Shift=8\n\
               (default: 0)."]
      }
      [@@deriving yojson]

      let make ~type_ ~x ~y ~data ?modifiers () =
        { type_; x; y; data; modifiers }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.dispatchDragEvent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Dispatches a drag event into the page. |desc}]

  module DispatchKeyEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type dispatchkeyevent_type = [ `keyDown | `keyUp | `rawKeyDown | `char ]

      let dispatchkeyevent_type_of_yojson = function
        | `String "keyDown" -> `keyDown
        | `String "keyUp" -> `keyUp
        | `String "rawKeyDown" -> `rawKeyDown
        | `String "char" -> `char
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_dispatchkeyevent_type = function
        | `keyDown -> `String "keyDown"
        | `keyUp -> `String "keyUp"
        | `rawKeyDown -> `String "rawKeyDown"
        | `char -> `String "char"

      type t = {
        type_ : dispatchkeyevent_type;
            [@key "type"] [@ocaml.doc "Type of the key event."]
        modifiers : Types.number option;
            [@key "modifiers"]
            [@yojson.option]
            [@ocaml.doc
              "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, \
               Meta/Command=4, Shift=8\n\
               (default: 0)."]
        timestamp : Types.Input.TimeSinceEpoch.t option;
            [@key "timestamp"]
            [@yojson.option]
            [@ocaml.doc "Time at which the event occurred."]
        text : string option;
            [@key "text"]
            [@yojson.option]
            [@ocaml.doc
              "Text as generated by processing a virtual key code with a \
               keyboard layout. Not needed for\n\
               for `keyUp` and `rawKeyDown` events (default: \"\")"]
        unmodifiedText : string option;
            [@key "unmodifiedText"]
            [@yojson.option]
            [@ocaml.doc
              "Text that would have been generated by the keyboard if no \
               modifiers were pressed (except for\n\
               shift). Useful for shortcut (accelerator) key handling \
               (default: \"\")."]
        keyIdentifier : string option;
            [@key "keyIdentifier"]
            [@yojson.option]
            [@ocaml.doc
              "Unique key identifier (e.g., 'U+0041') (default: \"\")."]
        code : string option;
            [@key "code"]
            [@yojson.option]
            [@ocaml.doc
              "Unique DOM defined string value for each physical key (e.g., \
               'KeyA') (default: \"\")."]
        key : string option;
            [@key "key"]
            [@yojson.option]
            [@ocaml.doc
              "Unique DOM defined string value describing the meaning of the \
               key in the context of active\n\
               modifiers, keyboard layout, etc (e.g., 'AltGr') (default: \"\")."]
        windowsVirtualKeyCode : Types.number option;
            [@key "windowsVirtualKeyCode"]
            [@yojson.option]
            [@ocaml.doc "Windows virtual key code (default: 0)."]
        nativeVirtualKeyCode : Types.number option;
            [@key "nativeVirtualKeyCode"]
            [@yojson.option]
            [@ocaml.doc "Native virtual key code (default: 0)."]
        autoRepeat : bool option;
            [@key "autoRepeat"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the event was generated from auto repeat (default: \
               false)."]
        isKeypad : bool option;
            [@key "isKeypad"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the event was generated from the keypad (default: \
               false)."]
        isSystemKey : bool option;
            [@key "isSystemKey"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the event was a system key event (default: false)."]
        location : Types.number option;
            [@key "location"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the event was from the left or right side of the \
               keyboard. 1=Left, 2=Right (default:\n\
               0)."]
        commands : string list option;
            [@key "commands"]
            [@yojson.option]
            [@ocaml.doc
              "Editing commands to send with the key event (e.g., 'selectAll') \
               (default: []).\n\
               These are related to but not equal the command names used in \
               `document.execCommand` and NSStandardKeyBindingResponding.\n\
               See \
               https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h \
               for valid command names."]
      }
      [@@deriving yojson]

      let make ~type_ ?modifiers ?timestamp ?text ?unmodifiedText ?keyIdentifier
          ?code ?key ?windowsVirtualKeyCode ?nativeVirtualKeyCode ?autoRepeat
          ?isKeypad ?isSystemKey ?location ?commands () =
        {
          type_;
          modifiers;
          timestamp;
          text;
          unmodifiedText;
          keyIdentifier;
          code;
          key;
          windowsVirtualKeyCode;
          nativeVirtualKeyCode;
          autoRepeat;
          isKeypad;
          isSystemKey;
          location;
          commands;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.dispatchKeyEvent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Dispatches a key event to the page. |desc}]

  module InsertText = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        text : string; [@key "text"] [@ocaml.doc "The text to insert."]
      }
      [@@deriving yojson]

      let make ~text () = { text }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.insertText"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|This method emulates inserting text that doesn't come from a key press,
for example an emoji keyboard or an IME. |desc}]

  module ImeSetComposition = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        text : string; [@key "text"] [@ocaml.doc "The text to insert"]
        selectionStart : Types.number;
            [@key "selectionStart"] [@ocaml.doc "selection start"]
        selectionEnd : Types.number;
            [@key "selectionEnd"] [@ocaml.doc "selection end"]
        replacementStart : Types.number option;
            [@key "replacementStart"]
            [@yojson.option]
            [@ocaml.doc "replacement start"]
        replacementEnd : Types.number option;
            [@key "replacementEnd"]
            [@yojson.option]
            [@ocaml.doc "replacement end"]
      }
      [@@deriving yojson]

      let make ~text ~selectionStart ~selectionEnd ?replacementStart
          ?replacementEnd () =
        { text; selectionStart; selectionEnd; replacementStart; replacementEnd }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.imeSetComposition"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|This method sets the current candidate text for IME.
Use imeCommitComposition to commit the final text.
Use imeSetComposition with empty string as text to cancel composition. |desc}]

  module DispatchMouseEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type dispatchmouseevent_type =
        [ `mousePressed | `mouseReleased | `mouseMoved | `mouseWheel ]

      let dispatchmouseevent_type_of_yojson = function
        | `String "mousePressed" -> `mousePressed
        | `String "mouseReleased" -> `mouseReleased
        | `String "mouseMoved" -> `mouseMoved
        | `String "mouseWheel" -> `mouseWheel
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_dispatchmouseevent_type = function
        | `mousePressed -> `String "mousePressed"
        | `mouseReleased -> `String "mouseReleased"
        | `mouseMoved -> `String "mouseMoved"
        | `mouseWheel -> `String "mouseWheel"

      type dispatchmouseevent_pointertype = [ `mouse | `pen ]

      let dispatchmouseevent_pointertype_of_yojson = function
        | `String "mouse" -> `mouse
        | `String "pen" -> `pen
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_dispatchmouseevent_pointertype = function
        | `mouse -> `String "mouse"
        | `pen -> `String "pen"

      type t = {
        type_ : dispatchmouseevent_type;
            [@key "type"] [@ocaml.doc "Type of the mouse event."]
        x : Types.number;
            [@key "x"]
            [@ocaml.doc
              "X coordinate of the event relative to the main frame's viewport \
               in CSS pixels."]
        y : Types.number;
            [@key "y"]
            [@ocaml.doc
              "Y coordinate of the event relative to the main frame's viewport \
               in CSS pixels. 0 refers to\n\
               the top of the viewport and Y increases as it proceeds towards \
               the bottom of the viewport."]
        modifiers : Types.number option;
            [@key "modifiers"]
            [@yojson.option]
            [@ocaml.doc
              "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, \
               Meta/Command=4, Shift=8\n\
               (default: 0)."]
        timestamp : Types.Input.TimeSinceEpoch.t option;
            [@key "timestamp"]
            [@yojson.option]
            [@ocaml.doc "Time at which the event occurred."]
        button : Types.Input.MouseButton.t option;
            [@key "button"]
            [@yojson.option]
            [@ocaml.doc "Mouse button (default: \"none\")."]
        buttons : Types.number option;
            [@key "buttons"]
            [@yojson.option]
            [@ocaml.doc
              "A number indicating which buttons are pressed on the mouse when \
               a mouse event is triggered.\n\
               Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0."]
        clickCount : Types.number option;
            [@key "clickCount"]
            [@yojson.option]
            [@ocaml.doc
              "Number of times the mouse button was clicked (default: 0)."]
        force : Types.number option;
            [@key "force"]
            [@yojson.option]
            [@ocaml.doc
              "The normalized pressure, which has a range of [0,1] (default: \
               0)."]
        tangentialPressure : Types.number option;
            [@key "tangentialPressure"]
            [@yojson.option]
            [@ocaml.doc
              "The normalized tangential pressure, which has a range of [-1,1] \
               (default: 0)."]
        tiltX : Types.number option;
            [@key "tiltX"]
            [@yojson.option]
            [@ocaml.doc
              "The plane angle between the Y-Z plane and the plane containing \
               both the stylus axis and the Y axis, in degrees of the range \
               [-90,90], a positive tiltX is to the right (default: 0)."]
        tiltY : Types.number option;
            [@key "tiltY"]
            [@yojson.option]
            [@ocaml.doc
              "The plane angle between the X-Z plane and the plane containing \
               both the stylus axis and the X axis, in degrees of the range \
               [-90,90], a positive tiltY is towards the user (default: 0)."]
        twist : Types.number option;
            [@key "twist"]
            [@yojson.option]
            [@ocaml.doc
              "The clockwise rotation of a pen stylus around its own major \
               axis, in degrees in the range [0,359] (default: 0)."]
        deltaX : Types.number option;
            [@key "deltaX"]
            [@yojson.option]
            [@ocaml.doc
              "X delta in CSS pixels for mouse wheel event (default: 0)."]
        deltaY : Types.number option;
            [@key "deltaY"]
            [@yojson.option]
            [@ocaml.doc
              "Y delta in CSS pixels for mouse wheel event (default: 0)."]
        pointerType : dispatchmouseevent_pointertype option;
            [@key "pointerType"]
            [@yojson.option]
            [@ocaml.doc "Pointer type (default: \"mouse\")."]
      }
      [@@deriving yojson]

      let make ~type_ ~x ~y ?modifiers ?timestamp ?button ?buttons ?clickCount
          ?force ?tangentialPressure ?tiltX ?tiltY ?twist ?deltaX ?deltaY
          ?pointerType () =
        {
          type_;
          x;
          y;
          modifiers;
          timestamp;
          button;
          buttons;
          clickCount;
          force;
          tangentialPressure;
          tiltX;
          tiltY;
          twist;
          deltaX;
          deltaY;
          pointerType;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.dispatchMouseEvent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Dispatches a mouse event to the page. |desc}]

  module DispatchTouchEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type dispatchtouchevent_type =
        [ `touchStart | `touchEnd | `touchMove | `touchCancel ]

      let dispatchtouchevent_type_of_yojson = function
        | `String "touchStart" -> `touchStart
        | `String "touchEnd" -> `touchEnd
        | `String "touchMove" -> `touchMove
        | `String "touchCancel" -> `touchCancel
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_dispatchtouchevent_type = function
        | `touchStart -> `String "touchStart"
        | `touchEnd -> `String "touchEnd"
        | `touchMove -> `String "touchMove"
        | `touchCancel -> `String "touchCancel"

      type t = {
        type_ : dispatchtouchevent_type;
            [@key "type"]
            [@ocaml.doc
              "Type of the touch event. TouchEnd and TouchCancel must not \
               contain any touch points, while\n\
               TouchStart and TouchMove must contains at least one."]
        touchPoints : Types.Input.TouchPoint.t list;
            [@key "touchPoints"]
            [@ocaml.doc
              "Active touch points on the touch device. One event per any \
               changed point (compared to\n\
               previous touch event in a sequence) is generated, emulating \
               pressing/moving/releasing points\n\
               one by one."]
        modifiers : Types.number option;
            [@key "modifiers"]
            [@yojson.option]
            [@ocaml.doc
              "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, \
               Meta/Command=4, Shift=8\n\
               (default: 0)."]
        timestamp : Types.Input.TimeSinceEpoch.t option;
            [@key "timestamp"]
            [@yojson.option]
            [@ocaml.doc "Time at which the event occurred."]
      }
      [@@deriving yojson]

      let make ~type_ ~touchPoints ?modifiers ?timestamp () =
        { type_; touchPoints; modifiers; timestamp }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.dispatchTouchEvent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Dispatches a touch event to the page. |desc}]

  module CancelDragging = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Input.cancelDragging"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Cancels any active dragging in the page. |desc}]

  module EmulateTouchFromMouseEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type emulatetouchfrommouseevent_type =
        [ `mousePressed | `mouseReleased | `mouseMoved | `mouseWheel ]

      let emulatetouchfrommouseevent_type_of_yojson = function
        | `String "mousePressed" -> `mousePressed
        | `String "mouseReleased" -> `mouseReleased
        | `String "mouseMoved" -> `mouseMoved
        | `String "mouseWheel" -> `mouseWheel
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_emulatetouchfrommouseevent_type = function
        | `mousePressed -> `String "mousePressed"
        | `mouseReleased -> `String "mouseReleased"
        | `mouseMoved -> `String "mouseMoved"
        | `mouseWheel -> `String "mouseWheel"

      type t = {
        type_ : emulatetouchfrommouseevent_type;
            [@key "type"] [@ocaml.doc "Type of the mouse event."]
        x : Types.number;
            [@key "x"] [@ocaml.doc "X coordinate of the mouse pointer in DIP."]
        y : Types.number;
            [@key "y"] [@ocaml.doc "Y coordinate of the mouse pointer in DIP."]
        button : Types.Input.MouseButton.t;
            [@key "button"]
            [@ocaml.doc
              "Mouse button. Only \"none\", \"left\", \"right\" are supported."]
        timestamp : Types.Input.TimeSinceEpoch.t option;
            [@key "timestamp"]
            [@yojson.option]
            [@ocaml.doc
              "Time at which the event occurred (default: current time)."]
        deltaX : Types.number option;
            [@key "deltaX"]
            [@yojson.option]
            [@ocaml.doc "X delta in DIP for mouse wheel event (default: 0)."]
        deltaY : Types.number option;
            [@key "deltaY"]
            [@yojson.option]
            [@ocaml.doc "Y delta in DIP for mouse wheel event (default: 0)."]
        modifiers : Types.number option;
            [@key "modifiers"]
            [@yojson.option]
            [@ocaml.doc
              "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, \
               Meta/Command=4, Shift=8\n\
               (default: 0)."]
        clickCount : Types.number option;
            [@key "clickCount"]
            [@yojson.option]
            [@ocaml.doc
              "Number of times the mouse button was clicked (default: 0)."]
      }
      [@@deriving yojson]

      let make ~type_ ~x ~y ~button ?timestamp ?deltaX ?deltaY ?modifiers
          ?clickCount () =
        {
          type_;
          x;
          y;
          button;
          timestamp;
          deltaX;
          deltaY;
          modifiers;
          clickCount;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.emulateTouchFromMouseEvent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Emulates touch event from the mouse event parameters. |desc}]

  module SetIgnoreInputEvents = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ignore : bool;
            [@key "ignore"]
            [@ocaml.doc "Ignores input events processing when set to true."]
      }
      [@@deriving yojson]

      let make ~ignore () = { ignore }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.setIgnoreInputEvents"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Ignores input events (useful while auditing page). |desc}]

  module SetInterceptDrags = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool; [@key "enabled"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.setInterceptDrags"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`. |desc}]

  module SynthesizePinchGesture = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        x : Types.number;
            [@key "x"]
            [@ocaml.doc
              "X coordinate of the start of the gesture in CSS pixels."]
        y : Types.number;
            [@key "y"]
            [@ocaml.doc
              "Y coordinate of the start of the gesture in CSS pixels."]
        scaleFactor : Types.number;
            [@key "scaleFactor"]
            [@ocaml.doc
              "Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms \
               out)."]
        relativeSpeed : Types.number option;
            [@key "relativeSpeed"]
            [@yojson.option]
            [@ocaml.doc
              "Relative pointer speed in pixels per second (default: 800)."]
        gestureSourceType : Types.Input.GestureSourceType.t option;
            [@key "gestureSourceType"]
            [@yojson.option]
            [@ocaml.doc
              "Which type of input events to be generated (default: 'default', \
               which queries the platform\n\
               for the preferred input type)."]
      }
      [@@deriving yojson]

      let make ~x ~y ~scaleFactor ?relativeSpeed ?gestureSourceType () =
        { x; y; scaleFactor; relativeSpeed; gestureSourceType }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.synthesizePinchGesture"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Synthesizes a pinch gesture over a time period by issuing appropriate touch events. |desc}]

  module SynthesizeScrollGesture = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        x : Types.number;
            [@key "x"]
            [@ocaml.doc
              "X coordinate of the start of the gesture in CSS pixels."]
        y : Types.number;
            [@key "y"]
            [@ocaml.doc
              "Y coordinate of the start of the gesture in CSS pixels."]
        xDistance : Types.number option;
            [@key "xDistance"]
            [@yojson.option]
            [@ocaml.doc
              "The distance to scroll along the X axis (positive to scroll \
               left)."]
        yDistance : Types.number option;
            [@key "yDistance"]
            [@yojson.option]
            [@ocaml.doc
              "The distance to scroll along the Y axis (positive to scroll up)."]
        xOverscroll : Types.number option;
            [@key "xOverscroll"]
            [@yojson.option]
            [@ocaml.doc
              "The number of additional pixels to scroll back along the X \
               axis, in addition to the given\n\
               distance."]
        yOverscroll : Types.number option;
            [@key "yOverscroll"]
            [@yojson.option]
            [@ocaml.doc
              "The number of additional pixels to scroll back along the Y \
               axis, in addition to the given\n\
               distance."]
        preventFling : bool option;
            [@key "preventFling"]
            [@yojson.option]
            [@ocaml.doc "Prevent fling (default: true)."]
        speed : Types.number option;
            [@key "speed"]
            [@yojson.option]
            [@ocaml.doc "Swipe speed in pixels per second (default: 800)."]
        gestureSourceType : Types.Input.GestureSourceType.t option;
            [@key "gestureSourceType"]
            [@yojson.option]
            [@ocaml.doc
              "Which type of input events to be generated (default: 'default', \
               which queries the platform\n\
               for the preferred input type)."]
        repeatCount : Types.number option;
            [@key "repeatCount"]
            [@yojson.option]
            [@ocaml.doc
              "The number of times to repeat the gesture (default: 0)."]
        repeatDelayMs : Types.number option;
            [@key "repeatDelayMs"]
            [@yojson.option]
            [@ocaml.doc
              "The number of milliseconds delay between each repeat. (default: \
               250)."]
        interactionMarkerName : string option;
            [@key "interactionMarkerName"]
            [@yojson.option]
            [@ocaml.doc
              "The name of the interaction markers to generate, if not empty \
               (default: \"\")."]
      }
      [@@deriving yojson]

      let make ~x ~y ?xDistance ?yDistance ?xOverscroll ?yOverscroll
          ?preventFling ?speed ?gestureSourceType ?repeatCount ?repeatDelayMs
          ?interactionMarkerName () =
        {
          x;
          y;
          xDistance;
          yDistance;
          xOverscroll;
          yOverscroll;
          preventFling;
          speed;
          gestureSourceType;
          repeatCount;
          repeatDelayMs;
          interactionMarkerName;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.synthesizeScrollGesture"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Synthesizes a scroll gesture over a time period by issuing appropriate touch events. |desc}]

  module SynthesizeTapGesture = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        x : Types.number;
            [@key "x"]
            [@ocaml.doc
              "X coordinate of the start of the gesture in CSS pixels."]
        y : Types.number;
            [@key "y"]
            [@ocaml.doc
              "Y coordinate of the start of the gesture in CSS pixels."]
        duration : Types.number option;
            [@key "duration"]
            [@yojson.option]
            [@ocaml.doc
              "Duration between touchdown and touchup events in ms (default: \
               50)."]
        tapCount : Types.number option;
            [@key "tapCount"]
            [@yojson.option]
            [@ocaml.doc
              "Number of times to perform the tap (e.g. 2 for double tap, \
               default: 1)."]
        gestureSourceType : Types.Input.GestureSourceType.t option;
            [@key "gestureSourceType"]
            [@yojson.option]
            [@ocaml.doc
              "Which type of input events to be generated (default: 'default', \
               which queries the platform\n\
               for the preferred input type)."]
      }
      [@@deriving yojson]

      let make ~x ~y ?duration ?tapCount ?gestureSourceType () =
        { x; y; duration; tapCount; gestureSourceType }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Input.synthesizeTapGesture"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Synthesizes a tap gesture over a time period by issuing appropriate touch events. |desc}]
end

module Inspector = struct
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Inspector.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables inspector domain notifications. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Inspector.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables inspector domain notifications. |desc}]
end

module LayerTree = struct
  module CompositingReasons = struct
    module Response : sig
      type result = {
        compositingReasons : string list;
            [@key "compositingReasons"]
            [@ocaml.doc
              "A list of strings specifying reasons for the given layer to \
               become composited."]
        compositingReasonIds : string list;
            [@key "compositingReasonIds"]
            [@ocaml.doc
              "A list of strings specifying reason IDs for the given layer to \
               become composited."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        compositingReasons : string list;
            [@key "compositingReasons"]
            [@ocaml.doc
              "A list of strings specifying reasons for the given layer to \
               become composited."]
        compositingReasonIds : string list;
            [@key "compositingReasonIds"]
            [@ocaml.doc
              "A list of strings specifying reason IDs for the given layer to \
               become composited."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        layerId : Types.LayerTree.LayerId.t;
            [@key "layerId"]
            [@ocaml.doc
              "The id of the layer for which we want to get the reasons it was \
               composited."]
      }
      [@@deriving yojson]

      let make ~layerId () = { layerId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.compositingReasons"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Provides the reasons why the given layer was composited. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "LayerTree.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables compositing tree inspection. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "LayerTree.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables compositing tree inspection. |desc}]

  module LoadSnapshot = struct
    module Response : sig
      type result = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the snapshot."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the snapshot."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        tiles : Types.LayerTree.PictureTile.t list;
            [@key "tiles"]
            [@ocaml.doc "An array of tiles composing the snapshot."]
      }
      [@@deriving yojson]

      let make ~tiles () = { tiles }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.loadSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns the snapshot identifier. |desc}]

  module MakeSnapshot = struct
    module Response : sig
      type result = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the layer snapshot."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the layer snapshot."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        layerId : Types.LayerTree.LayerId.t;
            [@key "layerId"] [@ocaml.doc "The id of the layer."]
      }
      [@@deriving yojson]

      let make ~layerId () = { layerId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.makeSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns the layer snapshot identifier. |desc}]

  module ProfileSnapshot = struct
    module Response : sig
      type result = {
        timings : Types.LayerTree.PaintProfile.t list;
            [@key "timings"]
            [@ocaml.doc "The array of paint profiles, one per run."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        timings : Types.LayerTree.PaintProfile.t list;
            [@key "timings"]
            [@ocaml.doc "The array of paint profiles, one per run."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the layer snapshot."]
        minRepeatCount : Types.number option;
            [@key "minRepeatCount"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum number of times to replay the snapshot (1, if not \
               specified)."]
        minDuration : Types.number option;
            [@key "minDuration"]
            [@yojson.option]
            [@ocaml.doc
              "The minimum duration (in seconds) to replay the snapshot."]
        clipRect : Types.DOM.Rect.t option;
            [@key "clipRect"]
            [@yojson.option]
            [@ocaml.doc
              "The clip rectangle to apply when replaying the snapshot."]
      }
      [@@deriving yojson]

      let make ~snapshotId ?minRepeatCount ?minDuration ?clipRect () =
        { snapshotId; minRepeatCount; minDuration; clipRect }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.profileSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module ReleaseSnapshot = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the layer snapshot."]
      }
      [@@deriving yojson]

      let make ~snapshotId () = { snapshotId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.releaseSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Releases layer snapshot captured by the back-end. |desc}]

  module ReplaySnapshot = struct
    module Response : sig
      type result = {
        dataURL : string;
            [@key "dataURL"] [@ocaml.doc "A data: URL for resulting image."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        dataURL : string;
            [@key "dataURL"] [@ocaml.doc "A data: URL for resulting image."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the layer snapshot."]
        fromStep : Types.number option;
            [@key "fromStep"]
            [@yojson.option]
            [@ocaml.doc
              "The first step to replay from (replay from the very start if \
               not specified)."]
        toStep : Types.number option;
            [@key "toStep"]
            [@yojson.option]
            [@ocaml.doc
              "The last step to replay to (replay till the end if not \
               specified)."]
        scale : Types.number option;
            [@key "scale"]
            [@yojson.option]
            [@ocaml.doc "The scale to apply while replaying (defaults to 1)."]
      }
      [@@deriving yojson]

      let make ~snapshotId ?fromStep ?toStep ?scale () =
        { snapshotId; fromStep; toStep; scale }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.replaySnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Replays the layer snapshot and returns the resulting bitmap. |desc}]

  module SnapshotCommandLog = struct
    module Response : sig
      type result = {
        commandLog : Types.assoc list;
            [@key "commandLog"]
            [@ocaml.doc "The array of canvas function calls."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        commandLog : Types.assoc list;
            [@key "commandLog"]
            [@ocaml.doc "The array of canvas function calls."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        snapshotId : Types.LayerTree.SnapshotId.t;
            [@key "snapshotId"] [@ocaml.doc "The id of the layer snapshot."]
      }
      [@@deriving yojson]

      let make ~snapshotId () = { snapshotId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "LayerTree.snapshotCommandLog"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Replays the layer snapshot and returns canvas log. |desc}]
end

module Log = struct
  module Clear = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Log.clear"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears the log. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Log.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Disables log domain, prevents further log entries from being reported to the client. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Log.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables log domain, sends the entries collected so far to the client by means of the
`entryAdded` notification. |desc}]

  module StartViolationsReport = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        config : Types.Log.ViolationSetting.t list;
            [@key "config"] [@ocaml.doc "Configuration for violations."]
      }
      [@@deriving yojson]

      let make ~config () = { config }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Log.startViolationsReport"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|start violation reporting. |desc}]

  module StopViolationsReport = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Log.stopViolationsReport"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Stop violation reporting. |desc}]
end

module Media = struct
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Media.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables the Media domain |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Media.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables the Media domain. |desc}]
end

module Memory = struct
  module GetDOMCounters = struct
    module Response : sig
      type result = {
        documents : Types.number;
            [@key "documents"] [@ocaml.doc "No description provided"]
        nodes : Types.number;
            [@key "nodes"] [@ocaml.doc "No description provided"]
        jsEventListeners : Types.number;
            [@key "jsEventListeners"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        documents : Types.number;
            [@key "documents"] [@ocaml.doc "No description provided"]
        nodes : Types.number;
            [@key "nodes"] [@ocaml.doc "No description provided"]
        jsEventListeners : Types.number;
            [@key "jsEventListeners"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.getDOMCounters"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Retruns current DOM object counters. |desc}]

  module GetDOMCountersForLeakDetection = struct
    module Response : sig
      type result = {
        counters : Types.Memory.DOMCounter.t list;
            [@key "counters"] [@ocaml.doc "DOM object counters."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        counters : Types.Memory.DOMCounter.t list;
            [@key "counters"] [@ocaml.doc "DOM object counters."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.getDOMCountersForLeakDetection"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Retruns DOM object counters after preparing renderer for leak detection. |desc}]

  module PrepareForLeakDetection = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.prepareForLeakDetection"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Prepares for leak detection by terminating workers, stopping spellcheckers,
dropping non-essential internal caches, running garbage collections, etc. |desc}]

  module ForciblyPurgeJavaScriptMemory = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.forciblyPurgeJavaScriptMemory"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Simulate OomIntervention by purging V8 memory. |desc}]

  module SetPressureNotificationsSuppressed = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        suppressed : bool;
            [@key "suppressed"]
            [@ocaml.doc
              "If true, memory pressure notifications will be suppressed."]
      }
      [@@deriving yojson]

      let make ~suppressed () = { suppressed }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Memory.setPressureNotificationsSuppressed";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enable/disable suppressing memory pressure notifications in all processes. |desc}]

  module SimulatePressureNotification = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        level : Types.Memory.PressureLevel.t;
            [@key "level"]
            [@ocaml.doc "Memory pressure level of the notification."]
      }
      [@@deriving yojson]

      let make ~level () = { level }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Memory.simulatePressureNotification";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Simulate a memory pressure notification in all processes. |desc}]

  module StartSampling = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        samplingInterval : Types.number option;
            [@key "samplingInterval"]
            [@yojson.option]
            [@ocaml.doc "Average number of bytes between samples."]
        suppressRandomness : bool option;
            [@key "suppressRandomness"]
            [@yojson.option]
            [@ocaml.doc "Do not randomize intervals between samples."]
      }
      [@@deriving yojson]

      let make ?samplingInterval ?suppressRandomness () =
        { samplingInterval; suppressRandomness }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Memory.startSampling"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Start collecting native memory profile. |desc}]

  module StopSampling = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.stopSampling"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Stop collecting native memory profile. |desc}]

  module GetAllTimeSamplingProfile = struct
    module Response : sig
      type result = {
        profile : Types.Memory.SamplingProfile.t;
            [@key "profile"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        profile : Types.Memory.SamplingProfile.t;
            [@key "profile"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.getAllTimeSamplingProfile"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Retrieve native memory allocations profile
collected since renderer process startup. |desc}]

  module GetBrowserSamplingProfile = struct
    module Response : sig
      type result = {
        profile : Types.Memory.SamplingProfile.t;
            [@key "profile"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        profile : Types.Memory.SamplingProfile.t;
            [@key "profile"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.getBrowserSamplingProfile"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Retrieve native memory allocations profile
collected since browser process startup. |desc}]

  module GetSamplingProfile = struct
    module Response : sig
      type result = {
        profile : Types.Memory.SamplingProfile.t;
            [@key "profile"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        profile : Types.Memory.SamplingProfile.t;
            [@key "profile"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Memory.getSamplingProfile"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Retrieve native memory allocations profile collected since last
`startSampling` call. |desc}]
end

module Network = struct
  module SetAcceptedEncodings = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        encodings : Types.Network.ContentEncoding.t list;
            [@key "encodings"]
            [@ocaml.doc "List of accepted content encodings."]
      }
      [@@deriving yojson]

      let make ~encodings () = { encodings }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setAcceptedEncodings"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted. |desc}]

  module ClearAcceptedEncodingsOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.clearAcceptedEncodingsOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Clears accepted encodings set by setAcceptedEncodings |desc}]

  module CanClearBrowserCache = struct
    module Response : sig
      type result = {
        result : bool;
            [@key "result"] [@ocaml.doc "True if browser cache can be cleared."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : bool;
            [@key "result"] [@ocaml.doc "True if browser cache can be cleared."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.canClearBrowserCache"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Tells whether clearing browser cache is supported. |desc}]

  module CanClearBrowserCookies = struct
    module Response : sig
      type result = {
        result : bool;
            [@key "result"]
            [@ocaml.doc "True if browser cookies can be cleared."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : bool;
            [@key "result"]
            [@ocaml.doc "True if browser cookies can be cleared."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.canClearBrowserCookies"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Tells whether clearing browser cookies is supported. |desc}]

  module CanEmulateNetworkConditions = struct
    module Response : sig
      type result = {
        result : bool;
            [@key "result"]
            [@ocaml.doc "True if emulation of network conditions is supported."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : bool;
            [@key "result"]
            [@ocaml.doc "True if emulation of network conditions is supported."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.canEmulateNetworkConditions"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Tells whether emulation of network conditions is supported. |desc}]

  module ClearBrowserCache = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.clearBrowserCache"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears browser cache. |desc}]

  module ClearBrowserCookies = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.clearBrowserCookies"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears browser cookies. |desc}]

  module ContinueInterceptedRequest = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        interceptionId : Types.Network.InterceptionId.t;
            [@key "interceptionId"] [@ocaml.doc "No description provided"]
        errorReason : Types.Network.ErrorReason.t option;
            [@key "errorReason"]
            [@yojson.option]
            [@ocaml.doc
              "If set this causes the request to fail with the given reason. \
               Passing `Aborted` for requests\n\
               marked with `isNavigationRequest` also cancels the navigation. \
               Must not be set in response\n\
               to an authChallenge."]
        rawResponse : string option;
            [@key "rawResponse"]
            [@yojson.option]
            [@ocaml.doc
              "If set the requests completes using with the provided base64 \
               encoded raw response, including\n\
               HTTP status line and headers etc... Must not be set in response \
               to an authChallenge. (Encoded as a base64 string when passed \
               over JSON)"]
        url : string option;
            [@key "url"]
            [@yojson.option]
            [@ocaml.doc
              "If set the request url will be modified in a way that's not \
               observable by page. Must not be\n\
               set in response to an authChallenge."]
        method_ : string option;
            [@key "method"]
            [@yojson.option]
            [@ocaml.doc
              "If set this allows the request method to be overridden. Must \
               not be set in response to an\n\
               authChallenge."]
        postData : string option;
            [@key "postData"]
            [@yojson.option]
            [@ocaml.doc
              "If set this allows postData to be set. Must not be set in \
               response to an authChallenge."]
        headers : Types.Network.Headers.t option;
            [@key "headers"]
            [@yojson.option]
            [@ocaml.doc
              "If set this allows the request headers to be changed. Must not \
               be set in response to an\n\
               authChallenge."]
        authChallengeResponse : Types.Network.AuthChallengeResponse.t option;
            [@key "authChallengeResponse"]
            [@yojson.option]
            [@ocaml.doc
              "Response to a requestIntercepted with an authChallenge. Must \
               not be set otherwise."]
      }
      [@@deriving yojson]

      let make ~interceptionId ?errorReason ?rawResponse ?url ?method_ ?postData
          ?headers ?authChallengeResponse () =
        {
          interceptionId;
          errorReason;
          rawResponse;
          url;
          method_;
          postData;
          headers;
          authChallengeResponse;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Network.continueInterceptedRequest";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Response to Network.requestIntercepted which either modifies the request to continue with any
modifications, or blocks it, or completes it with the provided response bytes. If a network
fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
event will be sent with the same InterceptionId.
Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead. |desc}]

  module DeleteCookies = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        name : string;
            [@key "name"] [@ocaml.doc "Name of the cookies to remove."]
        url : string option;
            [@key "url"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, deletes all the cookies with the given name where \
               domain and path match\n\
               provided URL."]
        domain : string option;
            [@key "domain"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, deletes only cookies with the exact domain."]
        path : string option;
            [@key "path"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, deletes only cookies with the exact path."]
        partitionKey : Types.Network.CookiePartitionKey.t option;
            [@key "partitionKey"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, deletes only cookies with the the given name and \
               partitionKey where\n\
               all partition key attributes match the cookie partition key \
               attribute."]
      }
      [@@deriving yojson]

      let make ~name ?url ?domain ?path ?partitionKey () =
        { name; url; domain; path; partitionKey }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.deleteCookies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Deletes browser cookies with matching name and url or domain/path/partitionKey pair. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Disables network tracking, prevents network events from being sent to the client. |desc}]

  module EmulateNetworkConditions = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        offline : bool;
            [@key "offline"]
            [@ocaml.doc "True to emulate internet disconnection."]
        latency : Types.number;
            [@key "latency"]
            [@ocaml.doc
              "Minimum latency from request sent to response headers received \
               (ms)."]
        downloadThroughput : Types.number;
            [@key "downloadThroughput"]
            [@ocaml.doc
              "Maximal aggregated download throughput (bytes/sec). -1 disables \
               download throttling."]
        uploadThroughput : Types.number;
            [@key "uploadThroughput"]
            [@ocaml.doc
              "Maximal aggregated upload throughput (bytes/sec).  -1 disables \
               upload throttling."]
        connectionType : Types.Network.ConnectionType.t option;
            [@key "connectionType"]
            [@yojson.option]
            [@ocaml.doc "Connection type if known."]
        packetLoss : Types.number option;
            [@key "packetLoss"]
            [@yojson.option]
            [@ocaml.doc
              "WebRTC packet loss (percent, 0-100). 0 disables packet loss \
               emulation, 100 drops all the packets."]
        packetQueueLength : Types.number option;
            [@key "packetQueueLength"]
            [@yojson.option]
            [@ocaml.doc
              "WebRTC packet queue length (packet). 0 removes any queue length \
               limitations."]
        packetReordering : bool option;
            [@key "packetReordering"]
            [@yojson.option]
            [@ocaml.doc "WebRTC packetReordering feature."]
      }
      [@@deriving yojson]

      let make ~offline ~latency ~downloadThroughput ~uploadThroughput
          ?connectionType ?packetLoss ?packetQueueLength ?packetReordering () =
        {
          offline;
          latency;
          downloadThroughput;
          uploadThroughput;
          connectionType;
          packetLoss;
          packetQueueLength;
          packetReordering;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.emulateNetworkConditions"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Activates emulation of network conditions. This command is deprecated in favor of the emulateNetworkConditionsByRule
and overrideNetworkState commands, which can be used together to the same effect. |desc}]

  module EmulateNetworkConditionsByRule = struct
    module Response : sig
      type result = {
        ruleIds : string list;
            [@key "ruleIds"]
            [@ocaml.doc
              "An id for each entry in matchedNetworkConditions. The id will \
               be included in the requestWillBeSentExtraInfo for\n\
               requests affected by a rule."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        ruleIds : string list;
            [@key "ruleIds"]
            [@ocaml.doc
              "An id for each entry in matchedNetworkConditions. The id will \
               be included in the requestWillBeSentExtraInfo for\n\
               requests affected by a rule."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        offline : bool;
            [@key "offline"]
            [@ocaml.doc "True to emulate internet disconnection."]
        matchedNetworkConditions : Types.Network.NetworkConditions.t list;
            [@key "matchedNetworkConditions"]
            [@ocaml.doc
              "Configure conditions for matching requests. If multiple entries \
               match a request, the first entry wins.  Global\n\
               conditions can be configured by leaving the urlPattern for the \
               conditions empty. These global conditions are\n\
               also applied for throttling of p2p connections."]
      }
      [@@deriving yojson]

      let make ~offline ~matchedNetworkConditions () =
        { offline; matchedNetworkConditions }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Network.emulateNetworkConditionsByRule";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Activates emulation of network conditions for individual requests using URL match patterns. Unlike the deprecated
Network.emulateNetworkConditions this method does not affect `navigator` state. Use Network.overrideNetworkState to
explicitly modify `navigator` behavior. |desc}]

  module OverrideNetworkState = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        offline : bool;
            [@key "offline"]
            [@ocaml.doc "True to emulate internet disconnection."]
        latency : Types.number;
            [@key "latency"]
            [@ocaml.doc
              "Minimum latency from request sent to response headers received \
               (ms)."]
        downloadThroughput : Types.number;
            [@key "downloadThroughput"]
            [@ocaml.doc
              "Maximal aggregated download throughput (bytes/sec). -1 disables \
               download throttling."]
        uploadThroughput : Types.number;
            [@key "uploadThroughput"]
            [@ocaml.doc
              "Maximal aggregated upload throughput (bytes/sec).  -1 disables \
               upload throttling."]
        connectionType : Types.Network.ConnectionType.t option;
            [@key "connectionType"]
            [@yojson.option]
            [@ocaml.doc "Connection type if known."]
      }
      [@@deriving yojson]

      let make ~offline ~latency ~downloadThroughput ~uploadThroughput
          ?connectionType () =
        {
          offline;
          latency;
          downloadThroughput;
          uploadThroughput;
          connectionType;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.overrideNetworkState"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Override the state of navigator.onLine and navigator.connection. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        maxTotalBufferSize : Types.number option;
            [@key "maxTotalBufferSize"]
            [@yojson.option]
            [@ocaml.doc
              "Buffer size in bytes to use when preserving network payloads \
               (XHRs, etc)."]
        maxResourceBufferSize : Types.number option;
            [@key "maxResourceBufferSize"]
            [@yojson.option]
            [@ocaml.doc
              "Per-resource buffer size in bytes to use when preserving \
               network payloads (XHRs, etc)."]
        maxPostDataSize : Types.number option;
            [@key "maxPostDataSize"]
            [@yojson.option]
            [@ocaml.doc
              "Longest post body size (in bytes) that would be included in \
               requestWillBeSent notification"]
        reportDirectSocketTraffic : bool option;
            [@key "reportDirectSocketTraffic"]
            [@yojson.option]
            [@ocaml.doc
              "Whether DirectSocket chunk send/receive events should be \
               reported."]
        enableDurableMessages : bool option;
            [@key "enableDurableMessages"]
            [@yojson.option]
            [@ocaml.doc
              "Enable storing response bodies outside of renderer, so that \
               these survive\n\
               a cross-process navigation. Requires maxTotalBufferSize to be \
               set.\n\
               Currently defaults to false. This field is being deprecated in \
               favor of the dedicated\n\
               configureDurableMessages command, due to the possibility of \
               deadlocks when awaiting\n\
               Network.enable before issuing Runtime.runIfWaitingForDebugger."]
      }
      [@@deriving yojson]

      let make ?maxTotalBufferSize ?maxResourceBufferSize ?maxPostDataSize
          ?reportDirectSocketTraffic ?enableDurableMessages () =
        {
          maxTotalBufferSize;
          maxResourceBufferSize;
          maxPostDataSize;
          reportDirectSocketTraffic;
          enableDurableMessages;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables network tracking, network events will now be delivered to the client. |desc}]

  module ConfigureDurableMessages = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        maxTotalBufferSize : Types.number option;
            [@key "maxTotalBufferSize"]
            [@yojson.option]
            [@ocaml.doc
              "Buffer size in bytes to use when preserving network payloads \
               (XHRs, etc)."]
        maxResourceBufferSize : Types.number option;
            [@key "maxResourceBufferSize"]
            [@yojson.option]
            [@ocaml.doc
              "Per-resource buffer size in bytes to use when preserving \
               network payloads (XHRs, etc)."]
      }
      [@@deriving yojson]

      let make ?maxTotalBufferSize ?maxResourceBufferSize () =
        { maxTotalBufferSize; maxResourceBufferSize }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.configureDurableMessages"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Configures storing response bodies outside of renderer, so that these survive
a cross-process navigation.
If maxTotalBufferSize is not set, durable messages are disabled. |desc}]

  module GetAllCookies = struct
    module Response : sig
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Network.getAllCookies"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns all browser cookies. Depending on the backend support, will return detailed cookie
information in the `cookies` field.
Deprecated. Use Storage.getCookies instead. |desc}]

  module GetCertificate = struct
    module Response : sig
      type result = {
        tableNames : string list;
            [@key "tableNames"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        tableNames : string list;
            [@key "tableNames"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string;
            [@key "origin"] [@ocaml.doc "Origin to get certificate for."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.getCertificate"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns the DER-encoded certificate. |desc}]

  module GetCookies = struct
    module Response : sig
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        urls : string list option;
            [@key "urls"]
            [@yojson.option]
            [@ocaml.doc
              "The list of URLs for which applicable cookies will be fetched.\n\
               If not specified, it's assumed to be set to the list containing\n\
               the URLs of the page and all of its subframes."]
      }
      [@@deriving yojson]

      let make ?urls () = { urls }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.getCookies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns all browser cookies for the current URL. Depending on the backend support, will return
detailed cookie information in the `cookies` field. |desc}]

  module GetResponseBody = struct
    module Response : sig
      type result = {
        body : string; [@key "body"] [@ocaml.doc "Response body."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        body : string; [@key "body"] [@ocaml.doc "Response body."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Network.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "Identifier of the network request to get content for."]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.getResponseBody"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns content served for the given request. |desc}]

  module GetRequestPostData = struct
    module Response : sig
      type result = {
        postData : string;
            [@key "postData"]
            [@ocaml.doc
              "Request body string, omitting files from multipart requests"]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        postData : string;
            [@key "postData"]
            [@ocaml.doc
              "Request body string, omitting files from multipart requests"]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Network.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "Identifier of the network request to get content for."]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.getRequestPostData"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns post data sent with the request. Returns an error when no data was sent with the request. |desc}]

  module GetResponseBodyForInterception = struct
    module Response : sig
      type result = {
        body : string; [@key "body"] [@ocaml.doc "Response body."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        body : string; [@key "body"] [@ocaml.doc "Response body."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was sent as base64."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        interceptionId : Types.Network.InterceptionId.t;
            [@key "interceptionId"]
            [@ocaml.doc
              "Identifier for the intercepted request to get body for."]
      }
      [@@deriving yojson]

      let make ~interceptionId () = { interceptionId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Network.getResponseBodyForInterception";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns content served for the given currently intercepted request. |desc}]

  module TakeResponseBodyForInterceptionAsStream = struct
    module Response : sig
      type result = {
        stream : Types.IO.StreamHandle.t;
            [@key "stream"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        stream : Types.IO.StreamHandle.t;
            [@key "stream"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        interceptionId : Types.Network.InterceptionId.t;
            [@key "interceptionId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~interceptionId () = { interceptionId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Network.takeResponseBodyForInterceptionAsStream";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns a handle to the stream representing the response body. Note that after this command,
the intercepted request can't be continued as is -- you either need to cancel it or to provide
the response body. The stream only supports sequential read, IO.read will fail if the position
is specified. |desc}]

  module ReplayXHR = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Network.RequestId.t;
            [@key "requestId"] [@ocaml.doc "Identifier of XHR to replay."]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.replayXHR"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|This method sends a new XMLHttpRequest which is identical to the original one. The following
parameters should be identical: method, url, async, request body, extra headers, withCredentials
attribute, user, password. |desc}]

  module SearchInResponseBody = struct
    module Response : sig
      type result = {
        result : Types.Debugger.SearchMatch.t list;
            [@key "result"] [@ocaml.doc "List of search matches."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Debugger.SearchMatch.t list;
            [@key "result"] [@ocaml.doc "List of search matches."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Network.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "Identifier of the network response to search."]
        query : string; [@key "query"] [@ocaml.doc "String to search for."]
        caseSensitive : bool option;
            [@key "caseSensitive"]
            [@yojson.option]
            [@ocaml.doc "If true, search is case sensitive."]
        isRegex : bool option;
            [@key "isRegex"]
            [@yojson.option]
            [@ocaml.doc "If true, treats string parameter as regex."]
      }
      [@@deriving yojson]

      let make ~requestId ~query ?caseSensitive ?isRegex () =
        { requestId; query; caseSensitive; isRegex }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.searchInResponseBody"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Searches for given string in response content. |desc}]

  module SetBlockedURLs = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        urlPatterns : Types.Network.BlockPattern.t list option;
            [@key "urlPatterns"]
            [@yojson.option]
            [@ocaml.doc
              "Patterns to match in the order in which they are given. These \
               patterns\n\
               also take precedence over any wildcard patterns defined in \
               `urls`."]
        urls : string list option;
            [@key "urls"]
            [@yojson.option]
            [@ocaml.doc "URL patterns to block. Wildcards ('*') are allowed."]
      }
      [@@deriving yojson]

      let make ?urlPatterns ?urls () = { urlPatterns; urls }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setBlockedURLs"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Blocks URLs from loading. |desc}]

  module SetBypassServiceWorker = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        bypass : bool;
            [@key "bypass"]
            [@ocaml.doc "Bypass service worker and load from network."]
      }
      [@@deriving yojson]

      let make ~bypass () = { bypass }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setBypassServiceWorker"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Toggles ignoring of service worker for each request. |desc}]

  module SetCacheDisabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cacheDisabled : bool;
            [@key "cacheDisabled"] [@ocaml.doc "Cache disabled state."]
      }
      [@@deriving yojson]

      let make ~cacheDisabled () = { cacheDisabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setCacheDisabled"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Toggles ignoring cache for each request. If `true`, cache will not be used. |desc}]

  module SetCookie = struct
    module Response : sig
      type result = {
        success : bool;
            [@key "success"]
            [@ocaml.doc
              "Always set to true. If an error occurs, the response indicates \
               protocol error."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        success : bool;
            [@key "success"]
            [@ocaml.doc
              "Always set to true. If an error occurs, the response indicates \
               protocol error."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        name : string; [@key "name"] [@ocaml.doc "Cookie name."]
        value : string; [@key "value"] [@ocaml.doc "Cookie value."]
        url : string option;
            [@key "url"]
            [@yojson.option]
            [@ocaml.doc
              "The request-URI to associate with the setting of the cookie. \
               This value can affect the\n\
               default domain, path, source port, and source scheme values of \
               the created cookie."]
        domain : string option;
            [@key "domain"] [@yojson.option] [@ocaml.doc "Cookie domain."]
        path : string option;
            [@key "path"] [@yojson.option] [@ocaml.doc "Cookie path."]
        secure : bool option;
            [@key "secure"]
            [@yojson.option]
            [@ocaml.doc "True if cookie is secure."]
        httpOnly : bool option;
            [@key "httpOnly"]
            [@yojson.option]
            [@ocaml.doc "True if cookie is http-only."]
        sameSite : Types.Network.CookieSameSite.t option;
            [@key "sameSite"]
            [@yojson.option]
            [@ocaml.doc "Cookie SameSite type."]
        expires : Types.Network.TimeSinceEpoch.t option;
            [@key "expires"]
            [@yojson.option]
            [@ocaml.doc "Cookie expiration date, session cookie if not set"]
        priority : Types.Network.CookiePriority.t option;
            [@key "priority"]
            [@yojson.option]
            [@ocaml.doc "Cookie Priority type."]
        sourceScheme : Types.Network.CookieSourceScheme.t option;
            [@key "sourceScheme"]
            [@yojson.option]
            [@ocaml.doc "Cookie source scheme type."]
        sourcePort : Types.number option;
            [@key "sourcePort"]
            [@yojson.option]
            [@ocaml.doc
              "Cookie source port. Valid values are {-1, [1, 65535]}, -1 \
               indicates an unspecified port.\n\
               An unspecified port value allows protocol clients to emulate \
               legacy cookie scope for the port.\n\
               This is a temporary ability and it will be removed in the \
               future."]
        partitionKey : Types.Network.CookiePartitionKey.t option;
            [@key "partitionKey"]
            [@yojson.option]
            [@ocaml.doc
              "Cookie partition key. If not set, the cookie will be set as not \
               partitioned."]
      }
      [@@deriving yojson]

      let make ~name ~value ?url ?domain ?path ?secure ?httpOnly ?sameSite
          ?expires ?priority ?sourceScheme ?sourcePort ?partitionKey () =
        {
          name;
          value;
          url;
          domain;
          path;
          secure;
          httpOnly;
          sameSite;
          expires;
          priority;
          sourceScheme;
          sourcePort;
          partitionKey;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setCookie"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist. |desc}]

  module SetCookies = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cookies : Types.Network.CookieParam.t list;
            [@key "cookies"] [@ocaml.doc "Cookies to be set."]
      }
      [@@deriving yojson]

      let make ~cookies () = { cookies }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setCookies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets given cookies. |desc}]

  module SetExtraHTTPHeaders = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        headers : Types.Network.Headers.t;
            [@key "headers"] [@ocaml.doc "Map with extra HTTP headers."]
      }
      [@@deriving yojson]

      let make ~headers () = { headers }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setExtraHTTPHeaders"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Specifies whether to always send extra HTTP headers with the requests from this page. |desc}]

  module SetAttachDebugStack = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc
              "Whether to attach a page script stack for debugging purpose."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setAttachDebugStack"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Specifies whether to attach a page script stack id in requests |desc}]

  module SetRequestInterception = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        patterns : Types.Network.RequestPattern.t list;
            [@key "patterns"]
            [@ocaml.doc
              "Requests matching any of these patterns will be forwarded and \
               wait for the corresponding\n\
               continueInterceptedRequest call."]
      }
      [@@deriving yojson]

      let make ~patterns () = { patterns }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setRequestInterception"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets the requests to intercept that match the provided patterns and optionally resource types.
Deprecated, please use Fetch.enable instead. |desc}]

  module SetUserAgentOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        userAgent : string; [@key "userAgent"] [@ocaml.doc "User agent to use."]
        acceptLanguage : string option;
            [@key "acceptLanguage"]
            [@yojson.option]
            [@ocaml.doc "Browser language to emulate."]
        platform : string option;
            [@key "platform"]
            [@yojson.option]
            [@ocaml.doc "The platform navigator.platform should return."]
        userAgentMetadata : Types.Emulation.UserAgentMetadata.t option;
            [@key "userAgentMetadata"]
            [@yojson.option]
            [@ocaml.doc
              "To be sent in Sec-CH-UA-* headers and returned in \
               navigator.userAgentData"]
      }
      [@@deriving yojson]

      let make ~userAgent ?acceptLanguage ?platform ?userAgentMetadata () =
        { userAgent; acceptLanguage; platform; userAgentMetadata }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setUserAgentOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Allows overriding user agent with the given string. |desc}]

  module StreamResourceContent = struct
    module Response : sig
      type result = {
        bufferedData : string;
            [@key "bufferedData"]
            [@ocaml.doc
              "Data that has been buffered until streaming is enabled. \
               (Encoded as a base64 string when passed over JSON)"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        bufferedData : string;
            [@key "bufferedData"]
            [@ocaml.doc
              "Data that has been buffered until streaming is enabled. \
               (Encoded as a base64 string when passed over JSON)"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : Types.Network.RequestId.t;
            [@key "requestId"]
            [@ocaml.doc "Identifier of the request to stream."]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.streamResourceContent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables streaming of the response for the given requestId.
If enabled, the dataReceived event contains the data that was received during streaming. |desc}]

  module GetSecurityIsolationStatus = struct
    module Response : sig
      type result = {
        status : Types.Network.SecurityIsolationStatus.t;
            [@key "status"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        status : Types.Network.SecurityIsolationStatus.t;
            [@key "status"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc
              "If no frameId is provided, the status of the target is provided."]
      }
      [@@deriving yojson]

      let make ?frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Network.getSecurityIsolationStatus";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns information about the COEP/COOP isolation status. |desc}]

  module EnableReportingApi = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enable : bool;
            [@key "enable"]
            [@ocaml.doc
              "Whether to enable or disable events for the Reporting API"]
      }
      [@@deriving yojson]

      let make ~enable () = { enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.enableReportingApi"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
Enabling triggers 'reportingApiReportAdded' for all existing reports. |desc}]

  module EnableDeviceBoundSessions = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enable : bool;
            [@key "enable"] [@ocaml.doc "Whether to enable or disable events."]
      }
      [@@deriving yojson]

      let make ~enable () = { enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.enableDeviceBoundSessions"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets up tracking device bound sessions and fetching of initial set of sessions. |desc}]

  module FetchSchemefulSite = struct
    module Response : sig
      type result = {
        schemefulSite : string;
            [@key "schemefulSite"]
            [@ocaml.doc "The corresponding schemeful site."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        schemefulSite : string;
            [@key "schemefulSite"]
            [@ocaml.doc "The corresponding schemeful site."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "The URL origin."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.fetchSchemefulSite"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Fetches the schemeful site for a specific origin. |desc}]

  module LoadNetworkResource = struct
    module Response : sig
      type result = {
        resource : Types.Network.LoadNetworkResourcePageResult.t;
            [@key "resource"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        resource : Types.Network.LoadNetworkResourcePageResult.t;
            [@key "resource"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc
              "Frame id to get the resource for. Mandatory for frame targets, \
               and\n\
               should be omitted for worker targets."]
        url : string;
            [@key "url"] [@ocaml.doc "URL of the resource to get content for."]
        options : Types.Network.LoadNetworkResourceOptions.t;
            [@key "options"] [@ocaml.doc "Options for the request."]
      }
      [@@deriving yojson]

      let make ?frameId ~url ~options () = { frameId; url; options }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.loadNetworkResource"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Fetches the resource and returns the content. |desc}]

  module SetCookieControls = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enableThirdPartyCookieRestriction : bool;
            [@key "enableThirdPartyCookieRestriction"]
            [@ocaml.doc "Whether 3pc restriction is enabled."]
        disableThirdPartyCookieMetadata : bool;
            [@key "disableThirdPartyCookieMetadata"]
            [@ocaml.doc
              "Whether 3pc grace period exception should be enabled; false by \
               default."]
        disableThirdPartyCookieHeuristics : bool;
            [@key "disableThirdPartyCookieHeuristics"]
            [@ocaml.doc
              "Whether 3pc heuristics exceptions should be enabled; false by \
               default."]
      }
      [@@deriving yojson]

      let make ~enableThirdPartyCookieRestriction
          ~disableThirdPartyCookieMetadata ~disableThirdPartyCookieHeuristics ()
          =
        {
          enableThirdPartyCookieRestriction;
          disableThirdPartyCookieMetadata;
          disableThirdPartyCookieHeuristics;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Network.setCookieControls"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets Controls for third-party cookie access
Page reload is required before the new cookie behavior will be observed |desc}]
end

module Overlay = struct
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Overlay.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables domain notifications. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Overlay.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables domain notifications. |desc}]

  module GetHighlightObjectForTest = struct
    module Response : sig
      type result = {
        highlight : Types.assoc;
            [@key "highlight"] [@ocaml.doc "Highlight data for the node."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        highlight : Types.assoc;
            [@key "highlight"] [@ocaml.doc "Highlight data for the node."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"]
            [@ocaml.doc "Id of the node to get highlight object for."]
        includeDistance : bool option;
            [@key "includeDistance"]
            [@yojson.option]
            [@ocaml.doc "Whether to include distance info."]
        includeStyle : bool option;
            [@key "includeStyle"]
            [@yojson.option]
            [@ocaml.doc "Whether to include style info."]
        colorFormat : Types.Overlay.ColorFormat.t option;
            [@key "colorFormat"]
            [@yojson.option]
            [@ocaml.doc "The color format to get config with (default: hex)."]
        showAccessibilityInfo : bool option;
            [@key "showAccessibilityInfo"]
            [@yojson.option]
            [@ocaml.doc "Whether to show accessibility info (default: true)."]
      }
      [@@deriving yojson]

      let make ~nodeId ?includeDistance ?includeStyle ?colorFormat
          ?showAccessibilityInfo () =
        {
          nodeId;
          includeDistance;
          includeStyle;
          colorFormat;
          showAccessibilityInfo;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.getHighlightObjectForTest"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|For testing. |desc}]

  module GetGridHighlightObjectsForTest = struct
    module Response : sig
      type result = {
        highlights : Types.assoc;
            [@key "highlights"]
            [@ocaml.doc "Grid Highlight data for the node ids provided."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        highlights : Types.assoc;
            [@key "highlights"]
            [@ocaml.doc "Grid Highlight data for the node ids provided."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeIds : Types.DOM.NodeId.t list;
            [@key "nodeIds"]
            [@ocaml.doc "Ids of the node to get highlight object for."]
      }
      [@@deriving yojson]

      let make ~nodeIds () = { nodeIds }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.getGridHighlightObjectsForTest";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|For Persistent Grid testing. |desc}]

  module GetSourceOrderHighlightObjectForTest = struct
    module Response : sig
      type result = {
        highlight : Types.assoc;
            [@key "highlight"]
            [@ocaml.doc "Source order highlight data for the node id provided."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        highlight : Types.assoc;
            [@key "highlight"]
            [@ocaml.doc "Source order highlight data for the node id provided."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        nodeId : Types.DOM.NodeId.t;
            [@key "nodeId"] [@ocaml.doc "Id of the node to highlight."]
      }
      [@@deriving yojson]

      let make ~nodeId () = { nodeId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.getSourceOrderHighlightObjectForTest";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|For Source Order Viewer testing. |desc}]

  module HideHighlight = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Overlay.hideHighlight"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Hides any highlight. |desc}]

  module HighlightFrame = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"]
            [@ocaml.doc "Identifier of the frame to highlight."]
        contentColor : Types.DOM.RGBA.t option;
            [@key "contentColor"]
            [@yojson.option]
            [@ocaml.doc
              "The content box highlight fill color (default: transparent)."]
        contentOutlineColor : Types.DOM.RGBA.t option;
            [@key "contentOutlineColor"]
            [@yojson.option]
            [@ocaml.doc
              "The content box highlight outline color (default: transparent)."]
      }
      [@@deriving yojson]

      let make ~frameId ?contentColor ?contentOutlineColor () =
        { frameId; contentColor; contentOutlineColor }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.highlightFrame"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Highlights owner element of the frame with given id.
Deprecated: Doesn't work reliably and cannot be fixed due to process
separation (the owner node might be in a different process). Determine
the owner node in the client and use highlightNode. |desc}]

  module HighlightNode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        highlightConfig : Types.Overlay.HighlightConfig.t;
            [@key "highlightConfig"]
            [@ocaml.doc "A descriptor for the highlight appearance."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node to highlight."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node to highlight."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node to be highlighted."]
        selector : string option;
            [@key "selector"]
            [@yojson.option]
            [@ocaml.doc "Selectors to highlight relevant nodes."]
      }
      [@@deriving yojson]

      let make ~highlightConfig ?nodeId ?backendNodeId ?objectId ?selector () =
        { highlightConfig; nodeId; backendNodeId; objectId; selector }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.highlightNode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
objectId must be specified. |desc}]

  module HighlightQuad = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        quad : Types.DOM.Quad.t; [@key "quad"] [@ocaml.doc "Quad to highlight"]
        color : Types.DOM.RGBA.t option;
            [@key "color"]
            [@yojson.option]
            [@ocaml.doc "The highlight fill color (default: transparent)."]
        outlineColor : Types.DOM.RGBA.t option;
            [@key "outlineColor"]
            [@yojson.option]
            [@ocaml.doc "The highlight outline color (default: transparent)."]
      }
      [@@deriving yojson]

      let make ~quad ?color ?outlineColor () = { quad; color; outlineColor }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.highlightQuad"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Highlights given quad. Coordinates are absolute with respect to the main frame viewport. |desc}]

  module HighlightRect = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        x : Types.number; [@key "x"] [@ocaml.doc "X coordinate"]
        y : Types.number; [@key "y"] [@ocaml.doc "Y coordinate"]
        width : Types.number; [@key "width"] [@ocaml.doc "Rectangle width"]
        height : Types.number; [@key "height"] [@ocaml.doc "Rectangle height"]
        color : Types.DOM.RGBA.t option;
            [@key "color"]
            [@yojson.option]
            [@ocaml.doc "The highlight fill color (default: transparent)."]
        outlineColor : Types.DOM.RGBA.t option;
            [@key "outlineColor"]
            [@yojson.option]
            [@ocaml.doc "The highlight outline color (default: transparent)."]
      }
      [@@deriving yojson]

      let make ~x ~y ~width ~height ?color ?outlineColor () =
        { x; y; width; height; color; outlineColor }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.highlightRect"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
Issue: the method does not handle device pixel ratio (DPR) correctly.
The coordinates currently have to be adjusted by the client
if DPR is not 1 (see crbug.com/437807128). |desc}]

  module HighlightSourceOrder = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sourceOrderConfig : Types.Overlay.SourceOrderConfig.t;
            [@key "sourceOrderConfig"]
            [@ocaml.doc
              "A descriptor for the appearance of the overlay drawing."]
        nodeId : Types.DOM.NodeId.t option;
            [@key "nodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the node to highlight."]
        backendNodeId : Types.DOM.BackendNodeId.t option;
            [@key "backendNodeId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the backend node to highlight."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc "JavaScript object id of the node to be highlighted."]
      }
      [@@deriving yojson]

      let make ~sourceOrderConfig ?nodeId ?backendNodeId ?objectId () =
        { sourceOrderConfig; nodeId; backendNodeId; objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.highlightSourceOrder"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Highlights the source order of the children of the DOM node with given id or with the given
JavaScript object wrapper. Either nodeId or objectId must be specified. |desc}]

  module SetInspectMode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        mode : Types.Overlay.InspectMode.t;
            [@key "mode"] [@ocaml.doc "Set an inspection mode."]
        highlightConfig : Types.Overlay.HighlightConfig.t option;
            [@key "highlightConfig"]
            [@yojson.option]
            [@ocaml.doc
              "A descriptor for the highlight appearance of hovered-over \
               nodes. May be omitted if `enabled\n\
               == false`."]
      }
      [@@deriving yojson]

      let make ~mode ?highlightConfig () = { mode; highlightConfig }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setInspectMode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
Backend then generates 'inspectNodeRequested' event upon element selection. |desc}]

  module SetShowAdHighlights = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool; [@key "show"] [@ocaml.doc "True for showing ad highlights"]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowAdHighlights"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Highlights owner element of all frames detected to be ads. |desc}]

  module SetPausedInDebuggerMessage = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        message : string option;
            [@key "message"]
            [@yojson.option]
            [@ocaml.doc
              "The message to display, also triggers resume and step over \
               controls."]
      }
      [@@deriving yojson]

      let make ?message () = { message }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.setPausedInDebuggerMessage";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetShowDebugBorders = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool; [@key "show"] [@ocaml.doc "True for showing debug borders"]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowDebugBorders"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Requests that backend shows debug borders on layers |desc}]

  module SetShowFPSCounter = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool;
            [@key "show"] [@ocaml.doc "True for showing the FPS counter"]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowFPSCounter"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Requests that backend shows the FPS counter |desc}]

  module SetShowGridOverlays = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        gridNodeHighlightConfigs : Types.Overlay.GridNodeHighlightConfig.t list;
            [@key "gridNodeHighlightConfigs"]
            [@ocaml.doc
              "An array of node identifiers and descriptors for the highlight \
               appearance."]
      }
      [@@deriving yojson]

      let make ~gridNodeHighlightConfigs () = { gridNodeHighlightConfigs }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowGridOverlays"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Highlight multiple elements with the CSS Grid overlay. |desc}]

  module SetShowFlexOverlays = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        flexNodeHighlightConfigs : Types.Overlay.FlexNodeHighlightConfig.t list;
            [@key "flexNodeHighlightConfigs"]
            [@ocaml.doc
              "An array of node identifiers and descriptors for the highlight \
               appearance."]
      }
      [@@deriving yojson]

      let make ~flexNodeHighlightConfigs () = { flexNodeHighlightConfigs }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowFlexOverlays"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetShowScrollSnapOverlays = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scrollSnapHighlightConfigs :
          Types.Overlay.ScrollSnapHighlightConfig.t list;
            [@key "scrollSnapHighlightConfigs"]
            [@ocaml.doc
              "An array of node identifiers and descriptors for the highlight \
               appearance."]
      }
      [@@deriving yojson]

      let make ~scrollSnapHighlightConfigs () = { scrollSnapHighlightConfigs }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowScrollSnapOverlays"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetShowContainerQueryOverlays = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        containerQueryHighlightConfigs :
          Types.Overlay.ContainerQueryHighlightConfig.t list;
            [@key "containerQueryHighlightConfigs"]
            [@ocaml.doc
              "An array of node identifiers and descriptors for the highlight \
               appearance."]
      }
      [@@deriving yojson]

      let make ~containerQueryHighlightConfigs () =
        { containerQueryHighlightConfigs }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.setShowContainerQueryOverlays";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetShowPaintRects = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        result : bool;
            [@key "result"] [@ocaml.doc "True for showing paint rectangles"]
      }
      [@@deriving yojson]

      let make ~result () = { result }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowPaintRects"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Requests that backend shows paint rectangles |desc}]

  module SetShowLayoutShiftRegions = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        result : bool;
            [@key "result"] [@ocaml.doc "True for showing layout shift regions"]
      }
      [@@deriving yojson]

      let make ~result () = { result }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowLayoutShiftRegions"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Requests that backend shows layout shift regions |desc}]

  module SetShowScrollBottleneckRects = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool;
            [@key "show"]
            [@ocaml.doc "True for showing scroll bottleneck rects"]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.setShowScrollBottleneckRects";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Requests that backend shows scroll bottleneck rects |desc}]

  module SetShowHitTestBorders = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool;
            [@key "show"] [@ocaml.doc "True for showing hit-test borders"]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowHitTestBorders"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Deprecated, no longer has any effect. |desc}]

  module SetShowWebVitals = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool; [@key "show"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowWebVitals"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Deprecated, no longer has any effect. |desc}]

  module SetShowViewportSizeOnResize = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        show : bool; [@key "show"] [@ocaml.doc "Whether to paint size or not."]
      }
      [@@deriving yojson]

      let make ~show () = { show }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.setShowViewportSizeOnResize";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Paints viewport size upon main frame resize. |desc}]

  module SetShowHinge = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        hingeConfig : Types.Overlay.HingeConfig.t option;
            [@key "hingeConfig"]
            [@yojson.option]
            [@ocaml.doc "hinge data, null means hideHinge"]
      }
      [@@deriving yojson]

      let make ?hingeConfig () = { hingeConfig }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowHinge"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Add a dual screen device hinge |desc}]

  module SetShowIsolatedElements = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        isolatedElementHighlightConfigs :
          Types.Overlay.IsolatedElementHighlightConfig.t list;
            [@key "isolatedElementHighlightConfigs"]
            [@ocaml.doc
              "An array of node identifiers and descriptors for the highlight \
               appearance."]
      }
      [@@deriving yojson]

      let make ~isolatedElementHighlightConfigs () =
        { isolatedElementHighlightConfigs }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Overlay.setShowIsolatedElements"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Show elements in isolation mode with overlays. |desc}]

  module SetShowWindowControlsOverlay = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        windowControlsOverlayConfig :
          Types.Overlay.WindowControlsOverlayConfig.t option;
            [@key "windowControlsOverlayConfig"]
            [@yojson.option]
            [@ocaml.doc
              "Window Controls Overlay data, null means hide Window Controls \
               Overlay"]
      }
      [@@deriving yojson]

      let make ?windowControlsOverlayConfig () = { windowControlsOverlayConfig }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Overlay.setShowWindowControlsOverlay";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Show Window Controls Overlay for PWA |desc}]
end

module PWA = struct
  module GetOsAppState = struct
    module Response : sig
      type result = {
        badgeCount : Types.number;
            [@key "badgeCount"] [@ocaml.doc "No description provided"]
        fileHandlers : Types.PWA.FileHandler.t list;
            [@key "fileHandlers"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        badgeCount : Types.number;
            [@key "badgeCount"] [@ocaml.doc "No description provided"]
        fileHandlers : Types.PWA.FileHandler.t list;
            [@key "fileHandlers"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        manifestId : string;
            [@key "manifestId"]
            [@ocaml.doc
              "The id from the webapp's manifest file, commonly it's the url \
               of the\n\
               site installing the webapp. See\n\
               https://web.dev/learn/pwa/web-app-manifest."]
      }
      [@@deriving yojson]

      let make ~manifestId () = { manifestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "PWA.getOsAppState"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the following OS state for the given manifest id. |desc}]

  module Install = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        manifestId : string;
            [@key "manifestId"] [@ocaml.doc "No description provided"]
        installUrlOrBundleUrl : string option;
            [@key "installUrlOrBundleUrl"]
            [@yojson.option]
            [@ocaml.doc
              "The location of the app or bundle overriding the one derived \
               from the\n\
               manifestId."]
      }
      [@@deriving yojson]

      let make ~manifestId ?installUrlOrBundleUrl () =
        { manifestId; installUrlOrBundleUrl }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "PWA.install"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Installs the given manifest identity, optionally using the given installUrlOrBundleUrl

IWA-specific install description:
manifestId corresponds to isolated-app:// + web_package::SignedWebBundleId

File installation mode:
The installUrlOrBundleUrl can be either file:// or http(s):// pointing
to a signed web bundle (.swbn). In this case SignedWebBundleId must correspond to
The .swbn file's signing key.

Dev proxy installation mode:
installUrlOrBundleUrl must be http(s):// that serves dev mode IWA.
web_package::SignedWebBundleId must be of type dev proxy.

The advantage of dev proxy mode is that all changes to IWA
automatically will be reflected in the running app without
reinstallation.

To generate bundle id for proxy mode:
1. Generate 32 random bytes.
2. Add a specific suffix at the end following the documentation
   https://github.com/WICG/isolated-web-apps/blob/main/Scheme.md#suffix
3. Encode the entire sequence using Base32 without padding.

If Chrome is not in IWA dev
mode, the installation will fail, regardless of the state of the allowlist. |desc}]

  module Uninstall = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        manifestId : string;
            [@key "manifestId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~manifestId () = { manifestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "PWA.uninstall"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Uninstalls the given manifest_id and closes any opened app windows. |desc}]

  module Launch = struct
    module Response : sig
      type result = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"]
            [@ocaml.doc "ID of the tab target created as a result."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"]
            [@ocaml.doc "ID of the tab target created as a result."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        manifestId : string;
            [@key "manifestId"] [@ocaml.doc "No description provided"]
        url : string option;
            [@key "url"] [@yojson.option] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~manifestId ?url () = { manifestId; url }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "PWA.launch"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Launches the installed web app, or an url in the same web app instead of the
default start url if it is provided. Returns a page Target.TargetID which
can be used to attach to via Target.attachToTarget or similar APIs. |desc}]

  module LaunchFilesInApp = struct
    module Response : sig
      type result = {
        targetIds : Types.Target.TargetID.t list;
            [@key "targetIds"]
            [@ocaml.doc "IDs of the tab targets created as the result."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        targetIds : Types.Target.TargetID.t list;
            [@key "targetIds"]
            [@ocaml.doc "IDs of the tab targets created as the result."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        manifestId : string;
            [@key "manifestId"] [@ocaml.doc "No description provided"]
        files : string list;
            [@key "files"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~manifestId ~files () = { manifestId; files }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "PWA.launchFilesInApp"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Opens one or more local files from an installed web app identified by its
manifestId. The web app needs to have file handlers registered to process
the files. The API returns one or more page Target.TargetIDs which can be
used to attach to via Target.attachToTarget or similar APIs.
If some files in the parameters cannot be handled by the web app, they will
be ignored. If none of the files can be handled, this API returns an error.
If no files are provided as the parameter, this API also returns an error.

According to the definition of the file handlers in the manifest file, one
Target.TargetID may represent a page handling one or more files. The order
of the returned Target.TargetIDs is not guaranteed.

TODO(crbug.com/339454034): Check the existences of the input files. |desc}]

  module OpenCurrentPageInApp = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        manifestId : string;
            [@key "manifestId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~manifestId () = { manifestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "PWA.openCurrentPageInApp"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Opens the current page in its web app identified by the manifest id, needs
to be called on a page target. This function returns immediately without
waiting for the app to finish loading. |desc}]

  module ChangeAppUserSettings = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        manifestId : string;
            [@key "manifestId"] [@ocaml.doc "No description provided"]
        linkCapturing : bool option;
            [@key "linkCapturing"]
            [@yojson.option]
            [@ocaml.doc
              "If user allows the links clicked on by the user in the app's \
               scope, or\n\
               extended scope if the manifest has scope extensions and the flags\n\
               `DesktopPWAsLinkCapturingWithScopeExtensions` and\n\
               `WebAppEnableScopeExtensions` are enabled.\n\n\
               Note, the API does not support resetting the linkCapturing to the\n\
               initial value, uninstalling and installing the web app again \
               will reset\n\
               it.\n\n\
               TODO(crbug.com/339453269): Setting this value on ChromeOS is not\n\
               supported yet."]
        displayMode : Types.PWA.DisplayMode.t option;
            [@key "displayMode"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~manifestId ?linkCapturing ?displayMode () =
        { manifestId; linkCapturing; displayMode }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "PWA.changeAppUserSettings"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Changes user settings of the web app identified by its manifestId. If the
app was not installed, this command returns an error. Unset parameters will
be ignored; unrecognized values will cause an error.

Unlike the ones defined in the manifest files of the web apps, these
settings are provided by the browser and controlled by the users, they
impact the way the browser handling the web apps.

See the comment of each parameter. |desc}]
end

module Page = struct
  module AddScriptToEvaluateOnLoad = struct
    module Response : sig
      type result = {
        identifier : Types.Page.ScriptIdentifier.t;
            [@key "identifier"] [@ocaml.doc "Identifier of the added script."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        identifier : Types.Page.ScriptIdentifier.t;
            [@key "identifier"] [@ocaml.doc "Identifier of the added script."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptSource : string;
            [@key "scriptSource"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scriptSource () = { scriptSource }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.addScriptToEvaluateOnLoad"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Deprecated, please use addScriptToEvaluateOnNewDocument instead. |desc}]

  module AddScriptToEvaluateOnNewDocument = struct
    module Response : sig
      type result = {
        identifier : Types.Page.ScriptIdentifier.t;
            [@key "identifier"] [@ocaml.doc "Identifier of the added script."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        identifier : Types.Page.ScriptIdentifier.t;
            [@key "identifier"] [@ocaml.doc "Identifier of the added script."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        source : string; [@key "source"] [@ocaml.doc "No description provided"]
        worldName : string option;
            [@key "worldName"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, creates an isolated world with the given name and \
               evaluates given script in it.\n\
               This world name will be used as the \
               ExecutionContextDescription::name when the corresponding\n\
               event is emitted."]
        includeCommandLineAPI : bool option;
            [@key "includeCommandLineAPI"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies whether command line API should be available to the \
               script, defaults\n\
               to false."]
        runImmediately : bool option;
            [@key "runImmediately"]
            [@yojson.option]
            [@ocaml.doc
              "If true, runs the script immediately on existing execution \
               contexts or worlds.\n\
               Default: false."]
      }
      [@@deriving yojson]

      let make ~source ?worldName ?includeCommandLineAPI ?runImmediately () =
        { source; worldName; includeCommandLineAPI; runImmediately }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Page.addScriptToEvaluateOnNewDocument";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Evaluates given script in every frame upon creation (before loading frame's scripts). |desc}]

  module BringToFront = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.bringToFront"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Brings page to front (activates tab). |desc}]

  module CaptureScreenshot = struct
    module Response : sig
      type result = {
        data : string;
            [@key "data"]
            [@ocaml.doc
              "Base64-encoded image data. (Encoded as a base64 string when \
               passed over JSON)"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        data : string;
            [@key "data"]
            [@ocaml.doc
              "Base64-encoded image data. (Encoded as a base64 string when \
               passed over JSON)"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type capturescreenshot_format = [ `jpeg | `png | `webp ]

      let capturescreenshot_format_of_yojson = function
        | `String "jpeg" -> `jpeg
        | `String "png" -> `png
        | `String "webp" -> `webp
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_capturescreenshot_format = function
        | `jpeg -> `String "jpeg"
        | `png -> `String "png"
        | `webp -> `String "webp"

      type t = {
        format : capturescreenshot_format option;
            [@key "format"]
            [@yojson.option]
            [@ocaml.doc "Image compression format (defaults to png)."]
        quality : Types.number option;
            [@key "quality"]
            [@yojson.option]
            [@ocaml.doc "Compression quality from range [0..100] (jpeg only)."]
        clip : Types.Page.Viewport.t option;
            [@key "clip"]
            [@yojson.option]
            [@ocaml.doc "Capture the screenshot of a given region only."]
        fromSurface : bool option;
            [@key "fromSurface"]
            [@yojson.option]
            [@ocaml.doc
              "Capture the screenshot from the surface, rather than the view. \
               Defaults to true."]
        captureBeyondViewport : bool option;
            [@key "captureBeyondViewport"]
            [@yojson.option]
            [@ocaml.doc
              "Capture the screenshot beyond the viewport. Defaults to false."]
        optimizeForSpeed : bool option;
            [@key "optimizeForSpeed"]
            [@yojson.option]
            [@ocaml.doc
              "Optimize image encoding for speed, not for resulting size \
               (defaults to false)"]
      }
      [@@deriving yojson]

      let make ?format ?quality ?clip ?fromSurface ?captureBeyondViewport
          ?optimizeForSpeed () =
        {
          format;
          quality;
          clip;
          fromSurface;
          captureBeyondViewport;
          optimizeForSpeed;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.captureScreenshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Capture page screenshot. |desc}]

  module CaptureSnapshot = struct
    module Response : sig
      type result = {
        data : string; [@key "data"] [@ocaml.doc "Serialized page data."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        data : string; [@key "data"] [@ocaml.doc "Serialized page data."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type capturesnapshot_format = [ `mhtml ]

      let capturesnapshot_format_of_yojson = function
        | `String "mhtml" -> `mhtml
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_capturesnapshot_format = function
        | `mhtml -> `String "mhtml"

      type t = {
        format : capturesnapshot_format option;
            [@key "format"]
            [@yojson.option]
            [@ocaml.doc "Format (defaults to mhtml)."]
      }
      [@@deriving yojson]

      let make ?format () = { format }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.captureSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns a snapshot of the page as a string. For MHTML format, the serialization includes
iframes, shadow DOM, external resources, and element-inline styles. |desc}]

  module ClearDeviceMetricsOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.clearDeviceMetricsOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears the overridden device metrics. |desc}]

  module ClearDeviceOrientationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.clearDeviceOrientationOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears the overridden Device Orientation. |desc}]

  module ClearGeolocationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.clearGeolocationOverride"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Clears the overridden Geolocation Position and Error. |desc}]

  module CreateIsolatedWorld = struct
    module Response : sig
      type result = {
        executionContextId : Types.Runtime.ExecutionContextId.t;
            [@key "executionContextId"]
            [@ocaml.doc "Execution context of the isolated world."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        executionContextId : Types.Runtime.ExecutionContextId.t;
            [@key "executionContextId"]
            [@ocaml.doc "Execution context of the isolated world."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"]
            [@ocaml.doc
              "Id of the frame in which the isolated world should be created."]
        worldName : string option;
            [@key "worldName"]
            [@yojson.option]
            [@ocaml.doc
              "An optional name which is reported in the Execution Context."]
        grantUniveralAccess : bool option;
            [@key "grantUniveralAccess"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not universal access should be granted to the \
               isolated world. This is a powerful\n\
               option, use with caution."]
      }
      [@@deriving yojson]

      let make ~frameId ?worldName ?grantUniveralAccess () =
        { frameId; worldName; grantUniveralAccess }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.createIsolatedWorld"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Creates an isolated world for the given frame. |desc}]

  module DeleteCookie = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cookieName : string;
            [@key "cookieName"] [@ocaml.doc "Name of the cookie to remove."]
        url : string;
            [@key "url"] [@ocaml.doc "URL to match cooke domain and path."]
      }
      [@@deriving yojson]

      let make ~cookieName ~url () = { cookieName; url }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.deleteCookie"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Deletes browser cookie with given name, domain and path. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables page domain notifications. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enableFileChooserOpenedEvent : bool option;
            [@key "enableFileChooserOpenedEvent"]
            [@yojson.option]
            [@ocaml.doc
              "If true, the `Page.fileChooserOpened` event will be emitted \
               regardless of the state set by\n\
               `Page.setInterceptFileChooserDialog` command (default: false)."]
      }
      [@@deriving yojson]

      let make ?enableFileChooserOpenedEvent () =
        { enableFileChooserOpenedEvent }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables page domain notifications. |desc}]

  module GetAppManifest = struct
    module Response : sig
      type result = {
        url : string; [@key "url"] [@ocaml.doc "Manifest location."]
        errors : Types.Page.AppManifestError.t list;
            [@key "errors"] [@ocaml.doc "No description provided"]
        data : string option;
            [@key "data"] [@yojson.option] [@ocaml.doc "Manifest content."]
        parsed : Types.Page.AppManifestParsedProperties.t option;
            [@key "parsed"]
            [@yojson.option]
            [@ocaml.doc
              "Parsed manifest properties. Deprecated, use manifest instead."]
        manifest : Types.Page.WebAppManifest.t;
            [@key "manifest"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        url : string; [@key "url"] [@ocaml.doc "Manifest location."]
        errors : Types.Page.AppManifestError.t list;
            [@key "errors"] [@ocaml.doc "No description provided"]
        data : string option;
            [@key "data"] [@yojson.option] [@ocaml.doc "Manifest content."]
        parsed : Types.Page.AppManifestParsedProperties.t option;
            [@key "parsed"]
            [@yojson.option]
            [@ocaml.doc
              "Parsed manifest properties. Deprecated, use manifest instead."]
        manifest : Types.Page.WebAppManifest.t;
            [@key "manifest"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        manifestId : string option;
            [@key "manifestId"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ?manifestId () = { manifestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.getAppManifest"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Gets the processed manifest for this current document.
  This API always waits for the manifest to be loaded.
  If manifestId is provided, and it does not match the manifest of the
    current document, this API errors out.
  If there is not a loaded page, this API errors out immediately. |desc}]

  module GetInstallabilityErrors = struct
    module Response : sig
      type result = {
        installabilityErrors : Types.Page.InstallabilityError.t list;
            [@key "installabilityErrors"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        installabilityErrors : Types.Page.InstallabilityError.t list;
            [@key "installabilityErrors"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getInstallabilityErrors"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module GetManifestIcons = struct
    module Response : sig
      type result = {
        primaryIcon : string option;
            [@key "primaryIcon"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        primaryIcon : string option;
            [@key "primaryIcon"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getManifestIcons"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation. |desc}]

  module GetAppId = struct
    module Response : sig
      type result = {
        appId : string option;
            [@key "appId"]
            [@yojson.option]
            [@ocaml.doc
              "App id, either from manifest's id attribute or computed from \
               start_url"]
        recommendedId : string option;
            [@key "recommendedId"]
            [@yojson.option]
            [@ocaml.doc
              "Recommendation for manifest's id attribute to match current id \
               computed from start_url"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        appId : string option;
            [@key "appId"]
            [@yojson.option]
            [@ocaml.doc
              "App id, either from manifest's id attribute or computed from \
               start_url"]
        recommendedId : string option;
            [@key "recommendedId"]
            [@yojson.option]
            [@ocaml.doc
              "Recommendation for manifest's id attribute to match current id \
               computed from start_url"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getAppId"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the unique (PWA) app id.
Only returns values if the feature flag 'WebAppEnableManifestId' is enabled |desc}]

  module GetAdScriptAncestry = struct
    module Response : sig
      type result = {
        adScriptAncestry : Types.Page.AdScriptAncestry.t option;
            [@key "adScriptAncestry"]
            [@yojson.option]
            [@ocaml.doc
              "The ancestry chain of ad script identifiers leading to this \
               frame's\n\
               creation, along with the root script's filterlist rule. The \
               ancestry\n\
               chain is ordered from the most immediate script (in the frame \
               creation\n\
               stack) to more distant ancestors (that created the immediately \
               preceding\n\
               script). Only sent if frame is labelled as an ad and ids are \
               available."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        adScriptAncestry : Types.Page.AdScriptAncestry.t option;
            [@key "adScriptAncestry"]
            [@yojson.option]
            [@ocaml.doc
              "The ancestry chain of ad script identifiers leading to this \
               frame's\n\
               creation, along with the root script's filterlist rule. The \
               ancestry\n\
               chain is ordered from the most immediate script (in the frame \
               creation\n\
               stack) to more distant ancestors (that created the immediately \
               preceding\n\
               script). Only sent if frame is labelled as an ad and ids are \
               available."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.getAdScriptAncestry"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module GetFrameTree = struct
    module Response : sig
      type result = {
        frameTree : Types.Page.FrameTree.t;
            [@key "frameTree"] [@ocaml.doc "Present frame tree structure."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        frameTree : Types.Page.FrameTree.t;
            [@key "frameTree"] [@ocaml.doc "Present frame tree structure."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getFrameTree"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns present frame tree structure. |desc}]

  module GetLayoutMetrics = struct
    module Response : sig
      type result = {
        layoutViewport : Types.Page.LayoutViewport.t;
            [@key "layoutViewport"]
            [@ocaml.doc
              "Deprecated metrics relating to the layout viewport. Is in \
               device pixels. Use `cssLayoutViewport` instead."]
        visualViewport : Types.Page.VisualViewport.t;
            [@key "visualViewport"]
            [@ocaml.doc
              "Deprecated metrics relating to the visual viewport. Is in \
               device pixels. Use `cssVisualViewport` instead."]
        contentSize : Types.DOM.Rect.t;
            [@key "contentSize"]
            [@ocaml.doc
              "Deprecated size of scrollable area. Is in DP. Use \
               `cssContentSize` instead."]
        cssLayoutViewport : Types.Page.LayoutViewport.t;
            [@key "cssLayoutViewport"]
            [@ocaml.doc
              "Metrics relating to the layout viewport in CSS pixels."]
        cssVisualViewport : Types.Page.VisualViewport.t;
            [@key "cssVisualViewport"]
            [@ocaml.doc
              "Metrics relating to the visual viewport in CSS pixels."]
        cssContentSize : Types.DOM.Rect.t;
            [@key "cssContentSize"]
            [@ocaml.doc "Size of scrollable area in CSS pixels."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        layoutViewport : Types.Page.LayoutViewport.t;
            [@key "layoutViewport"]
            [@ocaml.doc
              "Deprecated metrics relating to the layout viewport. Is in \
               device pixels. Use `cssLayoutViewport` instead."]
        visualViewport : Types.Page.VisualViewport.t;
            [@key "visualViewport"]
            [@ocaml.doc
              "Deprecated metrics relating to the visual viewport. Is in \
               device pixels. Use `cssVisualViewport` instead."]
        contentSize : Types.DOM.Rect.t;
            [@key "contentSize"]
            [@ocaml.doc
              "Deprecated size of scrollable area. Is in DP. Use \
               `cssContentSize` instead."]
        cssLayoutViewport : Types.Page.LayoutViewport.t;
            [@key "cssLayoutViewport"]
            [@ocaml.doc
              "Metrics relating to the layout viewport in CSS pixels."]
        cssVisualViewport : Types.Page.VisualViewport.t;
            [@key "cssVisualViewport"]
            [@ocaml.doc
              "Metrics relating to the visual viewport in CSS pixels."]
        cssContentSize : Types.DOM.Rect.t;
            [@key "cssContentSize"]
            [@ocaml.doc "Size of scrollable area in CSS pixels."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getLayoutMetrics"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns metrics relating to the layouting of the page, such as viewport bounds/scale. |desc}]

  module GetNavigationHistory = struct
    module Response : sig
      type result = {
        currentIndex : Types.number;
            [@key "currentIndex"]
            [@ocaml.doc "Index of the current navigation history entry."]
        entries : Types.Page.NavigationEntry.t list;
            [@key "entries"] [@ocaml.doc "Array of navigation history entries."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        currentIndex : Types.number;
            [@key "currentIndex"]
            [@ocaml.doc "Index of the current navigation history entry."]
        entries : Types.Page.NavigationEntry.t list;
            [@key "entries"] [@ocaml.doc "Array of navigation history entries."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getNavigationHistory"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns navigation history for the current page. |desc}]

  module ResetNavigationHistory = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.resetNavigationHistory"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Resets navigation history for the current page. |desc}]

  module GetResourceContent = struct
    module Response : sig
      type result = {
        content : string; [@key "content"] [@ocaml.doc "Resource content."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was served as base64."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        content : string; [@key "content"] [@ocaml.doc "Resource content."]
        base64Encoded : bool;
            [@key "base64Encoded"]
            [@ocaml.doc "True, if content was served as base64."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "Frame id to get resource for."]
        url : string;
            [@key "url"] [@ocaml.doc "URL of the resource to get content for."]
      }
      [@@deriving yojson]

      let make ~frameId ~url () = { frameId; url }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.getResourceContent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns content of the given resource. |desc}]

  module GetResourceTree = struct
    module Response : sig
      type result = {
        frameTree : Types.Page.FrameResourceTree.t;
            [@key "frameTree"]
            [@ocaml.doc "Present frame / resource tree structure."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        frameTree : Types.Page.FrameResourceTree.t;
            [@key "frameTree"]
            [@ocaml.doc "Present frame / resource tree structure."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.getResourceTree"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns present frame / resource tree structure. |desc}]

  module HandleJavaScriptDialog = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        accept : bool;
            [@key "accept"]
            [@ocaml.doc "Whether to accept or dismiss the dialog."]
        promptText : string option;
            [@key "promptText"]
            [@yojson.option]
            [@ocaml.doc
              "The text to enter into the dialog prompt before accepting. Used \
               only if this is a prompt\n\
               dialog."]
      }
      [@@deriving yojson]

      let make ~accept ?promptText () = { accept; promptText }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.handleJavaScriptDialog"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). |desc}]

  module Navigate = struct
    module Response : sig
      type result = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"]
            [@ocaml.doc "Frame id that has navigated (or failed to navigate)"]
        loaderId : Types.Network.LoaderId.t option;
            [@key "loaderId"]
            [@yojson.option]
            [@ocaml.doc
              "Loader identifier. This is omitted in case of same-document \
               navigation,\n\
               as the previously committed loaderId would not change."]
        errorText : string option;
            [@key "errorText"]
            [@yojson.option]
            [@ocaml.doc
              "User friendly error message, present if and only if navigation \
               has failed."]
        isDownload : bool option;
            [@key "isDownload"]
            [@yojson.option]
            [@ocaml.doc "Whether the navigation resulted in a download."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"]
            [@ocaml.doc "Frame id that has navigated (or failed to navigate)"]
        loaderId : Types.Network.LoaderId.t option;
            [@key "loaderId"]
            [@yojson.option]
            [@ocaml.doc
              "Loader identifier. This is omitted in case of same-document \
               navigation,\n\
               as the previously committed loaderId would not change."]
        errorText : string option;
            [@key "errorText"]
            [@yojson.option]
            [@ocaml.doc
              "User friendly error message, present if and only if navigation \
               has failed."]
        isDownload : bool option;
            [@key "isDownload"]
            [@yojson.option]
            [@ocaml.doc "Whether the navigation resulted in a download."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        url : string; [@key "url"] [@ocaml.doc "URL to navigate the page to."]
        referrer : string option;
            [@key "referrer"] [@yojson.option] [@ocaml.doc "Referrer URL."]
        transitionType : Types.Page.TransitionType.t option;
            [@key "transitionType"]
            [@yojson.option]
            [@ocaml.doc "Intended transition type."]
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc
              "Frame id to navigate, if not specified navigates the top frame."]
        referrerPolicy : Types.Page.ReferrerPolicy.t option;
            [@key "referrerPolicy"]
            [@yojson.option]
            [@ocaml.doc "Referrer-policy used for the navigation."]
      }
      [@@deriving yojson]

      let make ~url ?referrer ?transitionType ?frameId ?referrerPolicy () =
        { url; referrer; transitionType; frameId; referrerPolicy }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.navigate"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Navigates current page to the given URL. |desc}]

  module NavigateToHistoryEntry = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        entryId : Types.number;
            [@key "entryId"]
            [@ocaml.doc "Unique id of the entry to navigate to."]
      }
      [@@deriving yojson]

      let make ~entryId () = { entryId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.navigateToHistoryEntry"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Navigates current page to the given history entry. |desc}]

  module PrintToPDF = struct
    module Response : sig
      type result = {
        data : string;
            [@key "data"]
            [@ocaml.doc
              "Base64-encoded pdf data. Empty if |returnAsStream| is \
               specified. (Encoded as a base64 string when passed over JSON)"]
        stream : Types.IO.StreamHandle.t option;
            [@key "stream"]
            [@yojson.option]
            [@ocaml.doc "A handle of the stream that holds resulting PDF data."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        data : string;
            [@key "data"]
            [@ocaml.doc
              "Base64-encoded pdf data. Empty if |returnAsStream| is \
               specified. (Encoded as a base64 string when passed over JSON)"]
        stream : Types.IO.StreamHandle.t option;
            [@key "stream"]
            [@yojson.option]
            [@ocaml.doc "A handle of the stream that holds resulting PDF data."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type printtopdf_transfermode = [ `ReturnAsBase64 | `ReturnAsStream ]

      let printtopdf_transfermode_of_yojson = function
        | `String "ReturnAsBase64" -> `ReturnAsBase64
        | `String "ReturnAsStream" -> `ReturnAsStream
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_printtopdf_transfermode = function
        | `ReturnAsBase64 -> `String "ReturnAsBase64"
        | `ReturnAsStream -> `String "ReturnAsStream"

      type t = {
        landscape : bool option;
            [@key "landscape"]
            [@yojson.option]
            [@ocaml.doc "Paper orientation. Defaults to false."]
        displayHeaderFooter : bool option;
            [@key "displayHeaderFooter"]
            [@yojson.option]
            [@ocaml.doc "Display header and footer. Defaults to false."]
        printBackground : bool option;
            [@key "printBackground"]
            [@yojson.option]
            [@ocaml.doc "Print background graphics. Defaults to false."]
        scale : Types.number option;
            [@key "scale"]
            [@yojson.option]
            [@ocaml.doc "Scale of the webpage rendering. Defaults to 1."]
        paperWidth : Types.number option;
            [@key "paperWidth"]
            [@yojson.option]
            [@ocaml.doc "Paper width in inches. Defaults to 8.5 inches."]
        paperHeight : Types.number option;
            [@key "paperHeight"]
            [@yojson.option]
            [@ocaml.doc "Paper height in inches. Defaults to 11 inches."]
        marginTop : Types.number option;
            [@key "marginTop"]
            [@yojson.option]
            [@ocaml.doc "Top margin in inches. Defaults to 1cm (~0.4 inches)."]
        marginBottom : Types.number option;
            [@key "marginBottom"]
            [@yojson.option]
            [@ocaml.doc
              "Bottom margin in inches. Defaults to 1cm (~0.4 inches)."]
        marginLeft : Types.number option;
            [@key "marginLeft"]
            [@yojson.option]
            [@ocaml.doc "Left margin in inches. Defaults to 1cm (~0.4 inches)."]
        marginRight : Types.number option;
            [@key "marginRight"]
            [@yojson.option]
            [@ocaml.doc
              "Right margin in inches. Defaults to 1cm (~0.4 inches)."]
        pageRanges : string option;
            [@key "pageRanges"]
            [@yojson.option]
            [@ocaml.doc
              "Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages \
               are\n\
               printed in the document order, not in the order specified, and no\n\
               more than once.\n\
               Defaults to empty string, which implies the entire document is \
               printed.\n\
               The page numbers are quietly capped to actual page count of the\n\
               document, and ranges beyond the end of the document are ignored.\n\
               If this results in no pages to print, an error is reported.\n\
               It is an error to specify a range with start greater than end."]
        headerTemplate : string option;
            [@key "headerTemplate"]
            [@yojson.option]
            [@ocaml.doc
              "HTML template for the print header. Should be valid HTML markup \
               with following\n\
               classes used to inject printing values into them:\n\
               - `date`: formatted print date\n\
               - `title`: document title\n\
               - `url`: document location\n\
               - `pageNumber`: current page number\n\
               - `totalPages`: total pages in the document\n\n\
               For example, `<span class=title></span>` would generate span \
               containing the title."]
        footerTemplate : string option;
            [@key "footerTemplate"]
            [@yojson.option]
            [@ocaml.doc
              "HTML template for the print footer. Should use the same format \
               as the `headerTemplate`."]
        preferCSSPageSize : bool option;
            [@key "preferCSSPageSize"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not to prefer page size as defined by css. Defaults \
               to false,\n\
               in which case the content will be scaled to fit the paper size."]
        transferMode : printtopdf_transfermode option;
            [@key "transferMode"]
            [@yojson.option]
            [@ocaml.doc "return as stream"]
        generateTaggedPDF : bool option;
            [@key "generateTaggedPDF"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not to generate tagged (accessible) PDF. Defaults to \
               embedder choice."]
        generateDocumentOutline : bool option;
            [@key "generateDocumentOutline"]
            [@yojson.option]
            [@ocaml.doc
              "Whether or not to embed the document outline into the PDF."]
      }
      [@@deriving yojson]

      let make ?landscape ?displayHeaderFooter ?printBackground ?scale
          ?paperWidth ?paperHeight ?marginTop ?marginBottom ?marginLeft
          ?marginRight ?pageRanges ?headerTemplate ?footerTemplate
          ?preferCSSPageSize ?transferMode ?generateTaggedPDF
          ?generateDocumentOutline () =
        {
          landscape;
          displayHeaderFooter;
          printBackground;
          scale;
          paperWidth;
          paperHeight;
          marginTop;
          marginBottom;
          marginLeft;
          marginRight;
          pageRanges;
          headerTemplate;
          footerTemplate;
          preferCSSPageSize;
          transferMode;
          generateTaggedPDF;
          generateDocumentOutline;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.printToPDF"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Print page as PDF. |desc}]

  module Reload = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ignoreCache : bool option;
            [@key "ignoreCache"]
            [@yojson.option]
            [@ocaml.doc
              "If true, browser cache is ignored (as if the user pressed \
               Shift+refresh)."]
        scriptToEvaluateOnLoad : string option;
            [@key "scriptToEvaluateOnLoad"]
            [@yojson.option]
            [@ocaml.doc
              "If set, the script will be injected into all frames of the \
               inspected page after reload.\n\
               Argument will be ignored if reloading dataURL origin."]
        loaderId : Types.Network.LoaderId.t option;
            [@key "loaderId"]
            [@yojson.option]
            [@ocaml.doc
              "If set, an error will be thrown if the target page's main frame's\n\
               loader id does not match the provided id. This prevents \
               accidentally\n\
               reloading an unintended target in case there's a racing \
               navigation."]
      }
      [@@deriving yojson]

      let make ?ignoreCache ?scriptToEvaluateOnLoad ?loaderId () =
        { ignoreCache; scriptToEvaluateOnLoad; loaderId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.reload"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Reloads given page optionally ignoring the cache. |desc}]

  module RemoveScriptToEvaluateOnLoad = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        identifier : Types.Page.ScriptIdentifier.t;
            [@key "identifier"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~identifier () = { identifier }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.removeScriptToEvaluateOnLoad"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Deprecated, please use removeScriptToEvaluateOnNewDocument instead. |desc}]

  module RemoveScriptToEvaluateOnNewDocument = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        identifier : Types.Page.ScriptIdentifier.t;
            [@key "identifier"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~identifier () = { identifier }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Page.removeScriptToEvaluateOnNewDocument";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Removes given script from the list. |desc}]

  module ScreencastFrameAck = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sessionId : Types.number; [@key "sessionId"] [@ocaml.doc "Frame number."]
      }
      [@@deriving yojson]

      let make ~sessionId () = { sessionId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.screencastFrameAck"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Acknowledges that a screencast frame has been received by the frontend. |desc}]

  module SearchInResource = struct
    module Response : sig
      type result = {
        result : Types.Debugger.SearchMatch.t list;
            [@key "result"] [@ocaml.doc "List of search matches."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Debugger.SearchMatch.t list;
            [@key "result"] [@ocaml.doc "List of search matches."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "Frame id for resource to search in."]
        url : string;
            [@key "url"] [@ocaml.doc "URL of the resource to search in."]
        query : string; [@key "query"] [@ocaml.doc "String to search for."]
        caseSensitive : bool option;
            [@key "caseSensitive"]
            [@yojson.option]
            [@ocaml.doc "If true, search is case sensitive."]
        isRegex : bool option;
            [@key "isRegex"]
            [@yojson.option]
            [@ocaml.doc "If true, treats string parameter as regex."]
      }
      [@@deriving yojson]

      let make ~frameId ~url ~query ?caseSensitive ?isRegex () =
        { frameId; url; query; caseSensitive; isRegex }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.searchInResource"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Searches for given string in resource content. |desc}]

  module SetAdBlockingEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool; [@key "enabled"] [@ocaml.doc "Whether to block ads."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setAdBlockingEnabled"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enable Chrome's experimental ad filter on all sites. |desc}]

  module SetBypassCSP = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"] [@ocaml.doc "Whether to bypass page CSP."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setBypassCSP"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enable page Content Security Policy by-passing. |desc}]

  module GetPermissionsPolicyState = struct
    module Response : sig
      type result = {
        states : Types.Page.PermissionsPolicyFeatureState.t list;
            [@key "states"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        states : Types.Page.PermissionsPolicyFeatureState.t list;
            [@key "states"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.getPermissionsPolicyState"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Get Permissions Policy state on given frame. |desc}]

  module GetOriginTrials = struct
    module Response : sig
      type result = {
        originTrials : Types.Page.OriginTrial.t list;
            [@key "originTrials"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        originTrials : Types.Page.OriginTrial.t list;
            [@key "originTrials"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.getOriginTrials"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Get Origin Trials on given frame. |desc}]

  module SetDeviceMetricsOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        width : Types.number;
            [@key "width"]
            [@ocaml.doc
              "Overriding width value in pixels (minimum 0, maximum 10000000). \
               0 disables the override."]
        height : Types.number;
            [@key "height"]
            [@ocaml.doc
              "Overriding height value in pixels (minimum 0, maximum \
               10000000). 0 disables the override."]
        deviceScaleFactor : Types.number;
            [@key "deviceScaleFactor"]
            [@ocaml.doc
              "Overriding device scale factor value. 0 disables the override."]
        mobile : bool;
            [@key "mobile"]
            [@ocaml.doc
              "Whether to emulate mobile device. This includes viewport meta \
               tag, overlay scrollbars, text\n\
               autosizing and more."]
        scale : Types.number option;
            [@key "scale"]
            [@yojson.option]
            [@ocaml.doc "Scale to apply to resulting view image."]
        screenWidth : Types.number option;
            [@key "screenWidth"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding screen width value in pixels (minimum 0, maximum \
               10000000)."]
        screenHeight : Types.number option;
            [@key "screenHeight"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding screen height value in pixels (minimum 0, maximum \
               10000000)."]
        positionX : Types.number option;
            [@key "positionX"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding view X position on screen in pixels (minimum 0, \
               maximum 10000000)."]
        positionY : Types.number option;
            [@key "positionY"]
            [@yojson.option]
            [@ocaml.doc
              "Overriding view Y position on screen in pixels (minimum 0, \
               maximum 10000000)."]
        dontSetVisibleSize : bool option;
            [@key "dontSetVisibleSize"]
            [@yojson.option]
            [@ocaml.doc
              "Do not set visible view size, rely upon explicit setVisibleSize \
               call."]
        screenOrientation : Types.Emulation.ScreenOrientation.t option;
            [@key "screenOrientation"]
            [@yojson.option]
            [@ocaml.doc "Screen orientation override."]
        viewport : Types.Page.Viewport.t option;
            [@key "viewport"]
            [@yojson.option]
            [@ocaml.doc
              "The viewport dimensions and scale. If not set, the override is \
               cleared."]
      }
      [@@deriving yojson]

      let make ~width ~height ~deviceScaleFactor ~mobile ?scale ?screenWidth
          ?screenHeight ?positionX ?positionY ?dontSetVisibleSize
          ?screenOrientation ?viewport () =
        {
          width;
          height;
          deviceScaleFactor;
          mobile;
          scale;
          screenWidth;
          screenHeight;
          positionX;
          positionY;
          dontSetVisibleSize;
          screenOrientation;
          viewport;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setDeviceMetricsOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
query results). |desc}]

  module SetDeviceOrientationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        alpha : Types.number; [@key "alpha"] [@ocaml.doc "Mock alpha"]
        beta : Types.number; [@key "beta"] [@ocaml.doc "Mock beta"]
        gamma : Types.number; [@key "gamma"] [@ocaml.doc "Mock gamma"]
      }
      [@@deriving yojson]

      let make ~alpha ~beta ~gamma () = { alpha; beta; gamma }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setDeviceOrientationOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Overrides the Device Orientation. |desc}]

  module SetFontFamilies = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        fontFamilies : Types.Page.FontFamilies.t;
            [@key "fontFamilies"]
            [@ocaml.doc
              "Specifies font families to set. If a font family is not \
               specified, it won't be changed."]
        forScripts : Types.Page.ScriptFontFamilies.t list option;
            [@key "forScripts"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies font families to set for individual scripts."]
      }
      [@@deriving yojson]

      let make ~fontFamilies ?forScripts () = { fontFamilies; forScripts }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setFontFamilies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Set generic font families. |desc}]

  module SetFontSizes = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        fontSizes : Types.Page.FontSizes.t;
            [@key "fontSizes"]
            [@ocaml.doc
              "Specifies font sizes to set. If a font size is not specified, \
               it won't be changed."]
      }
      [@@deriving yojson]

      let make ~fontSizes () = { fontSizes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setFontSizes"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Set default font sizes. |desc}]

  module SetDocumentContent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "Frame id to set HTML for."]
        html : string; [@key "html"] [@ocaml.doc "HTML content to set."]
      }
      [@@deriving yojson]

      let make ~frameId ~html () = { frameId; html }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setDocumentContent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets given markup as the document's HTML. |desc}]

  module SetDownloadBehavior = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setdownloadbehavior_behavior = [ `deny | `allow | `default ]

      let setdownloadbehavior_behavior_of_yojson = function
        | `String "deny" -> `deny
        | `String "allow" -> `allow
        | `String "default" -> `default
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setdownloadbehavior_behavior = function
        | `deny -> `String "deny"
        | `allow -> `String "allow"
        | `default -> `String "default"

      type t = {
        behavior : setdownloadbehavior_behavior;
            [@key "behavior"]
            [@ocaml.doc
              "Whether to allow all or deny all download requests, or use \
               default Chrome behavior if\n\
               available (otherwise deny)."]
        downloadPath : string option;
            [@key "downloadPath"]
            [@yojson.option]
            [@ocaml.doc
              "The default path to save downloaded files to. This is required \
               if behavior is set to 'allow'"]
      }
      [@@deriving yojson]

      let make ~behavior ?downloadPath () = { behavior; downloadPath }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setDownloadBehavior"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Set the behavior when downloading a file. |desc}]

  module SetGeolocationOverride = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        latitude : Types.number option;
            [@key "latitude"] [@yojson.option] [@ocaml.doc "Mock latitude"]
        longitude : Types.number option;
            [@key "longitude"] [@yojson.option] [@ocaml.doc "Mock longitude"]
        accuracy : Types.number option;
            [@key "accuracy"] [@yojson.option] [@ocaml.doc "Mock accuracy"]
      }
      [@@deriving yojson]

      let make ?latitude ?longitude ?accuracy () =
        { latitude; longitude; accuracy }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setGeolocationOverride"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
unavailable. |desc}]

  module SetLifecycleEventsEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc "If true, starts emitting lifecycle events."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setLifecycleEventsEnabled"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Controls whether page will emit lifecycle events. |desc}]

  module SetTouchEmulationEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type settouchemulationenabled_configuration = [ `mobile | `desktop ]

      let settouchemulationenabled_configuration_of_yojson = function
        | `String "mobile" -> `mobile
        | `String "desktop" -> `desktop
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_settouchemulationenabled_configuration = function
        | `mobile -> `String "mobile"
        | `desktop -> `String "desktop"

      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc "Whether the touch event emulation should be enabled."]
        configuration : settouchemulationenabled_configuration option;
            [@key "configuration"]
            [@yojson.option]
            [@ocaml.doc
              "Touch/gesture events configuration. Default: current platform."]
      }
      [@@deriving yojson]

      let make ~enabled ?configuration () = { enabled; configuration }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setTouchEmulationEnabled"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Toggles mouse event-based touch event emulation. |desc}]

  module StartScreencast = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type startscreencast_format = [ `jpeg | `png ]

      let startscreencast_format_of_yojson = function
        | `String "jpeg" -> `jpeg
        | `String "png" -> `png
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_startscreencast_format = function
        | `jpeg -> `String "jpeg"
        | `png -> `String "png"

      type t = {
        format : startscreencast_format option;
            [@key "format"]
            [@yojson.option]
            [@ocaml.doc "Image compression format."]
        quality : Types.number option;
            [@key "quality"]
            [@yojson.option]
            [@ocaml.doc "Compression quality from range [0..100]."]
        maxWidth : Types.number option;
            [@key "maxWidth"]
            [@yojson.option]
            [@ocaml.doc "Maximum screenshot width."]
        maxHeight : Types.number option;
            [@key "maxHeight"]
            [@yojson.option]
            [@ocaml.doc "Maximum screenshot height."]
        everyNthFrame : Types.number option;
            [@key "everyNthFrame"]
            [@yojson.option]
            [@ocaml.doc "Send every n-th frame."]
      }
      [@@deriving yojson]

      let make ?format ?quality ?maxWidth ?maxHeight ?everyNthFrame () =
        { format; quality; maxWidth; maxHeight; everyNthFrame }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.startScreencast"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Starts sending each frame using the `screencastFrame` event. |desc}]

  module StopLoading = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.stopLoading"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Force the page stop all navigations and pending resource fetches. |desc}]

  module Crash = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.crash"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Crashes renderer on the IO thread, generates minidumps. |desc}]

  module Close = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.close"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Tries to close page, running its beforeunload hooks, if any. |desc}]

  module SetWebLifecycleState = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setweblifecyclestate_state = [ `frozen | `active ]

      let setweblifecyclestate_state_of_yojson = function
        | `String "frozen" -> `frozen
        | `String "active" -> `active
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setweblifecyclestate_state = function
        | `frozen -> `String "frozen"
        | `active -> `String "active"

      type t = {
        state : setweblifecyclestate_state;
            [@key "state"] [@ocaml.doc "Target lifecycle state"]
      }
      [@@deriving yojson]

      let make ~state () = { state }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setWebLifecycleState"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Tries to update the web lifecycle state of the page.
It will transition the page to the given state according to:
https://github.com/WICG/web-lifecycle/ |desc}]

  module StopScreencast = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.stopScreencast"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Stops sending each frame in the `screencastFrame`. |desc}]

  module ProduceCompilationCache = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scripts : Types.Page.CompilationCacheParams.t list;
            [@key "scripts"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scripts () = { scripts }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.produceCompilationCache"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Requests backend to produce compilation cache for the specified scripts.
`scripts` are appended to the list of scripts for which the cache
would be produced. The list may be reset during page navigation.
When script with a matching URL is encountered, the cache is optionally
produced upon backend discretion, based on internal heuristics.
See also: `Page.compilationCacheProduced`. |desc}]

  module AddCompilationCache = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        url : string; [@key "url"] [@ocaml.doc "No description provided"]
        data : string;
            [@key "data"]
            [@ocaml.doc
              "Base64-encoded data (Encoded as a base64 string when passed \
               over JSON)"]
      }
      [@@deriving yojson]

      let make ~url ~data () = { url; data }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.addCompilationCache"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Seeds compilation cache for given url. Compilation cache does not survive
cross-process navigation. |desc}]

  module ClearCompilationCache = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.clearCompilationCache"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears seeded compilation cache. |desc}]

  module SetSPCTransactionMode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setspctransactionmode_mode =
        [ `none
        | `autoAccept
        | `autoChooseToAuthAnotherWay
        | `autoReject
        | `autoOptOut ]

      let setspctransactionmode_mode_of_yojson = function
        | `String "none" -> `none
        | `String "autoAccept" -> `autoAccept
        | `String "autoChooseToAuthAnotherWay" -> `autoChooseToAuthAnotherWay
        | `String "autoReject" -> `autoReject
        | `String "autoOptOut" -> `autoOptOut
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setspctransactionmode_mode = function
        | `none -> `String "none"
        | `autoAccept -> `String "autoAccept"
        | `autoChooseToAuthAnotherWay -> `String "autoChooseToAuthAnotherWay"
        | `autoReject -> `String "autoReject"
        | `autoOptOut -> `String "autoOptOut"

      type t = {
        mode : setspctransactionmode_mode;
            [@key "mode"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~mode () = { mode }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setSPCTransactionMode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets the Secure Payment Confirmation transaction mode.
https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode |desc}]

  module SetRPHRegistrationMode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setrphregistrationmode_mode = [ `none | `autoAccept | `autoReject ]

      let setrphregistrationmode_mode_of_yojson = function
        | `String "none" -> `none
        | `String "autoAccept" -> `autoAccept
        | `String "autoReject" -> `autoReject
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setrphregistrationmode_mode = function
        | `none -> `String "none"
        | `autoAccept -> `String "autoAccept"
        | `autoReject -> `String "autoReject"

      type t = {
        mode : setrphregistrationmode_mode;
            [@key "mode"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~mode () = { mode }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setRPHRegistrationMode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Extensions for Custom Handlers API:
https://html.spec.whatwg.org/multipage/system-state.html#rph-automation |desc}]

  module GenerateTestReport = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        message : string;
            [@key "message"]
            [@ocaml.doc "Message to be displayed in the report."]
        group : string option;
            [@key "group"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies the endpoint group to deliver the report to."]
      }
      [@@deriving yojson]

      let make ~message ?group () = { message; group }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.generateTestReport"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Generates a report for testing. |desc}]

  module WaitForDebugger = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Page.waitForDebugger"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger. |desc}]

  module SetInterceptFileChooserDialog = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool; [@key "enabled"] [@ocaml.doc "No description provided"]
        cancel : bool option;
            [@key "cancel"]
            [@yojson.option]
            [@ocaml.doc
              "If true, cancels the dialog by emitting relevant events (if any)\n\
               in addition to not showing it if the interception is enabled\n\
               (default: false)."]
      }
      [@@deriving yojson]

      let make ~enabled ?cancel () = { enabled; cancel }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Page.setInterceptFileChooserDialog";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Intercept file chooser requests and transfer control to protocol clients.
When file chooser interception is enabled, native file chooser dialog is not shown.
Instead, a protocol event `Page.fileChooserOpened` is emitted. |desc}]

  module SetPrerenderingAllowed = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        isAllowed : bool;
            [@key "isAllowed"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~isAllowed () = { isAllowed }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.setPrerenderingAllowed"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enable/disable prerendering manually.

This command is a short-term solution for https://crbug.com/1440085.
See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
for more details.

TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets. |desc}]

  module GetAnnotatedPageContent = struct
    module Response : sig
      type result = {
        content : string;
            [@key "content"]
            [@ocaml.doc
              "The annotated page content as a base64 encoded protobuf.\n\
               The format is defined by the `AnnotatedPageContent` message in\n\
               components/optimization_guide/proto/features/common_quality_data.proto \
               (Encoded as a base64 string when passed over JSON)"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        content : string;
            [@key "content"]
            [@ocaml.doc
              "The annotated page content as a base64 encoded protobuf.\n\
               The format is defined by the `AnnotatedPageContent` message in\n\
               components/optimization_guide/proto/features/common_quality_data.proto \
               (Encoded as a base64 string when passed over JSON)"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        includeActionableInformation : bool option;
            [@key "includeActionableInformation"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to include actionable information. Defaults to true."]
      }
      [@@deriving yojson]

      let make ?includeActionableInformation () =
        { includeActionableInformation }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Page.getAnnotatedPageContent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Get the annotated page content for the main frame.
This is an experimental command that is subject to change. |desc}]
end

module Performance = struct
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Performance.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disable collecting and reporting metrics. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type enable_timedomain = [ `timeTicks | `threadTicks ]

      let enable_timedomain_of_yojson = function
        | `String "timeTicks" -> `timeTicks
        | `String "threadTicks" -> `threadTicks
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_enable_timedomain = function
        | `timeTicks -> `String "timeTicks"
        | `threadTicks -> `String "threadTicks"

      type t = {
        timeDomain : enable_timedomain option;
            [@key "timeDomain"]
            [@yojson.option]
            [@ocaml.doc
              "Time domain to use for collecting and reporting duration \
               metrics."]
      }
      [@@deriving yojson]

      let make ?timeDomain () = { timeDomain }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Performance.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enable collecting and reporting metrics. |desc}]

  module SetTimeDomain = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type settimedomain_timedomain = [ `timeTicks | `threadTicks ]

      let settimedomain_timedomain_of_yojson = function
        | `String "timeTicks" -> `timeTicks
        | `String "threadTicks" -> `threadTicks
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_settimedomain_timedomain = function
        | `timeTicks -> `String "timeTicks"
        | `threadTicks -> `String "threadTicks"

      type t = {
        timeDomain : settimedomain_timedomain;
            [@key "timeDomain"] [@ocaml.doc "Time domain"]
      }
      [@@deriving yojson]

      let make ~timeDomain () = { timeDomain }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Performance.setTimeDomain"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets time domain to use for collecting and reporting duration metrics.
Note that this must be called before enabling metrics collection. Calling
this method while metrics collection is enabled returns an error. |desc}]

  module GetMetrics = struct
    module Response : sig
      type result = {
        metrics : Types.Performance.Metric.t list;
            [@key "metrics"] [@ocaml.doc "Current values for run-time metrics."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        metrics : Types.Performance.Metric.t list;
            [@key "metrics"] [@ocaml.doc "Current values for run-time metrics."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Performance.getMetrics"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Retrieve current values of run-time metrics. |desc}]
end

module PerformanceTimeline = struct
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventTypes : string list;
            [@key "eventTypes"]
            [@ocaml.doc
              "The types of event to report, as specified in\n\
               https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype\n\
               The specified filter overrides any previous filters, passing \
               empty\n\
               filter disables recording.\n\
               Note that not all types exposed to the web platform are \
               currently supported."]
      }
      [@@deriving yojson]

      let make ~eventTypes () = { eventTypes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "PerformanceTimeline.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Previously buffered events would be reported before method returns.
See also: timelineEventAdded |desc}]
end

module Preload = struct
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Preload.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Preload.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]
end

module Security = struct
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Security.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables tracking security state changes. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Security.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables tracking security state changes. |desc}]

  module SetIgnoreCertificateErrors = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ignore : bool;
            [@key "ignore"]
            [@ocaml.doc "If true, all certificate errors will be ignored."]
      }
      [@@deriving yojson]

      let make ~ignore () = { ignore }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Security.setIgnoreCertificateErrors";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enable/disable whether all certificate errors should be ignored. |desc}]

  module HandleCertificateError = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        eventId : Types.number;
            [@key "eventId"] [@ocaml.doc "The ID of the event."]
        action : Types.Security.CertificateErrorAction.t;
            [@key "action"]
            [@ocaml.doc "The action to take on the certificate error."]
      }
      [@@deriving yojson]

      let make ~eventId ~action () = { eventId; action }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Security.handleCertificateError"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Handles a certificate error that fired a certificateError event. |desc}]

  module SetOverrideCertificateErrors = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        override : bool;
            [@key "override"]
            [@ocaml.doc "If true, certificate errors will be overridden."]
      }
      [@@deriving yojson]

      let make ~override () = { override }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Security.setOverrideCertificateErrors";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enable/disable overriding certificate errors. If enabled, all certificate error events need to
be handled by the DevTools client and should be answered with `handleCertificateError` commands. |desc}]
end

module ServiceWorker = struct
  module DeliverPushMessage = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "No description provided"]
        registrationId : Types.ServiceWorker.RegistrationID.t;
            [@key "registrationId"] [@ocaml.doc "No description provided"]
        data : string; [@key "data"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~origin ~registrationId ~data () =
        { origin; registrationId; data }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.deliverPushMessage"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "ServiceWorker.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module DispatchSyncEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "No description provided"]
        registrationId : Types.ServiceWorker.RegistrationID.t;
            [@key "registrationId"] [@ocaml.doc "No description provided"]
        tag : string; [@key "tag"] [@ocaml.doc "No description provided"]
        lastChance : bool;
            [@key "lastChance"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~origin ~registrationId ~tag ~lastChance () =
        { origin; registrationId; tag; lastChance }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.dispatchSyncEvent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module DispatchPeriodicSyncEvent = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "No description provided"]
        registrationId : Types.ServiceWorker.RegistrationID.t;
            [@key "registrationId"] [@ocaml.doc "No description provided"]
        tag : string; [@key "tag"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~origin ~registrationId ~tag () = { origin; registrationId; tag }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "ServiceWorker.dispatchPeriodicSyncEvent";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "ServiceWorker.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetForceUpdateOnPageLoad = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        forceUpdateOnPageLoad : bool;
            [@key "forceUpdateOnPageLoad"]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~forceUpdateOnPageLoad () = { forceUpdateOnPageLoad }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "ServiceWorker.setForceUpdateOnPageLoad";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SkipWaiting = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scopeURL : string;
            [@key "scopeURL"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scopeURL () = { scopeURL }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.skipWaiting"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module StartWorker = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scopeURL : string;
            [@key "scopeURL"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scopeURL () = { scopeURL }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.startWorker"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module StopAllWorkers = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "ServiceWorker.stopAllWorkers"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module StopWorker = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        versionId : string;
            [@key "versionId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~versionId () = { versionId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.stopWorker"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module Unregister = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scopeURL : string;
            [@key "scopeURL"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scopeURL () = { scopeURL }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.unregister"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module UpdateRegistration = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scopeURL : string;
            [@key "scopeURL"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scopeURL () = { scopeURL }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "ServiceWorker.updateRegistration"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]
end

module SmartCardEmulation = struct
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "SmartCardEmulation.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables the |SmartCardEmulation| domain. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "SmartCardEmulation.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables the |SmartCardEmulation| domain. |desc}]

  module ReportEstablishContextResult = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : string;
            [@key "requestId"] [@ocaml.doc "No description provided"]
        contextId : Types.number;
            [@key "contextId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~requestId ~contextId () = { requestId; contextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "SmartCardEmulation.reportEstablishContextResult";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Reports the successful result of a |SCardEstablishContext| call.

This maps to:
PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gaa1b8970169fd4883a6dc4a8f43f19b67
Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardestablishcontext |desc}]

  module ReportReleaseContextResult = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : string;
            [@key "requestId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "SmartCardEmulation.reportReleaseContextResult";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Reports the successful result of a |SCardReleaseContext| call.

This maps to:
PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga6aabcba7744c5c9419fdd6404f73a934
Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardreleasecontext |desc}]

  module ReportListReadersResult = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : string;
            [@key "requestId"] [@ocaml.doc "No description provided"]
        readers : string list;
            [@key "readers"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~requestId ~readers () = { requestId; readers }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "SmartCardEmulation.reportListReadersResult";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Reports the successful result of a |SCardListReaders| call.

This maps to:
PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga93b07815789b3cf2629d439ecf20f0d9
Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardlistreadersa |desc}]

  module ReportGetStatusChangeResult = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : string;
            [@key "requestId"] [@ocaml.doc "No description provided"]
        readerStates : Types.SmartCardEmulation.ReaderStateOut.t list;
            [@key "readerStates"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~requestId ~readerStates () = { requestId; readerStates }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "SmartCardEmulation.reportGetStatusChangeResult";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Reports the successful result of a |SCardGetStatusChange| call.

This maps to:
PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga33247d5d1257d59e55647c3bb717db24
Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetstatuschangea |desc}]

  module ReportBeginTransactionResult = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : string;
            [@key "requestId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "SmartCardEmulation.reportBeginTransactionResult";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Reports the result of a |SCardBeginTransaction| call.
On success, this creates a new transaction object.

This maps to:
PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gaddb835dce01a0da1d6ca02d33ee7d861
Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardbegintransaction |desc}]

  module ReportPlainResult = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : string;
            [@key "requestId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~requestId () = { requestId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "SmartCardEmulation.reportPlainResult";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Reports the successful result of a call that returns only a result code.
Used for: |SCardCancel|, |SCardDisconnect|, |SCardSetAttrib|, |SCardEndTransaction|.

This maps to:
1. SCardCancel
   PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gaacbbc0c6d6c0cbbeb4f4debf6fbeeee6
   Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardcancel

2. SCardDisconnect
   PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga4be198045c73ec0deb79e66c0ca1738a
   Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scarddisconnect

3. SCardSetAttrib
   PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga060f0038a4ddfd5dd2b8fadf3c3a2e4f
   Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardsetattrib

4. SCardEndTransaction
   PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gae8742473b404363e5c587f570d7e2f3b
   Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardendtransaction |desc}]

  module ReportConnectResult = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : string;
            [@key "requestId"] [@ocaml.doc "No description provided"]
        handle : Types.number;
            [@key "handle"] [@ocaml.doc "No description provided"]
        activeProtocol : Types.SmartCardEmulation.Protocol.t option;
            [@key "activeProtocol"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~requestId ~handle ?activeProtocol () =
        { requestId; handle; activeProtocol }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "SmartCardEmulation.reportConnectResult";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Reports the successful result of a |SCardConnect| call.

This maps to:
PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga4e515829752e0a8dbc4d630696a8d6a5
Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardconnecta |desc}]

  module ReportDataResult = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : string;
            [@key "requestId"] [@ocaml.doc "No description provided"]
        data : string; [@key "data"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~requestId ~data () = { requestId; data }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "SmartCardEmulation.reportDataResult";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Reports the successful result of a call that sends back data on success.
Used for |SCardTransmit|, |SCardControl|, and |SCardGetAttrib|.

This maps to:
1. SCardTransmit
   PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga9a2d77242a271310269065e64633ab99
   Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardtransmit

2. SCardControl
   PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gac3454d4657110fd7f753b2d3d8f4e32f
   Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardcontrol

3. SCardGetAttrib
   PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gaacfec51917255b7a25b94c5104961602
   Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetattrib |desc}]

  module ReportStatusResult = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : string;
            [@key "requestId"] [@ocaml.doc "No description provided"]
        readerName : string;
            [@key "readerName"] [@ocaml.doc "No description provided"]
        state : Types.SmartCardEmulation.ConnectionState.t;
            [@key "state"] [@ocaml.doc "No description provided"]
        atr : string; [@key "atr"] [@ocaml.doc "No description provided"]
        protocol : Types.SmartCardEmulation.Protocol.t option;
            [@key "protocol"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~requestId ~readerName ~state ~atr ?protocol () =
        { requestId; readerName; state; atr; protocol }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "SmartCardEmulation.reportStatusResult";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Reports the successful result of a |SCardStatus| call.

This maps to:
PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gae49c3c894ad7ac12a5b896bde70d0382
Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardstatusa |desc}]

  module ReportError = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        requestId : string;
            [@key "requestId"] [@ocaml.doc "No description provided"]
        resultCode : Types.SmartCardEmulation.ResultCode.t;
            [@key "resultCode"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~requestId ~resultCode () = { requestId; resultCode }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "SmartCardEmulation.reportError"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Reports an error result for the given request. |desc}]
end

module Storage = struct
  module GetStorageKeyForFrame = struct
    module Response : sig
      type result = {
        storageKey : Types.Storage.SerializedStorageKey.t;
            [@key "storageKey"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        storageKey : Types.Storage.SerializedStorageKey.t;
            [@key "storageKey"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t;
            [@key "frameId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getStorageKeyForFrame"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns a storage key given a frame id.
Deprecated. Please use Storage.getStorageKey instead. |desc}]

  module GetStorageKey = struct
    module Response : sig
      type result = {
        storageKey : Types.Storage.SerializedStorageKey.t;
            [@key "storageKey"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        storageKey : Types.Storage.SerializedStorageKey.t;
            [@key "storageKey"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        frameId : Types.Page.FrameId.t option;
            [@key "frameId"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ?frameId () = { frameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getStorageKey"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns storage key for the given frame. If no frame ID is provided,
the storage key of the target executing this command is returned. |desc}]

  module ClearDataForOrigin = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
        storageTypes : string;
            [@key "storageTypes"]
            [@ocaml.doc "Comma separated list of StorageType to clear."]
      }
      [@@deriving yojson]

      let make ~origin ~storageTypes () = { origin; storageTypes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.clearDataForOrigin"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears storage for origin. |desc}]

  module ClearDataForStorageKey = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageKey : string; [@key "storageKey"] [@ocaml.doc "Storage key."]
        storageTypes : string;
            [@key "storageTypes"]
            [@ocaml.doc "Comma separated list of StorageType to clear."]
      }
      [@@deriving yojson]

      let make ~storageKey ~storageTypes () = { storageKey; storageTypes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.clearDataForStorageKey"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears storage for storage key. |desc}]

  module GetCookies = struct
    module Response : sig
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        cookies : Types.Network.Cookie.t list;
            [@key "cookies"] [@ocaml.doc "Array of cookie objects."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Browser context to use when called on the browser endpoint."]
      }
      [@@deriving yojson]

      let make ?browserContextId () = { browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getCookies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns all browser cookies. |desc}]

  module SetCookies = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        cookies : Types.Network.CookieParam.t list;
            [@key "cookies"] [@ocaml.doc "Cookies to be set."]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Browser context to use when called on the browser endpoint."]
      }
      [@@deriving yojson]

      let make ~cookies ?browserContextId () = { cookies; browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.setCookies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets given cookies. |desc}]

  module ClearCookies = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Browser context to use when called on the browser endpoint."]
      }
      [@@deriving yojson]

      let make ?browserContextId () = { browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.clearCookies"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Clears cookies. |desc}]

  module GetUsageAndQuota = struct
    module Response : sig
      type result = {
        usage : Types.number;
            [@key "usage"] [@ocaml.doc "Storage usage (bytes)."]
        quota : Types.number;
            [@key "quota"] [@ocaml.doc "Storage quota (bytes)."]
        overrideActive : bool;
            [@key "overrideActive"]
            [@ocaml.doc
              "Whether or not the origin has an active storage quota override"]
        usageBreakdown : Types.Storage.UsageForType.t list;
            [@key "usageBreakdown"]
            [@ocaml.doc "Storage usage per type (bytes)."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        usage : Types.number;
            [@key "usage"] [@ocaml.doc "Storage usage (bytes)."]
        quota : Types.number;
            [@key "quota"] [@ocaml.doc "Storage quota (bytes)."]
        overrideActive : bool;
            [@key "overrideActive"]
            [@ocaml.doc
              "Whether or not the origin has an active storage quota override"]
        usageBreakdown : Types.Storage.UsageForType.t list;
            [@key "usageBreakdown"]
            [@ocaml.doc "Storage usage per type (bytes)."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getUsageAndQuota"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns usage and quota in bytes. |desc}]

  module OverrideQuotaForOrigin = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
        quotaSize : Types.number option;
            [@key "quotaSize"]
            [@yojson.option]
            [@ocaml.doc
              "The quota size (in bytes) to override the original quota with.\n\
               If this is called multiple times, the overridden quota will be \
               equal to\n\
               the quotaSize provided in the final call. If this is called \
               without\n\
               specifying a quotaSize, the quota will be reset to the default \
               value for\n\
               the specified origin. If this is called multiple times with \
               different\n\
               origins, the override will be maintained for each origin until \
               it is\n\
               disabled (called without a quotaSize)."]
      }
      [@@deriving yojson]

      let make ~origin ?quotaSize () = { origin; quotaSize }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.overrideQuotaForOrigin"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Override quota for the specified origin |desc}]

  module TrackCacheStorageForOrigin = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.trackCacheStorageForOrigin";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Registers origin to be notified when an update occurs to its cache storage list. |desc}]

  module TrackCacheStorageForStorageKey = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageKey : string; [@key "storageKey"] [@ocaml.doc "Storage key."]
      }
      [@@deriving yojson]

      let make ~storageKey () = { storageKey }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.trackCacheStorageForStorageKey";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Registers storage key to be notified when an update occurs to its cache storage list. |desc}]

  module TrackIndexedDBForOrigin = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.trackIndexedDBForOrigin"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Registers origin to be notified when an update occurs to its IndexedDB. |desc}]

  module TrackIndexedDBForStorageKey = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageKey : string; [@key "storageKey"] [@ocaml.doc "Storage key."]
      }
      [@@deriving yojson]

      let make ~storageKey () = { storageKey }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.trackIndexedDBForStorageKey";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Registers storage key to be notified when an update occurs to its IndexedDB. |desc}]

  module UntrackCacheStorageForOrigin = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.untrackCacheStorageForOrigin";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Unregisters origin from receiving notifications for cache storage. |desc}]

  module UntrackCacheStorageForStorageKey = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageKey : string; [@key "storageKey"] [@ocaml.doc "Storage key."]
      }
      [@@deriving yojson]

      let make ~storageKey () = { storageKey }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.untrackCacheStorageForStorageKey";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Unregisters storage key from receiving notifications for cache storage. |desc}]

  module UntrackIndexedDBForOrigin = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        origin : string; [@key "origin"] [@ocaml.doc "Security origin."]
      }
      [@@deriving yojson]

      let make ~origin () = { origin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.untrackIndexedDBForOrigin"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Unregisters origin from receiving notifications for IndexedDB. |desc}]

  module UntrackIndexedDBForStorageKey = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageKey : string; [@key "storageKey"] [@ocaml.doc "Storage key."]
      }
      [@@deriving yojson]

      let make ~storageKey () = { storageKey }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.untrackIndexedDBForStorageKey";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Unregisters storage key from receiving notifications for IndexedDB. |desc}]

  module GetTrustTokens = struct
    module Response : sig
      type result = {
        tokens : Types.Storage.TrustTokens.t list;
            [@key "tokens"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        tokens : Types.Storage.TrustTokens.t list;
            [@key "tokens"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Storage.getTrustTokens"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the number of stored Trust Tokens per issuer for the
current browsing context. |desc}]

  module ClearTrustTokens = struct
    module Response : sig
      type result = {
        didDeleteTokens : bool;
            [@key "didDeleteTokens"]
            [@ocaml.doc "True if any tokens were deleted, false otherwise."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        didDeleteTokens : bool;
            [@key "didDeleteTokens"]
            [@ocaml.doc "True if any tokens were deleted, false otherwise."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        issuerOrigin : string;
            [@key "issuerOrigin"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~issuerOrigin () = { issuerOrigin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.clearTrustTokens"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Removes all Trust Tokens issued by the provided issuerOrigin.
Leaves other stored data, including the issuer's Redemption Records, intact. |desc}]

  module GetInterestGroupDetails = struct
    module Response : sig
      type result = {
        details : Types.assoc;
            [@key "details"]
            [@ocaml.doc
              "This largely corresponds to:\n\
               https://wicg.github.io/turtledove/#dictdef-generatebidinterestgroup\n\
               but has absolute expirationTime instead of relative lifetimeMs \
               and\n\
               also adds joiningOrigin."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        details : Types.assoc;
            [@key "details"]
            [@ocaml.doc
              "This largely corresponds to:\n\
               https://wicg.github.io/turtledove/#dictdef-generatebidinterestgroup\n\
               but has absolute expirationTime instead of relative lifetimeMs \
               and\n\
               also adds joiningOrigin."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
        name : string; [@key "name"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~ownerOrigin ~name () = { ownerOrigin; name }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getInterestGroupDetails"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Gets details for a named interest group. |desc}]

  module SetInterestGroupTracking = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enable : bool; [@key "enable"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enable () = { enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.setInterestGroupTracking"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables/Disables issuing of interestGroupAccessed events. |desc}]

  module SetInterestGroupAuctionTracking = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enable : bool; [@key "enable"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enable () = { enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.setInterestGroupAuctionTracking";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables/Disables issuing of interestGroupAuctionEventOccurred and
interestGroupAuctionNetworkRequestCreated. |desc}]

  module GetSharedStorageMetadata = struct
    module Response : sig
      type result = {
        metadata : Types.Storage.SharedStorageMetadata.t;
            [@key "metadata"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        metadata : Types.Storage.SharedStorageMetadata.t;
            [@key "metadata"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~ownerOrigin () = { ownerOrigin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getSharedStorageMetadata"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Gets metadata for an origin's shared storage. |desc}]

  module GetSharedStorageEntries = struct
    module Response : sig
      type result = {
        entries : Types.Storage.SharedStorageEntry.t list;
            [@key "entries"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        entries : Types.Storage.SharedStorageEntry.t list;
            [@key "entries"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~ownerOrigin () = { ownerOrigin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.getSharedStorageEntries"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Gets the entries in an given origin's shared storage. |desc}]

  module SetSharedStorageEntry = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
        key : string; [@key "key"] [@ocaml.doc "No description provided"]
        value : string; [@key "value"] [@ocaml.doc "No description provided"]
        ignoreIfPresent : bool option;
            [@key "ignoreIfPresent"]
            [@yojson.option]
            [@ocaml.doc
              "If `ignoreIfPresent` is included and true, then only sets the \
               entry if\n\
               `key` doesn't already exist."]
      }
      [@@deriving yojson]

      let make ~ownerOrigin ~key ~value ?ignoreIfPresent () =
        { ownerOrigin; key; value; ignoreIfPresent }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.setSharedStorageEntry"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets entry with `key` and `value` for a given origin's shared storage. |desc}]

  module DeleteSharedStorageEntry = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
        key : string; [@key "key"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~ownerOrigin ~key () = { ownerOrigin; key }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.deleteSharedStorageEntry"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Deletes entry for `key` (if it exists) for a given origin's shared storage. |desc}]

  module ClearSharedStorageEntries = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~ownerOrigin () = { ownerOrigin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.clearSharedStorageEntries"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Clears all entries for a given origin's shared storage. |desc}]

  module ResetSharedStorageBudget = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        ownerOrigin : string;
            [@key "ownerOrigin"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~ownerOrigin () = { ownerOrigin }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.resetSharedStorageBudget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Resets the budget for `ownerOrigin` by clearing all budget withdrawals. |desc}]

  module SetSharedStorageTracking = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enable : bool; [@key "enable"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enable () = { enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.setSharedStorageTracking"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables/disables issuing of sharedStorageAccessed events. |desc}]

  module SetStorageBucketTracking = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        storageKey : string;
            [@key "storageKey"] [@ocaml.doc "No description provided"]
        enable : bool; [@key "enable"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~storageKey ~enable () = { storageKey; enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.setStorageBucketTracking"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Set tracking for a storage key's buckets. |desc}]

  module DeleteStorageBucket = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        bucket : Types.Storage.StorageBucket.t;
            [@key "bucket"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~bucket () = { bucket }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Storage.deleteStorageBucket"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Deletes the Storage Bucket with the given storage key and bucket name. |desc}]

  module RunBounceTrackingMitigations = struct
    module Response : sig
      type result = {
        deletedSites : string list;
            [@key "deletedSites"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        deletedSites : string list;
            [@key "deletedSites"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Storage.runBounceTrackingMitigations"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Deletes state for sites identified as potential bounce trackers, immediately. |desc}]

  module SetAttributionReportingLocalTestingMode = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool;
            [@key "enabled"]
            [@ocaml.doc
              "If enabled, noise is suppressed and reports are sent \
               immediately."]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.setAttributionReportingLocalTestingMode";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|https://wicg.github.io/attribution-reporting-api/ |desc}]

  module SetAttributionReportingTracking = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enable : bool; [@key "enable"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enable () = { enable }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.setAttributionReportingTracking";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables/disables issuing of Attribution Reporting events. |desc}]

  module SendPendingAttributionReports = struct
    module Response : sig
      type result = {
        numSent : Types.number;
            [@key "numSent"]
            [@ocaml.doc "The number of reports that were sent."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        numSent : Types.number;
            [@key "numSent"]
            [@ocaml.doc "The number of reports that were sent."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Storage.sendPendingAttributionReports"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sends all pending Attribution Reports immediately, regardless of their
scheduled report time. |desc}]

  module GetRelatedWebsiteSets = struct
    module Response : sig
      type result = {
        sets : Types.Storage.RelatedWebsiteSet.t list;
            [@key "sets"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        sets : Types.Storage.RelatedWebsiteSet.t list;
            [@key "sets"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Storage.getRelatedWebsiteSets"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the effective Related Website Sets in use by this profile for the browser
session. The effective Related Website Sets will not change during a browser session. |desc}]

  module GetAffectedUrlsForThirdPartyCookieMetadata = struct
    module Response : sig
      type result = {
        matchedUrls : string list;
            [@key "matchedUrls"]
            [@ocaml.doc
              "Array of matching URLs. If there is a primary pattern match for \
               the first-\n\
               party URL, only the first-party URL is returned in the array."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        matchedUrls : string list;
            [@key "matchedUrls"]
            [@ocaml.doc
              "Array of matching URLs. If there is a primary pattern match for \
               the first-\n\
               party URL, only the first-party URL is returned in the array."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        firstPartyUrl : string;
            [@key "firstPartyUrl"]
            [@ocaml.doc "The URL of the page currently being visited."]
        thirdPartyUrls : string list;
            [@key "thirdPartyUrls"]
            [@ocaml.doc "The list of embedded resource URLs from the page."]
      }
      [@@deriving yojson]

      let make ~firstPartyUrl ~thirdPartyUrls () =
        { firstPartyUrl; thirdPartyUrls }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.getAffectedUrlsForThirdPartyCookieMetadata";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the list of URLs from a page and its embedded resources that match
existing grace period URL pattern rules.
https://developers.google.com/privacy-sandbox/cookies/temporary-exceptions/grace-period |desc}]

  module SetProtectedAudienceKAnonymity = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        owner : string; [@key "owner"] [@ocaml.doc "No description provided"]
        name : string; [@key "name"] [@ocaml.doc "No description provided"]
        hashes : string list;
            [@key "hashes"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~owner ~name ~hashes () = { owner; name; hashes }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Storage.setProtectedAudienceKAnonymity";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]
end

module SystemInfo = struct
  module GetInfo = struct
    module Response : sig
      type result = {
        gpu : Types.SystemInfo.GPUInfo.t;
            [@key "gpu"]
            [@ocaml.doc "Information about the GPUs on the system."]
        modelName : string;
            [@key "modelName"]
            [@ocaml.doc
              "A platform-dependent description of the model of the machine. \
               On Mac OS, this is, for\n\
               example, 'MacBookPro'. Will be the empty string if not \
               supported."]
        modelVersion : string;
            [@key "modelVersion"]
            [@ocaml.doc
              "A platform-dependent description of the version of the machine. \
               On Mac OS, this is, for\n\
               example, '10.1'. Will be the empty string if not supported."]
        commandLine : string;
            [@key "commandLine"]
            [@ocaml.doc
              "The command line string used to launch the browser. Will be the \
               empty string if not\n\
               supported."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        gpu : Types.SystemInfo.GPUInfo.t;
            [@key "gpu"]
            [@ocaml.doc "Information about the GPUs on the system."]
        modelName : string;
            [@key "modelName"]
            [@ocaml.doc
              "A platform-dependent description of the model of the machine. \
               On Mac OS, this is, for\n\
               example, 'MacBookPro'. Will be the empty string if not \
               supported."]
        modelVersion : string;
            [@key "modelVersion"]
            [@ocaml.doc
              "A platform-dependent description of the version of the machine. \
               On Mac OS, this is, for\n\
               example, '10.1'. Will be the empty string if not supported."]
        commandLine : string;
            [@key "commandLine"]
            [@ocaml.doc
              "The command line string used to launch the browser. Will be the \
               empty string if not\n\
               supported."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "SystemInfo.getInfo"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns information about the system. |desc}]

  module GetFeatureState = struct
    module Response : sig
      type result = {
        featureEnabled : bool;
            [@key "featureEnabled"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        featureEnabled : bool;
            [@key "featureEnabled"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        featureState : string;
            [@key "featureState"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~featureState () = { featureState }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "SystemInfo.getFeatureState"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns information about the feature state. |desc}]

  module GetProcessInfo = struct
    module Response : sig
      type result = {
        processInfo : Types.SystemInfo.ProcessInfo.t list;
            [@key "processInfo"] [@ocaml.doc "An array of process info blocks."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        processInfo : Types.SystemInfo.ProcessInfo.t list;
            [@key "processInfo"] [@ocaml.doc "An array of process info blocks."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "SystemInfo.getProcessInfo"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns information about all running processes. |desc}]
end

module Target = struct
  module ActivateTarget = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~targetId () = { targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.activateTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Activates (focuses) the target. |desc}]

  module AttachToTarget = struct
    module Response : sig
      type result = {
        sessionId : Types.Target.SessionID.t;
            [@key "sessionId"] [@ocaml.doc "Id assigned to the session."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        sessionId : Types.Target.SessionID.t;
            [@key "sessionId"] [@ocaml.doc "Id assigned to the session."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "No description provided"]
        flatten : bool option;
            [@key "flatten"]
            [@yojson.option]
            [@ocaml.doc
              "Enables \"flat\" access to the session via specifying sessionId \
               attribute in the commands.\n\
               We plan to make this the default, deprecate non-flattened mode,\n\
               and eventually retire it. See crbug.com/991325."]
      }
      [@@deriving yojson]

      let make ~targetId ?flatten () = { targetId; flatten }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.attachToTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Attaches to the target with given id. |desc}]

  module AttachToBrowserTarget = struct
    module Response : sig
      type result = {
        sessionId : Types.Target.SessionID.t;
            [@key "sessionId"] [@ocaml.doc "Id assigned to the session."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        sessionId : Types.Target.SessionID.t;
            [@key "sessionId"] [@ocaml.doc "Id assigned to the session."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Target.attachToBrowserTarget"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Attaches to the browser target, only uses flat sessionId mode. |desc}]

  module CloseTarget = struct
    module Response : sig
      type result = {
        success : bool;
            [@key "success"]
            [@ocaml.doc
              "Always set to true. If an error occurs, the response indicates \
               protocol error."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        success : bool;
            [@key "success"]
            [@ocaml.doc
              "Always set to true. If an error occurs, the response indicates \
               protocol error."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~targetId () = { targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.closeTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Closes the target. If the target is a page that gets closed too. |desc}]

  module ExposeDevToolsProtocol = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "No description provided"]
        bindingName : string option;
            [@key "bindingName"]
            [@yojson.option]
            [@ocaml.doc "Binding name, 'cdp' if not specified."]
        inheritPermissions : bool option;
            [@key "inheritPermissions"]
            [@yojson.option]
            [@ocaml.doc
              "If true, inherits the current root session's permissions \
               (default: false)."]
      }
      [@@deriving yojson]

      let make ~targetId ?bindingName ?inheritPermissions () =
        { targetId; bindingName; inheritPermissions }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.exposeDevToolsProtocol"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Inject object to the target's main frame that provides a communication
channel with browser target.

Injected object will be available as `window[bindingName]`.

The object has the following API:
- `binding.send(json)` - a method to send messages over the remote debugging protocol
- `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses. |desc}]

  module CreateBrowserContext = struct
    module Response : sig
      type result = {
        browserContextId : Types.Browser.BrowserContextID.t;
            [@key "browserContextId"]
            [@ocaml.doc "The id of the context created."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        browserContextId : Types.Browser.BrowserContextID.t;
            [@key "browserContextId"]
            [@ocaml.doc "The id of the context created."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        disposeOnDetach : bool option;
            [@key "disposeOnDetach"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, disposes this context when debugging session \
               disconnects."]
        proxyServer : string option;
            [@key "proxyServer"]
            [@yojson.option]
            [@ocaml.doc
              "Proxy server, similar to the one passed to --proxy-server"]
        proxyBypassList : string option;
            [@key "proxyBypassList"]
            [@yojson.option]
            [@ocaml.doc
              "Proxy bypass list, similar to the one passed to \
               --proxy-bypass-list"]
        originsWithUniversalNetworkAccess : string list option;
            [@key "originsWithUniversalNetworkAccess"]
            [@yojson.option]
            [@ocaml.doc
              "An optional list of origins to grant unlimited cross-origin \
               access to.\n\
               Parts of the URL other than those constituting origin are \
               ignored."]
      }
      [@@deriving yojson]

      let make ?disposeOnDetach ?proxyServer ?proxyBypassList
          ?originsWithUniversalNetworkAccess () =
        {
          disposeOnDetach;
          proxyServer;
          proxyBypassList;
          originsWithUniversalNetworkAccess;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.createBrowserContext"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
one. |desc}]

  module GetBrowserContexts = struct
    module Response : sig
      type result = {
        browserContextIds : Types.Browser.BrowserContextID.t list;
            [@key "browserContextIds"]
            [@ocaml.doc "An array of browser context ids."]
        defaultBrowserContextId : Types.Browser.BrowserContextID.t option;
            [@key "defaultBrowserContextId"]
            [@yojson.option]
            [@ocaml.doc "The id of the default browser context if available."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        browserContextIds : Types.Browser.BrowserContextID.t list;
            [@key "browserContextIds"]
            [@ocaml.doc "An array of browser context ids."]
        defaultBrowserContextId : Types.Browser.BrowserContextID.t option;
            [@key "defaultBrowserContextId"]
            [@yojson.option]
            [@ocaml.doc "The id of the default browser context if available."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Target.getBrowserContexts"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns all browser contexts created with `Target.createBrowserContext` method. |desc}]

  module CreateTarget = struct
    module Response : sig
      type result = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "The id of the page opened."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "The id of the page opened."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        url : string;
            [@key "url"]
            [@ocaml.doc
              "The initial URL the page will be navigated to. An empty string \
               indicates about:blank."]
        left : Types.number option;
            [@key "left"]
            [@yojson.option]
            [@ocaml.doc
              "Frame left origin in DIP (requires newWindow to be true or \
               headless shell)."]
        top : Types.number option;
            [@key "top"]
            [@yojson.option]
            [@ocaml.doc
              "Frame top origin in DIP (requires newWindow to be true or \
               headless shell)."]
        width : Types.number option;
            [@key "width"]
            [@yojson.option]
            [@ocaml.doc
              "Frame width in DIP (requires newWindow to be true or headless \
               shell)."]
        height : Types.number option;
            [@key "height"]
            [@yojson.option]
            [@ocaml.doc
              "Frame height in DIP (requires newWindow to be true or headless \
               shell)."]
        windowState : Types.Target.WindowState.t option;
            [@key "windowState"]
            [@yojson.option]
            [@ocaml.doc
              "Frame window state (requires newWindow to be true or headless \
               shell).\n\
               Default is normal."]
        browserContextId : Types.Browser.BrowserContextID.t option;
            [@key "browserContextId"]
            [@yojson.option]
            [@ocaml.doc "The browser context to create the page in."]
        enableBeginFrameControl : bool option;
            [@key "enableBeginFrameControl"]
            [@yojson.option]
            [@ocaml.doc
              "Whether BeginFrames for this target will be controlled via \
               DevTools (headless shell only,\n\
               not supported on MacOS yet, false by default)."]
        newWindow : bool option;
            [@key "newWindow"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to create a new Window or Tab (false by default, not \
               supported by headless shell)."]
        background : bool option;
            [@key "background"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to create the target in background or foreground (false \
               by default, not supported\n\
               by headless shell)."]
        forTab : bool option;
            [@key "forTab"]
            [@yojson.option]
            [@ocaml.doc "Whether to create the target of type \"tab\"."]
        hidden : bool option;
            [@key "hidden"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to create a hidden target. The hidden target is \
               observable via protocol, but not\n\
               present in the tab UI strip. Cannot be created with `forTab: \
               true`, `newWindow: true` or\n\
               `background: false`. The life-time of the tab is limited to the \
               life-time of the session."]
        focus : bool option;
            [@key "focus"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, the option is used to determine if the new target \
               should\n\
               be focused or not. By default, the focus behavior depends on the\n\
               value of the background field. For example, background=false \
               and focus=false\n\
               will result in the target tab being opened but the browser \
               window remain\n\
               unchanged (if it was in the background, it will remain in the \
               background)\n\
               and background=false with focus=undefined will result in the \
               window being focused.\n\
               Using background: true and focus: true is not supported and \
               will result in an error."]
      }
      [@@deriving yojson]

      let make ~url ?left ?top ?width ?height ?windowState ?browserContextId
          ?enableBeginFrameControl ?newWindow ?background ?forTab ?hidden ?focus
          () =
        {
          url;
          left;
          top;
          width;
          height;
          windowState;
          browserContextId;
          enableBeginFrameControl;
          newWindow;
          background;
          forTab;
          hidden;
          focus;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.createTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Creates a new page. |desc}]

  module DetachFromTarget = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        sessionId : Types.Target.SessionID.t option;
            [@key "sessionId"]
            [@yojson.option]
            [@ocaml.doc "Session to detach."]
        targetId : Types.Target.TargetID.t option;
            [@key "targetId"] [@yojson.option] [@ocaml.doc "Deprecated."]
      }
      [@@deriving yojson]

      let make ?sessionId ?targetId () = { sessionId; targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.detachFromTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Detaches session with given id. |desc}]

  module DisposeBrowserContext = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        browserContextId : Types.Browser.BrowserContextID.t;
            [@key "browserContextId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~browserContextId () = { browserContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.disposeBrowserContext"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Deletes a BrowserContext. All the belonging pages will be closed without calling their
beforeunload hooks. |desc}]

  module GetTargetInfo = struct
    module Response : sig
      type result = {
        targetInfo : Types.Target.TargetInfo.t;
            [@key "targetInfo"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        targetInfo : Types.Target.TargetInfo.t;
            [@key "targetInfo"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t option;
            [@key "targetId"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ?targetId () = { targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.getTargetInfo"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns information about a target. |desc}]

  module GetTargets = struct
    module Response : sig
      type result = {
        targetInfos : Types.Target.TargetInfo.t list;
            [@key "targetInfos"] [@ocaml.doc "The list of targets."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        targetInfos : Types.Target.TargetInfo.t list;
            [@key "targetInfos"] [@ocaml.doc "The list of targets."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        filter : Types.Target.TargetFilter.t option;
            [@key "filter"]
            [@yojson.option]
            [@ocaml.doc
              "Only targets matching filter will be reported. If filter is not \
               specified\n\
               and target discovery is currently enabled, a filter used for \
               target discovery\n\
               is used for consistency."]
      }
      [@@deriving yojson]

      let make ?filter () = { filter }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.getTargets"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Retrieves a list of available targets. |desc}]

  module SendMessageToTarget = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        message : string;
            [@key "message"] [@ocaml.doc "No description provided"]
        sessionId : Types.Target.SessionID.t option;
            [@key "sessionId"]
            [@yojson.option]
            [@ocaml.doc "Identifier of the session."]
        targetId : Types.Target.TargetID.t option;
            [@key "targetId"] [@yojson.option] [@ocaml.doc "Deprecated."]
      }
      [@@deriving yojson]

      let make ~message ?sessionId ?targetId () =
        { message; sessionId; targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.sendMessageToTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sends protocol message over session with given id.
Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
and crbug.com/991325. |desc}]

  module SetAutoAttach = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        autoAttach : bool;
            [@key "autoAttach"]
            [@ocaml.doc "Whether to auto-attach to related targets."]
        waitForDebuggerOnStart : bool;
            [@key "waitForDebuggerOnStart"]
            [@ocaml.doc
              "Whether to pause new targets when attaching to them. Use \
               `Runtime.runIfWaitingForDebugger`\n\
               to run paused targets."]
        flatten : bool option;
            [@key "flatten"]
            [@yojson.option]
            [@ocaml.doc
              "Enables \"flat\" access to the session via specifying sessionId \
               attribute in the commands.\n\
               We plan to make this the default, deprecate non-flattened mode,\n\
               and eventually retire it. See crbug.com/991325."]
        filter : Types.Target.TargetFilter.t option;
            [@key "filter"]
            [@yojson.option]
            [@ocaml.doc "Only targets matching filter will be attached."]
      }
      [@@deriving yojson]

      let make ~autoAttach ~waitForDebuggerOnStart ?flatten ?filter () =
        { autoAttach; waitForDebuggerOnStart; flatten; filter }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.setAutoAttach"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Controls whether to automatically attach to new targets which are considered
to be directly related to this one (for example, iframes or workers).
When turned on, attaches to all existing related targets as well. When turned off,
automatically detaches from all currently attached targets.
This also clears all targets added by `autoAttachRelated` from the list of targets to watch
for creation of related targets.
You might want to call this recursively for auto-attached targets to attach
to all available targets. |desc}]

  module AutoAttachRelated = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "No description provided"]
        waitForDebuggerOnStart : bool;
            [@key "waitForDebuggerOnStart"]
            [@ocaml.doc
              "Whether to pause new targets when attaching to them. Use \
               `Runtime.runIfWaitingForDebugger`\n\
               to run paused targets."]
        filter : Types.Target.TargetFilter.t option;
            [@key "filter"]
            [@yojson.option]
            [@ocaml.doc "Only targets matching filter will be attached."]
      }
      [@@deriving yojson]

      let make ~targetId ~waitForDebuggerOnStart ?filter () =
        { targetId; waitForDebuggerOnStart; filter }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.autoAttachRelated"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Adds the specified target to the list of targets that will be monitored for any related target
creation (such as child frames, child workers and new versions of service worker) and reported
through `attachedToTarget`. The specified target is also auto-attached.
This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent
`setAutoAttach`. Only available at the Browser target. |desc}]

  module SetDiscoverTargets = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        discover : bool;
            [@key "discover"]
            [@ocaml.doc "Whether to discover available targets."]
        filter : Types.Target.TargetFilter.t option;
            [@key "filter"]
            [@yojson.option]
            [@ocaml.doc
              "Only targets matching filter will be attached. If `discover` is \
               false,\n\
               `filter` must be omitted or empty."]
      }
      [@@deriving yojson]

      let make ~discover ?filter () = { discover; filter }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.setDiscoverTargets"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Controls whether to discover available targets and notify via
`targetCreated/targetInfoChanged/targetDestroyed` events. |desc}]

  module SetRemoteLocations = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        locations : Types.Target.RemoteLocation.t list;
            [@key "locations"] [@ocaml.doc "List of remote locations."]
      }
      [@@deriving yojson]

      let make ~locations () = { locations }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.setRemoteLocations"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
`true`. |desc}]

  module GetDevToolsTarget = struct
    module Response : sig
      type result = {
        targetId : Types.Target.TargetID.t option;
            [@key "targetId"]
            [@yojson.option]
            [@ocaml.doc "The targetId of DevTools page target if exists."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        targetId : Types.Target.TargetID.t option;
            [@key "targetId"]
            [@yojson.option]
            [@ocaml.doc "The targetId of DevTools page target if exists."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"] [@ocaml.doc "Page or tab target ID."]
      }
      [@@deriving yojson]

      let make ~targetId () = { targetId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.getDevToolsTarget"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Gets the targetId of the DevTools page target opened for the given target
(if any). |desc}]

  module OpenDevTools = struct
    module Response : sig
      type result = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"]
            [@ocaml.doc "The targetId of DevTools page target."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"]
            [@ocaml.doc "The targetId of DevTools page target."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        targetId : Types.Target.TargetID.t;
            [@key "targetId"]
            [@ocaml.doc "This can be the page or tab target ID."]
        panelId : string option;
            [@key "panelId"]
            [@yojson.option]
            [@ocaml.doc
              "The id of the panel we want DevTools to open initially. Currently\n\
               supported panels are elements, console, network, sources, \
               resources\n\
               and performance."]
      }
      [@@deriving yojson]

      let make ~targetId ?panelId () = { targetId; panelId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Target.openDevTools"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Opens a DevTools window for the target. |desc}]
end

module Tethering = struct
  module Bind = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        port : Types.number; [@key "port"] [@ocaml.doc "Port number to bind."]
      }
      [@@deriving yojson]

      let make ~port () = { port }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Tethering.bind"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Request browser port binding. |desc}]

  module Unbind = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        port : Types.number; [@key "port"] [@ocaml.doc "Port number to unbind."]
      }
      [@@deriving yojson]

      let make ~port () = { port }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Tethering.unbind"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Request browser port unbinding. |desc}]
end

module Tracing = struct
  module End = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Tracing.end"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Stop trace events collection. |desc}]

  module GetCategories = struct
    module Response : sig
      type result = {
        categories : string list;
            [@key "categories"]
            [@ocaml.doc "A list of supported tracing categories."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        categories : string list;
            [@key "categories"]
            [@ocaml.doc "A list of supported tracing categories."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Tracing.getCategories"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Gets supported tracing categories. |desc}]

  module GetTrackEventDescriptor = struct
    module Response : sig
      type result = {
        descriptor : string;
            [@key "descriptor"]
            [@ocaml.doc
              "Base64-encoded serialized perfetto.protos.TrackEventDescriptor \
               protobuf message. (Encoded as a base64 string when passed over \
               JSON)"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        descriptor : string;
            [@key "descriptor"]
            [@ocaml.doc
              "Base64-encoded serialized perfetto.protos.TrackEventDescriptor \
               protobuf message. (Encoded as a base64 string when passed over \
               JSON)"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Tracing.getTrackEventDescriptor"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Return a descriptor for all available tracing categories. |desc}]

  module RecordClockSyncMarker = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        syncId : string;
            [@key "syncId"] [@ocaml.doc "The ID of this clock sync marker"]
      }
      [@@deriving yojson]

      let make ~syncId () = { syncId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Tracing.recordClockSyncMarker"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Record a clock sync marker in the trace. |desc}]

  module RequestMemoryDump = struct
    module Response : sig
      type result = {
        dumpGuid : string;
            [@key "dumpGuid"]
            [@ocaml.doc "GUID of the resulting global memory dump."]
        success : bool;
            [@key "success"]
            [@ocaml.doc "True iff the global memory dump succeeded."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        dumpGuid : string;
            [@key "dumpGuid"]
            [@ocaml.doc "GUID of the resulting global memory dump."]
        success : bool;
            [@key "success"]
            [@ocaml.doc "True iff the global memory dump succeeded."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        deterministic : bool option;
            [@key "deterministic"]
            [@yojson.option]
            [@ocaml.doc
              "Enables more deterministic results by forcing garbage collection"]
        levelOfDetail : Types.Tracing.MemoryDumpLevelOfDetail.t option;
            [@key "levelOfDetail"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies level of details in memory dump. Defaults to \
               \"detailed\"."]
      }
      [@@deriving yojson]

      let make ?deterministic ?levelOfDetail () =
        { deterministic; levelOfDetail }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Tracing.requestMemoryDump"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Request a global memory dump. |desc}]

  module Start = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type start_transfermode = [ `ReportEvents | `ReturnAsStream ]

      let start_transfermode_of_yojson = function
        | `String "ReportEvents" -> `ReportEvents
        | `String "ReturnAsStream" -> `ReturnAsStream
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_start_transfermode = function
        | `ReportEvents -> `String "ReportEvents"
        | `ReturnAsStream -> `String "ReturnAsStream"

      type t = {
        categories : string option;
            [@key "categories"]
            [@yojson.option]
            [@ocaml.doc "Category/tag filter"]
        options : string option;
            [@key "options"] [@yojson.option] [@ocaml.doc "Tracing options"]
        bufferUsageReportingInterval : Types.number option;
            [@key "bufferUsageReportingInterval"]
            [@yojson.option]
            [@ocaml.doc
              "If set, the agent will issue bufferUsage events at this \
               interval, specified in milliseconds"]
        transferMode : start_transfermode option;
            [@key "transferMode"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to report trace events as series of dataCollected \
               events or to save trace to a\n\
               stream (defaults to `ReportEvents`)."]
        streamFormat : Types.Tracing.StreamFormat.t option;
            [@key "streamFormat"]
            [@yojson.option]
            [@ocaml.doc
              "Trace data format to use. This only applies when using \
               `ReturnAsStream`\n\
               transfer mode (defaults to `json`)."]
        streamCompression : Types.Tracing.StreamCompression.t option;
            [@key "streamCompression"]
            [@yojson.option]
            [@ocaml.doc
              "Compression format to use. This only applies when using \
               `ReturnAsStream`\n\
               transfer mode (defaults to `none`)"]
        traceConfig : Types.Tracing.TraceConfig.t option;
            [@key "traceConfig"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        perfettoConfig : string option;
            [@key "perfettoConfig"]
            [@yojson.option]
            [@ocaml.doc
              "Base64-encoded serialized perfetto.protos.TraceConfig protobuf \
               message\n\
               When specified, the parameters `categories`, `options`, \
               `traceConfig`\n\
               are ignored. (Encoded as a base64 string when passed over JSON)"]
        tracingBackend : Types.Tracing.TracingBackend.t option;
            [@key "tracingBackend"]
            [@yojson.option]
            [@ocaml.doc "Backend type (defaults to `auto`)"]
      }
      [@@deriving yojson]

      let make ?categories ?options ?bufferUsageReportingInterval ?transferMode
          ?streamFormat ?streamCompression ?traceConfig ?perfettoConfig
          ?tracingBackend () =
        {
          categories;
          options;
          bufferUsageReportingInterval;
          transferMode;
          streamFormat;
          streamCompression;
          traceConfig;
          perfettoConfig;
          tracingBackend;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Tracing.start"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Start trace events collection. |desc}]
end

module WebAudio = struct
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "WebAudio.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables the WebAudio domain and starts sending context lifetime events. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "WebAudio.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables the WebAudio domain. |desc}]

  module GetRealtimeData = struct
    module Response : sig
      type result = {
        realtimeData : Types.WebAudio.ContextRealtimeData.t;
            [@key "realtimeData"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        realtimeData : Types.WebAudio.ContextRealtimeData.t;
            [@key "realtimeData"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        contextId : Types.WebAudio.GraphObjectId.t;
            [@key "contextId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~contextId () = { contextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAudio.getRealtimeData"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Fetch the realtime data from the registered contexts. |desc}]
end

module WebAuthn = struct
  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enableUI : bool option;
            [@key "enableUI"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to enable the WebAuthn user interface. Enabling the UI is\n\
               recommended for debugging and demo purposes, as it is closer to \
               the real\n\
               experience. Disabling the UI is recommended for automated \
               testing.\n\
               Supported at the embedder's discretion if UI is available.\n\
               Defaults to false."]
      }
      [@@deriving yojson]

      let make ?enableUI () = { enableUI }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enable the WebAuthn domain and start intercepting credential storage and
retrieval with a virtual authenticator. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "WebAuthn.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disable the WebAuthn domain. |desc}]

  module AddVirtualAuthenticator = struct
    module Response : sig
      type result = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        options : Types.WebAuthn.VirtualAuthenticatorOptions.t;
            [@key "options"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~options () = { options }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.addVirtualAuthenticator"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Creates and adds a virtual authenticator. |desc}]

  module SetResponseOverrideBits = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        isBogusSignature : bool option;
            [@key "isBogusSignature"]
            [@yojson.option]
            [@ocaml.doc
              "If isBogusSignature is set, overrides the signature in the \
               authenticator response to be zero.\n\
               Defaults to false."]
        isBadUV : bool option;
            [@key "isBadUV"]
            [@yojson.option]
            [@ocaml.doc
              "If isBadUV is set, overrides the UV bit in the flags in the \
               authenticator response to\n\
               be zero. Defaults to false."]
        isBadUP : bool option;
            [@key "isBadUP"]
            [@yojson.option]
            [@ocaml.doc
              "If isBadUP is set, overrides the UP bit in the flags in the \
               authenticator response to\n\
               be zero. Defaults to false."]
      }
      [@@deriving yojson]

      let make ~authenticatorId ?isBogusSignature ?isBadUV ?isBadUP () =
        { authenticatorId; isBogusSignature; isBadUV; isBadUP }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.setResponseOverrideBits"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present. |desc}]

  module RemoveVirtualAuthenticator = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId () = { authenticatorId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "WebAuthn.removeVirtualAuthenticator";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Removes the given authenticator. |desc}]

  module AddCredential = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        credential : Types.WebAuthn.Credential.t;
            [@key "credential"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId ~credential () = { authenticatorId; credential }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.addCredential"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Adds the credential to the specified authenticator. |desc}]

  module GetCredential = struct
    module Response : sig
      type result = {
        credential : Types.WebAuthn.Credential.t;
            [@key "credential"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        credential : Types.WebAuthn.Credential.t;
            [@key "credential"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        credentialId : string;
            [@key "credentialId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId ~credentialId () =
        { authenticatorId; credentialId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.getCredential"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns a single credential stored in the given virtual authenticator that
matches the credential ID. |desc}]

  module GetCredentials = struct
    module Response : sig
      type result = {
        credentials : Types.WebAuthn.Credential.t list;
            [@key "credentials"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        credentials : Types.WebAuthn.Credential.t list;
            [@key "credentials"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId () = { authenticatorId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.getCredentials"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns all the credentials stored in the given virtual authenticator. |desc}]

  module RemoveCredential = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        credentialId : string;
            [@key "credentialId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId ~credentialId () =
        { authenticatorId; credentialId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.removeCredential"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Removes a credential from the authenticator. |desc}]

  module ClearCredentials = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId () = { authenticatorId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.clearCredentials"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Clears all the credentials from the specified device. |desc}]

  module SetUserVerified = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        isUserVerified : bool;
            [@key "isUserVerified"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId ~isUserVerified () =
        { authenticatorId; isUserVerified }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.setUserVerified"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets whether User Verification succeeds or fails for an authenticator.
The default is true. |desc}]

  module SetAutomaticPresenceSimulation = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        enabled : bool; [@key "enabled"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId ~enabled () = { authenticatorId; enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "WebAuthn.setAutomaticPresenceSimulation";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.
The default is true. |desc}]

  module SetCredentialProperties = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        authenticatorId : Types.WebAuthn.AuthenticatorId.t;
            [@key "authenticatorId"] [@ocaml.doc "No description provided"]
        credentialId : string;
            [@key "credentialId"] [@ocaml.doc "No description provided"]
        backupEligibility : bool option;
            [@key "backupEligibility"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
        backupState : bool option;
            [@key "backupState"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~authenticatorId ~credentialId ?backupEligibility ?backupState ()
          =
        { authenticatorId; credentialId; backupEligibility; backupState }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "WebAuthn.setCredentialProperties"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Allows setting credential properties.
https://w3c.github.io/webauthn/#sctn-automation-set-credential-properties |desc}]
end

module Console = struct
  module ClearMessages = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Console.clearMessages"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Does nothing. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Console.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Disables console domain, prevents further console messages from being reported to the client. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Console.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables console domain, sends the messages collected so far to the client by means of the
`messageAdded` notification. |desc}]
end

module Debugger = struct
  module ContinueToLocation = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type continuetolocation_targetcallframes = [ `any | `current ]

      let continuetolocation_targetcallframes_of_yojson = function
        | `String "any" -> `any
        | `String "current" -> `current
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_continuetolocation_targetcallframes = function
        | `any -> `String "any"
        | `current -> `String "current"

      type t = {
        location : Types.Debugger.Location.t;
            [@key "location"] [@ocaml.doc "Location to continue to."]
        targetCallFrames : continuetolocation_targetcallframes option;
            [@key "targetCallFrames"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~location ?targetCallFrames () = { location; targetCallFrames }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.continueToLocation"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Continues execution until specific location is reached. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Debugger.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables debugger for given page. |desc}]

  module Enable = struct
    module Response : sig
      type result = {
        debuggerId : Types.Runtime.UniqueDebuggerId.t;
            [@key "debuggerId"]
            [@ocaml.doc "Unique identifier of the debugger."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        debuggerId : Types.Runtime.UniqueDebuggerId.t;
            [@key "debuggerId"]
            [@ocaml.doc "Unique identifier of the debugger."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        maxScriptsCacheSize : Types.number option;
            [@key "maxScriptsCacheSize"]
            [@yojson.option]
            [@ocaml.doc
              "The maximum size in bytes of collected scripts (not referenced \
               by other heap objects)\n\
               the debugger can hold. Puts no limit if parameter is omitted."]
      }
      [@@deriving yojson]

      let make ?maxScriptsCacheSize () = { maxScriptsCacheSize }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.enable"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables debugger for the given page. Clients should not assume that the debugging has been
enabled until the result for this command is received. |desc}]

  module EvaluateOnCallFrame = struct
    module Response : sig
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"]
            [@ocaml.doc "Object wrapper for the evaluation result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"]
            [@ocaml.doc "Object wrapper for the evaluation result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        callFrameId : Types.Debugger.CallFrameId.t;
            [@key "callFrameId"]
            [@ocaml.doc "Call frame identifier to evaluate on."]
        expression : string;
            [@key "expression"] [@ocaml.doc "Expression to evaluate."]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "String object group name to put result into (allows rapid \
               releasing resulting object handles\n\
               using `releaseObjectGroup`)."]
        includeCommandLineAPI : bool option;
            [@key "includeCommandLineAPI"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies whether command line API should be available to the \
               evaluated expression, defaults\n\
               to false."]
        silent : bool option;
            [@key "silent"]
            [@yojson.option]
            [@ocaml.doc
              "In silent mode exceptions thrown during evaluation are not \
               reported and do not pause\n\
               execution. Overrides `setPauseOnException` state."]
        returnByValue : bool option;
            [@key "returnByValue"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the result is expected to be a JSON object that should \
               be sent by value."]
        generatePreview : bool option;
            [@key "generatePreview"]
            [@yojson.option]
            [@ocaml.doc "Whether preview should be generated for the result."]
        throwOnSideEffect : bool option;
            [@key "throwOnSideEffect"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to throw an exception if side effect cannot be ruled \
               out during evaluation."]
        timeout : Types.Runtime.TimeDelta.t option;
            [@key "timeout"]
            [@yojson.option]
            [@ocaml.doc
              "Terminate execution after timing out (number of milliseconds)."]
      }
      [@@deriving yojson]

      let make ~callFrameId ~expression ?objectGroup ?includeCommandLineAPI
          ?silent ?returnByValue ?generatePreview ?throwOnSideEffect ?timeout ()
          =
        {
          callFrameId;
          expression;
          objectGroup;
          includeCommandLineAPI;
          silent;
          returnByValue;
          generatePreview;
          throwOnSideEffect;
          timeout;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.evaluateOnCallFrame"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Evaluates expression on a given call frame. |desc}]

  module GetPossibleBreakpoints = struct
    module Response : sig
      type result = {
        locations : Types.Debugger.BreakLocation.t list;
            [@key "locations"]
            [@ocaml.doc "List of the possible breakpoint locations."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        locations : Types.Debugger.BreakLocation.t list;
            [@key "locations"]
            [@ocaml.doc "List of the possible breakpoint locations."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        start : Types.Debugger.Location.t;
            [@key "start"]
            [@ocaml.doc
              "Start of range to search possible breakpoint locations in."]
        end_ : Types.Debugger.Location.t option;
            [@key "end"]
            [@yojson.option]
            [@ocaml.doc
              "End of range to search possible breakpoint locations in \
               (excluding). When not specified, end\n\
               of scripts is used as end of range."]
        restrictToFunction : bool option;
            [@key "restrictToFunction"]
            [@yojson.option]
            [@ocaml.doc
              "Only consider locations which are in the same (non-nested) \
               function as start."]
      }
      [@@deriving yojson]

      let make ~start ?end_ ?restrictToFunction () =
        { start; end_; restrictToFunction }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.getPossibleBreakpoints"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns possible locations for breakpoint. scriptId in start and end range locations should be
the same. |desc}]

  module GetScriptSource = struct
    module Response : sig
      type result = {
        scriptSource : string;
            [@key "scriptSource"]
            [@ocaml.doc "Script source (empty in case of Wasm bytecode)."]
        bytecode : string option;
            [@key "bytecode"]
            [@yojson.option]
            [@ocaml.doc
              "Wasm bytecode. (Encoded as a base64 string when passed over \
               JSON)"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        scriptSource : string;
            [@key "scriptSource"]
            [@ocaml.doc "Script source (empty in case of Wasm bytecode)."]
        bytecode : string option;
            [@key "bytecode"]
            [@yojson.option]
            [@ocaml.doc
              "Wasm bytecode. (Encoded as a base64 string when passed over \
               JSON)"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"] [@ocaml.doc "Id of the script to get source for."]
      }
      [@@deriving yojson]

      let make ~scriptId () = { scriptId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.getScriptSource"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns source for the script with given id. |desc}]

  module DisassembleWasmModule = struct
    module Response : sig
      type result = {
        streamId : string option;
            [@key "streamId"]
            [@yojson.option]
            [@ocaml.doc
              "For large modules, return a stream from which additional chunks \
               of\n\
               disassembly can be read successively."]
        totalNumberOfLines : Types.number;
            [@key "totalNumberOfLines"]
            [@ocaml.doc "The total number of lines in the disassembly text."]
        functionBodyOffsets : Types.number list;
            [@key "functionBodyOffsets"]
            [@ocaml.doc
              "The offsets of all function bodies, in the format [start1, end1,\n\
               start2, end2, ...] where all ends are exclusive."]
        chunk : Types.Debugger.WasmDisassemblyChunk.t;
            [@key "chunk"] [@ocaml.doc "The first chunk of disassembly."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        streamId : string option;
            [@key "streamId"]
            [@yojson.option]
            [@ocaml.doc
              "For large modules, return a stream from which additional chunks \
               of\n\
               disassembly can be read successively."]
        totalNumberOfLines : Types.number;
            [@key "totalNumberOfLines"]
            [@ocaml.doc "The total number of lines in the disassembly text."]
        functionBodyOffsets : Types.number list;
            [@key "functionBodyOffsets"]
            [@ocaml.doc
              "The offsets of all function bodies, in the format [start1, end1,\n\
               start2, end2, ...] where all ends are exclusive."]
        chunk : Types.Debugger.WasmDisassemblyChunk.t;
            [@key "chunk"] [@ocaml.doc "The first chunk of disassembly."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"] [@ocaml.doc "Id of the script to disassemble"]
      }
      [@@deriving yojson]

      let make ~scriptId () = { scriptId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.disassembleWasmModule"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module NextWasmDisassemblyChunk = struct
    module Response : sig
      type result = {
        chunk : Types.Debugger.WasmDisassemblyChunk.t;
            [@key "chunk"] [@ocaml.doc "The next chunk of disassembly."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        chunk : Types.Debugger.WasmDisassemblyChunk.t;
            [@key "chunk"] [@ocaml.doc "The next chunk of disassembly."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        streamId : string;
            [@key "streamId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~streamId () = { streamId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.nextWasmDisassemblyChunk"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Disassemble the next chunk of lines for the module corresponding to the
stream. If disassembly is complete, this API will invalidate the streamId
and return an empty chunk. Any subsequent calls for the now invalid stream
will return errors. |desc}]

  module GetWasmBytecode = struct
    module Response : sig
      type result = {
        bytecode : string;
            [@key "bytecode"]
            [@ocaml.doc
              "Script source. (Encoded as a base64 string when passed over \
               JSON)"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        bytecode : string;
            [@key "bytecode"]
            [@ocaml.doc
              "Script source. (Encoded as a base64 string when passed over \
               JSON)"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"]
            [@ocaml.doc "Id of the Wasm script to get source for."]
      }
      [@@deriving yojson]

      let make ~scriptId () = { scriptId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.getWasmBytecode"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|This command is deprecated. Use getScriptSource instead. |desc}]

  module GetStackTrace = struct
    module Response : sig
      type result = {
        stackTrace : Types.Runtime.StackTrace.t;
            [@key "stackTrace"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        stackTrace : Types.Runtime.StackTrace.t;
            [@key "stackTrace"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        stackTraceId : Types.Runtime.StackTraceId.t;
            [@key "stackTraceId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~stackTraceId () = { stackTraceId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.getStackTrace"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns stack trace with given `stackTraceId`. |desc}]

  module Pause = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Debugger.pause"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Stops on the next JavaScript statement. |desc}]

  module PauseOnAsyncCall = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        parentStackTraceId : Types.Runtime.StackTraceId.t;
            [@key "parentStackTraceId"]
            [@ocaml.doc
              "Debugger will pause when async call with given stack trace is \
               started."]
      }
      [@@deriving yojson]

      let make ~parentStackTraceId () = { parentStackTraceId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.pauseOnAsyncCall"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module RemoveBreakpoint = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~breakpointId () = { breakpointId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.removeBreakpoint"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Removes JavaScript breakpoint. |desc}]

  module RestartFrame = struct
    module Response : sig
      type result = {
        callFrames : Types.Debugger.CallFrame.t list;
            [@key "callFrames"] [@ocaml.doc "New stack trace."]
        asyncStackTrace : Types.Runtime.StackTrace.t option;
            [@key "asyncStackTrace"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
        asyncStackTraceId : Types.Runtime.StackTraceId.t option;
            [@key "asyncStackTraceId"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        callFrames : Types.Debugger.CallFrame.t list;
            [@key "callFrames"] [@ocaml.doc "New stack trace."]
        asyncStackTrace : Types.Runtime.StackTrace.t option;
            [@key "asyncStackTrace"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
        asyncStackTraceId : Types.Runtime.StackTraceId.t option;
            [@key "asyncStackTraceId"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type restartframe_mode = [ `StepInto ]

      let restartframe_mode_of_yojson = function
        | `String "StepInto" -> `StepInto
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_restartframe_mode = function
        | `StepInto -> `String "StepInto"

      type t = {
        callFrameId : Types.Debugger.CallFrameId.t;
            [@key "callFrameId"]
            [@ocaml.doc "Call frame identifier to evaluate on."]
        mode : restartframe_mode option;
            [@key "mode"]
            [@yojson.option]
            [@ocaml.doc
              "The `mode` parameter must be present and set to 'StepInto', \
               otherwise\n\
               `restartFrame` will error out."]
      }
      [@@deriving yojson]

      let make ~callFrameId ?mode () = { callFrameId; mode }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.restartFrame"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Restarts particular call frame from the beginning. The old, deprecated
behavior of `restartFrame` is to stay paused and allow further CDP commands
after a restart was scheduled. This can cause problems with restarting, so
we now continue execution immediatly after it has been scheduled until we
reach the beginning of the restarted frame.

To stay back-wards compatible, `restartFrame` now expects a `mode`
parameter to be present. If the `mode` parameter is missing, `restartFrame`
errors out.

The various return values are deprecated and `callFrames` is always empty.
Use the call frames from the `Debugger#paused` events instead, that fires
once V8 pauses at the beginning of the restarted function. |desc}]

  module Resume = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        terminateOnResume : bool option;
            [@key "terminateOnResume"]
            [@yojson.option]
            [@ocaml.doc
              "Set to true to terminate execution upon resuming execution. In \
               contrast\n\
               to Runtime.terminateExecution, this will allows to execute \
               further\n\
               JavaScript (i.e. via evaluation) until execution of the paused \
               code\n\
               is actually resumed, at which point termination is triggered.\n\
               If execution is currently not paused, this parameter has no \
               effect."]
      }
      [@@deriving yojson]

      let make ?terminateOnResume () = { terminateOnResume }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.resume"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Resumes JavaScript execution. |desc}]

  module SearchInContent = struct
    module Response : sig
      type result = {
        result : Types.Debugger.SearchMatch.t list;
            [@key "result"] [@ocaml.doc "List of search matches."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Debugger.SearchMatch.t list;
            [@key "result"] [@ocaml.doc "List of search matches."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"] [@ocaml.doc "Id of the script to search in."]
        query : string; [@key "query"] [@ocaml.doc "String to search for."]
        caseSensitive : bool option;
            [@key "caseSensitive"]
            [@yojson.option]
            [@ocaml.doc "If true, search is case sensitive."]
        isRegex : bool option;
            [@key "isRegex"]
            [@yojson.option]
            [@ocaml.doc "If true, treats string parameter as regex."]
      }
      [@@deriving yojson]

      let make ~scriptId ~query ?caseSensitive ?isRegex () =
        { scriptId; query; caseSensitive; isRegex }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.searchInContent"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Searches for given string in script content. |desc}]

  module SetAsyncCallStackDepth = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        maxDepth : Types.number;
            [@key "maxDepth"]
            [@ocaml.doc
              "Maximum depth of async call stacks. Setting to `0` will \
               effectively disable collecting async\n\
               call stacks (default)."]
      }
      [@@deriving yojson]

      let make ~maxDepth () = { maxDepth }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setAsyncCallStackDepth"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables or disables async call stacks tracking. |desc}]

  module SetBlackboxExecutionContexts = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        uniqueIds : string list;
            [@key "uniqueIds"]
            [@ocaml.doc
              "Array of execution context unique ids for the debugger to \
               ignore."]
      }
      [@@deriving yojson]

      let make ~uniqueIds () = { uniqueIds }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Debugger.setBlackboxExecutionContexts";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Replace previous blackbox execution contexts with passed ones. Forces backend to skip
stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
performing 'step in' several times, finally resorting to 'step out' if unsuccessful. |desc}]

  module SetBlackboxPatterns = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        patterns : string list;
            [@key "patterns"]
            [@ocaml.doc
              "Array of regexps that will be used to check script url for \
               blackbox state."]
        skipAnonymous : bool option;
            [@key "skipAnonymous"]
            [@yojson.option]
            [@ocaml.doc "If true, also ignore scripts with no source url."]
      }
      [@@deriving yojson]

      let make ~patterns ?skipAnonymous () = { patterns; skipAnonymous }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setBlackboxPatterns"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
scripts with url matching one of the patterns. VM will try to leave blackboxed script by
performing 'step in' several times, finally resorting to 'step out' if unsuccessful. |desc}]

  module SetBlackboxedRanges = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"] [@ocaml.doc "Id of the script."]
        positions : Types.Debugger.ScriptPosition.t list;
            [@key "positions"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~scriptId ~positions () = { scriptId; positions }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setBlackboxedRanges"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
Positions array contains positions where blackbox state is changed. First interval isn't
blackboxed. Array should be sorted. |desc}]

  module SetBreakpoint = struct
    module Response : sig
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
        actualLocation : Types.Debugger.Location.t;
            [@key "actualLocation"]
            [@ocaml.doc "Location this breakpoint resolved into."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
        actualLocation : Types.Debugger.Location.t;
            [@key "actualLocation"]
            [@ocaml.doc "Location this breakpoint resolved into."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        location : Types.Debugger.Location.t;
            [@key "location"] [@ocaml.doc "Location to set breakpoint in."]
        condition : string option;
            [@key "condition"]
            [@yojson.option]
            [@ocaml.doc
              "Expression to use as a breakpoint condition. When specified, \
               debugger will only stop on the\n\
               breakpoint if this expression evaluates to true."]
      }
      [@@deriving yojson]

      let make ~location ?condition () = { location; condition }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setBreakpoint"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets JavaScript breakpoint at a given location. |desc}]

  module SetInstrumentationBreakpoint = struct
    module Response : sig
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setinstrumentationbreakpoint_instrumentation =
        [ `beforeScriptExecution | `beforeScriptWithSourceMapExecution ]

      let setinstrumentationbreakpoint_instrumentation_of_yojson = function
        | `String "beforeScriptExecution" -> `beforeScriptExecution
        | `String "beforeScriptWithSourceMapExecution" ->
            `beforeScriptWithSourceMapExecution
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setinstrumentationbreakpoint_instrumentation = function
        | `beforeScriptExecution -> `String "beforeScriptExecution"
        | `beforeScriptWithSourceMapExecution ->
            `String "beforeScriptWithSourceMapExecution"

      type t = {
        instrumentation : setinstrumentationbreakpoint_instrumentation;
            [@key "instrumentation"] [@ocaml.doc "Instrumentation name."]
      }
      [@@deriving yojson]

      let make ~instrumentation () = { instrumentation }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Debugger.setInstrumentationBreakpoint";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Sets instrumentation breakpoint. |desc}]

  module SetBreakpointByUrl = struct
    module Response : sig
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
        locations : Types.Debugger.Location.t list;
            [@key "locations"]
            [@ocaml.doc
              "List of the locations this breakpoint resolved into upon \
               addition."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
        locations : Types.Debugger.Location.t list;
            [@key "locations"]
            [@ocaml.doc
              "List of the locations this breakpoint resolved into upon \
               addition."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        lineNumber : Types.number;
            [@key "lineNumber"] [@ocaml.doc "Line number to set breakpoint at."]
        url : string option;
            [@key "url"]
            [@yojson.option]
            [@ocaml.doc "URL of the resources to set breakpoint on."]
        urlRegex : string option;
            [@key "urlRegex"]
            [@yojson.option]
            [@ocaml.doc
              "Regex pattern for the URLs of the resources to set breakpoints \
               on. Either `url` or\n\
               `urlRegex` must be specified."]
        scriptHash : string option;
            [@key "scriptHash"]
            [@yojson.option]
            [@ocaml.doc "Script hash of the resources to set breakpoint on."]
        columnNumber : Types.number option;
            [@key "columnNumber"]
            [@yojson.option]
            [@ocaml.doc "Offset in the line to set breakpoint at."]
        condition : string option;
            [@key "condition"]
            [@yojson.option]
            [@ocaml.doc
              "Expression to use as a breakpoint condition. When specified, \
               debugger will only stop on the\n\
               breakpoint if this expression evaluates to true."]
      }
      [@@deriving yojson]

      let make ~lineNumber ?url ?urlRegex ?scriptHash ?columnNumber ?condition
          () =
        { lineNumber; url; urlRegex; scriptHash; columnNumber; condition }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setBreakpointByUrl"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
command is issued, all existing parsed scripts will have breakpoints resolved and returned in
`locations` property. Further matching script parsing will result in subsequent
`breakpointResolved` events issued. This logical breakpoint will survive page reloads. |desc}]

  module SetBreakpointOnFunctionCall = struct
    module Response : sig
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        breakpointId : Types.Debugger.BreakpointId.t;
            [@key "breakpointId"]
            [@ocaml.doc "Id of the created breakpoint for further reference."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"] [@ocaml.doc "Function object id."]
        condition : string option;
            [@key "condition"]
            [@yojson.option]
            [@ocaml.doc
              "Expression to use as a breakpoint condition. When specified, \
               debugger will\n\
               stop on the breakpoint if this expression evaluates to true."]
      }
      [@@deriving yojson]

      let make ~objectId ?condition () = { objectId; condition }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Debugger.setBreakpointOnFunctionCall";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Sets JavaScript breakpoint before each call to the given function.
If another function was created from the same source as a given one,
calling it will also trigger the breakpoint. |desc}]

  module SetBreakpointsActive = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        active : bool;
            [@key "active"]
            [@ocaml.doc "New value for breakpoints active state."]
      }
      [@@deriving yojson]

      let make ~active () = { active }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setBreakpointsActive"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Activates / deactivates all breakpoints on the page. |desc}]

  module SetPauseOnExceptions = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type setpauseonexceptions_state = [ `none | `caught | `uncaught | `all ]

      let setpauseonexceptions_state_of_yojson = function
        | `String "none" -> `none
        | `String "caught" -> `caught
        | `String "uncaught" -> `uncaught
        | `String "all" -> `all
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setpauseonexceptions_state = function
        | `none -> `String "none"
        | `caught -> `String "caught"
        | `uncaught -> `String "uncaught"
        | `all -> `String "all"

      type t = {
        state : setpauseonexceptions_state;
            [@key "state"] [@ocaml.doc "Pause on exceptions mode."]
      }
      [@@deriving yojson]

      let make ~state () = { state }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setPauseOnExceptions"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
or caught exceptions, no exceptions. Initial pause on exceptions state is `none`. |desc}]

  module SetReturnValue = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        newValue : Types.Runtime.CallArgument.t;
            [@key "newValue"] [@ocaml.doc "New return value."]
      }
      [@@deriving yojson]

      let make ~newValue () = { newValue }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setReturnValue"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Changes return value in top frame. Available only at return break position. |desc}]

  module SetScriptSource = struct
    module Response : sig
      type setscriptsource_status =
        [ `Ok
        | `CompileError
        | `BlockedByActiveGenerator
        | `BlockedByActiveFunction
        | `BlockedByTopLevelEsModuleChange ]

      val setscriptsource_status_of_yojson :
        Yojson.Basic.t -> setscriptsource_status

      val yojson_of_setscriptsource_status :
        setscriptsource_status -> Yojson.Basic.t

      type result = {
        callFrames : Types.Debugger.CallFrame.t list option;
            [@key "callFrames"]
            [@yojson.option]
            [@ocaml.doc
              "New stack trace in case editing has happened while VM was \
               stopped."]
        stackChanged : bool option;
            [@key "stackChanged"]
            [@yojson.option]
            [@ocaml.doc
              "Whether current call stack  was modified after applying the \
               changes."]
        asyncStackTrace : Types.Runtime.StackTrace.t option;
            [@key "asyncStackTrace"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
        asyncStackTraceId : Types.Runtime.StackTraceId.t option;
            [@key "asyncStackTraceId"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
        status : setscriptsource_status;
            [@key "status"]
            [@ocaml.doc
              "Whether the operation was successful or not. Only `Ok` denotes a\n\
               successful live edit while the other enum variants denote why\n\
               the live edit failed."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc
              "Exception details if any. Only present when `status` is \
               `CompileError`."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type setscriptsource_status =
        [ `Ok
        | `CompileError
        | `BlockedByActiveGenerator
        | `BlockedByActiveFunction
        | `BlockedByTopLevelEsModuleChange ]

      let setscriptsource_status_of_yojson = function
        | `String "Ok" -> `Ok
        | `String "CompileError" -> `CompileError
        | `String "BlockedByActiveGenerator" -> `BlockedByActiveGenerator
        | `String "BlockedByActiveFunction" -> `BlockedByActiveFunction
        | `String "BlockedByTopLevelEsModuleChange" ->
            `BlockedByTopLevelEsModuleChange
        | `String s -> failwith ("unknown enum: " ^ s)
        | _ -> failwith "unknown enum type"

      let yojson_of_setscriptsource_status = function
        | `Ok -> `String "Ok"
        | `CompileError -> `String "CompileError"
        | `BlockedByActiveGenerator -> `String "BlockedByActiveGenerator"
        | `BlockedByActiveFunction -> `String "BlockedByActiveFunction"
        | `BlockedByTopLevelEsModuleChange ->
            `String "BlockedByTopLevelEsModuleChange"

      type result = {
        callFrames : Types.Debugger.CallFrame.t list option;
            [@key "callFrames"]
            [@yojson.option]
            [@ocaml.doc
              "New stack trace in case editing has happened while VM was \
               stopped."]
        stackChanged : bool option;
            [@key "stackChanged"]
            [@yojson.option]
            [@ocaml.doc
              "Whether current call stack  was modified after applying the \
               changes."]
        asyncStackTrace : Types.Runtime.StackTrace.t option;
            [@key "asyncStackTrace"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
        asyncStackTraceId : Types.Runtime.StackTraceId.t option;
            [@key "asyncStackTraceId"]
            [@yojson.option]
            [@ocaml.doc "Async stack trace, if any."]
        status : setscriptsource_status;
            [@key "status"]
            [@ocaml.doc
              "Whether the operation was successful or not. Only `Ok` denotes a\n\
               successful live edit while the other enum variants denote why\n\
               the live edit failed."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc
              "Exception details if any. Only present when `status` is \
               `CompileError`."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"] [@ocaml.doc "Id of the script to edit."]
        scriptSource : string;
            [@key "scriptSource"] [@ocaml.doc "New content of the script."]
        dryRun : bool option;
            [@key "dryRun"]
            [@yojson.option]
            [@ocaml.doc
              "If true the change will not actually be applied. Dry run may be \
               used to get result\n\
               description without actually modifying the code."]
        allowTopFrameEditing : bool option;
            [@key "allowTopFrameEditing"]
            [@yojson.option]
            [@ocaml.doc
              "If true, then `scriptSource` is allowed to change the function \
               on top of the stack\n\
               as long as the top-most stack frame is the only activation of \
               that function."]
      }
      [@@deriving yojson]

      let make ~scriptId ~scriptSource ?dryRun ?allowTopFrameEditing () =
        { scriptId; scriptSource; dryRun; allowTopFrameEditing }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setScriptSource"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Edits JavaScript source live.

In general, functions that are currently on the stack can not be edited with
a single exception: If the edited function is the top-most stack frame and
that is the only activation of that function on the stack. In this case
the live edit will be successful and a `Debugger.restartFrame` for the
top-most function is automatically triggered. |desc}]

  module SetSkipAllPauses = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        skip : bool;
            [@key "skip"] [@ocaml.doc "New value for skip pauses state."]
      }
      [@@deriving yojson]

      let make ~skip () = { skip }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setSkipAllPauses"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc). |desc}]

  module SetVariableValue = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scopeNumber : Types.number;
            [@key "scopeNumber"]
            [@ocaml.doc
              "0-based number of scope as was listed in scope chain. Only \
               'local', 'closure' and 'catch'\n\
               scope types are allowed. Other scopes could be manipulated \
               manually."]
        variableName : string;
            [@key "variableName"] [@ocaml.doc "Variable name."]
        newValue : Types.Runtime.CallArgument.t;
            [@key "newValue"] [@ocaml.doc "New variable value."]
        callFrameId : Types.Debugger.CallFrameId.t;
            [@key "callFrameId"]
            [@ocaml.doc "Id of callframe that holds variable."]
      }
      [@@deriving yojson]

      let make ~scopeNumber ~variableName ~newValue ~callFrameId () =
        { scopeNumber; variableName; newValue; callFrameId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.setVariableValue"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Changes value of variable in a callframe. Object-based scopes are not supported and must be
mutated manually. |desc}]

  module StepInto = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        breakOnAsyncCall : bool option;
            [@key "breakOnAsyncCall"]
            [@yojson.option]
            [@ocaml.doc
              "Debugger will pause on the execution of the first async task \
               which was scheduled\n\
               before next pause."]
        skipList : Types.Debugger.LocationRange.t list option;
            [@key "skipList"]
            [@yojson.option]
            [@ocaml.doc
              "The skipList specifies location ranges that should be skipped \
               on step into."]
      }
      [@@deriving yojson]

      let make ?breakOnAsyncCall ?skipList () = { breakOnAsyncCall; skipList }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.stepInto"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Steps into the function call. |desc}]

  module StepOut = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Debugger.stepOut"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Steps out of the function call. |desc}]

  module StepOver = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        skipList : Types.Debugger.LocationRange.t list option;
            [@key "skipList"]
            [@yojson.option]
            [@ocaml.doc
              "The skipList specifies location ranges that should be skipped \
               on step over."]
      }
      [@@deriving yojson]

      let make ?skipList () = { skipList }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Debugger.stepOver"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Steps over the statement. |desc}]
end

module HeapProfiler = struct
  module AddInspectedHeapObject = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        heapObjectId : Types.HeapProfiler.HeapSnapshotObjectId.t;
            [@key "heapObjectId"]
            [@ocaml.doc
              "Heap snapshot object id to be accessible by means of $x command \
               line API."]
      }
      [@@deriving yojson]

      let make ~heapObjectId () = { heapObjectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "HeapProfiler.addInspectedHeapObject";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables console to refer to the node with given id via $x (see Command Line API for more details
$x functions). |desc}]

  module CollectGarbage = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeapProfiler.collectGarbage"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeapProfiler.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeapProfiler.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module GetHeapObjectId = struct
    module Response : sig
      type result = {
        heapSnapshotObjectId : Types.HeapProfiler.HeapSnapshotObjectId.t;
            [@key "heapSnapshotObjectId"]
            [@ocaml.doc
              "Id of the heap snapshot object corresponding to the passed \
               remote object id."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        heapSnapshotObjectId : Types.HeapProfiler.HeapSnapshotObjectId.t;
            [@key "heapSnapshotObjectId"]
            [@ocaml.doc
              "Id of the heap snapshot object corresponding to the passed \
               remote object id."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"]
            [@ocaml.doc "Identifier of the object to get heap object id for."]
      }
      [@@deriving yojson]

      let make ~objectId () = { objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "HeapProfiler.getHeapObjectId"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module GetObjectByHeapObjectId = struct
    module Response : sig
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Evaluation result."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Evaluation result."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.HeapProfiler.HeapSnapshotObjectId.t;
            [@key "objectId"] [@ocaml.doc "No description provided"]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "Symbolic group name that can be used to release multiple \
               objects."]
      }
      [@@deriving yojson]

      let make ~objectId ?objectGroup () = { objectId; objectGroup }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "HeapProfiler.getObjectByHeapObjectId";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module GetSamplingProfile = struct
    module Response : sig
      type result = {
        profile : Types.HeapProfiler.SamplingHeapProfile.t;
            [@key "profile"]
            [@ocaml.doc "Return the sampling profile being collected."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        profile : Types.HeapProfiler.SamplingHeapProfile.t;
            [@key "profile"]
            [@ocaml.doc "Return the sampling profile being collected."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeapProfiler.getSamplingProfile"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module StartSampling = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        samplingInterval : Types.number option;
            [@key "samplingInterval"]
            [@yojson.option]
            [@ocaml.doc
              "Average sample interval in bytes. Poisson distribution is used \
               for the intervals. The\n\
               default value is 32768 bytes."]
        stackDepth : Types.number option;
            [@key "stackDepth"]
            [@yojson.option]
            [@ocaml.doc "Maximum stack depth. The default value is 128."]
        includeObjectsCollectedByMajorGC : bool option;
            [@key "includeObjectsCollectedByMajorGC"]
            [@yojson.option]
            [@ocaml.doc
              "By default, the sampling heap profiler reports only objects \
               which are\n\
               still alive when the profile is returned via getSamplingProfile \
               or\n\
               stopSampling, which is useful for determining what functions \
               contribute\n\
               the most to steady-state memory usage. This flag instructs the \
               sampling\n\
               heap profiler to also include information about objects \
               discarded by\n\
               major GC, which will show which functions cause large temporary \
               memory\n\
               usage or long GC pauses."]
        includeObjectsCollectedByMinorGC : bool option;
            [@key "includeObjectsCollectedByMinorGC"]
            [@yojson.option]
            [@ocaml.doc
              "By default, the sampling heap profiler reports only objects \
               which are\n\
               still alive when the profile is returned via getSamplingProfile \
               or\n\
               stopSampling, which is useful for determining what functions \
               contribute\n\
               the most to steady-state memory usage. This flag instructs the \
               sampling\n\
               heap profiler to also include information about objects \
               discarded by\n\
               minor GC, which is useful when tuning a latency-sensitive \
               application\n\
               for minimal GC activity."]
      }
      [@@deriving yojson]

      let make ?samplingInterval ?stackDepth ?includeObjectsCollectedByMajorGC
          ?includeObjectsCollectedByMinorGC () =
        {
          samplingInterval;
          stackDepth;
          includeObjectsCollectedByMajorGC;
          includeObjectsCollectedByMinorGC;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "HeapProfiler.startSampling"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module StartTrackingHeapObjects = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        trackAllocations : bool option;
            [@key "trackAllocations"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ?trackAllocations () = { trackAllocations }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "HeapProfiler.startTrackingHeapObjects";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module StopSampling = struct
    module Response : sig
      type result = {
        profile : Types.HeapProfiler.SamplingHeapProfile.t;
            [@key "profile"] [@ocaml.doc "Recorded sampling heap profile."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        profile : Types.HeapProfiler.SamplingHeapProfile.t;
            [@key "profile"] [@ocaml.doc "Recorded sampling heap profile."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "HeapProfiler.stopSampling"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module StopTrackingHeapObjects = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        reportProgress : bool option;
            [@key "reportProgress"]
            [@yojson.option]
            [@ocaml.doc
              "If true 'reportHeapSnapshotProgress' events will be generated \
               while snapshot is being taken\n\
               when the tracking is stopped."]
        treatGlobalObjectsAsRoots : bool option;
            [@key "treatGlobalObjectsAsRoots"]
            [@yojson.option]
            [@ocaml.doc "Deprecated in favor of `exposeInternals`."]
        captureNumericValue : bool option;
            [@key "captureNumericValue"]
            [@yojson.option]
            [@ocaml.doc
              "If true, numerical values are included in the snapshot"]
        exposeInternals : bool option;
            [@key "exposeInternals"]
            [@yojson.option]
            [@ocaml.doc "If true, exposes internals of the snapshot."]
      }
      [@@deriving yojson]

      let make ?reportProgress ?treatGlobalObjectsAsRoots ?captureNumericValue
          ?exposeInternals () =
        {
          reportProgress;
          treatGlobalObjectsAsRoots;
          captureNumericValue;
          exposeInternals;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "HeapProfiler.stopTrackingHeapObjects";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module TakeHeapSnapshot = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        reportProgress : bool option;
            [@key "reportProgress"]
            [@yojson.option]
            [@ocaml.doc
              "If true 'reportHeapSnapshotProgress' events will be generated \
               while snapshot is being taken."]
        treatGlobalObjectsAsRoots : bool option;
            [@key "treatGlobalObjectsAsRoots"]
            [@yojson.option]
            [@ocaml.doc
              "If true, a raw snapshot without artificial roots will be \
               generated.\n\
               Deprecated in favor of `exposeInternals`."]
        captureNumericValue : bool option;
            [@key "captureNumericValue"]
            [@yojson.option]
            [@ocaml.doc
              "If true, numerical values are included in the snapshot"]
        exposeInternals : bool option;
            [@key "exposeInternals"]
            [@yojson.option]
            [@ocaml.doc "If true, exposes internals of the snapshot."]
      }
      [@@deriving yojson]

      let make ?reportProgress ?treatGlobalObjectsAsRoots ?captureNumericValue
          ?exposeInternals () =
        {
          reportProgress;
          treatGlobalObjectsAsRoots;
          captureNumericValue;
          exposeInternals;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "HeapProfiler.takeHeapSnapshot"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]
end

module Profiler = struct
  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module GetBestEffortCoverage = struct
    module Response : sig
      type result = {
        result : Types.Profiler.ScriptCoverage.t list;
            [@key "result"]
            [@ocaml.doc "Coverage data for the current isolate."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Profiler.ScriptCoverage.t list;
            [@key "result"]
            [@ocaml.doc "Coverage data for the current isolate."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.getBestEffortCoverage"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Collect coverage data for the current isolate. The coverage data may be incomplete due to
garbage collection. |desc}]

  module SetSamplingInterval = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        interval : Types.number;
            [@key "interval"]
            [@ocaml.doc "New sampling interval in microseconds."]
      }
      [@@deriving yojson]

      let make ~interval () = { interval }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Profiler.setSamplingInterval"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Changes CPU profiler sampling interval. Must be called before CPU profiles recording started. |desc}]

  module Start = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.start"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module StartPreciseCoverage = struct
    module Response : sig
      type result = {
        timestamp : Types.number;
            [@key "timestamp"]
            [@ocaml.doc
              "Monotonically increasing time (in seconds) when the coverage \
               update was taken in the backend."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        timestamp : Types.number;
            [@key "timestamp"]
            [@ocaml.doc
              "Monotonically increasing time (in seconds) when the coverage \
               update was taken in the backend."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        callCount : bool option;
            [@key "callCount"]
            [@yojson.option]
            [@ocaml.doc
              "Collect accurate call counts beyond simple 'covered' or 'not \
               covered'."]
        detailed : bool option;
            [@key "detailed"]
            [@yojson.option]
            [@ocaml.doc "Collect block-based coverage."]
        allowTriggeredUpdates : bool option;
            [@key "allowTriggeredUpdates"]
            [@yojson.option]
            [@ocaml.doc
              "Allow the backend to send updates on its own initiative"]
      }
      [@@deriving yojson]

      let make ?callCount ?detailed ?allowTriggeredUpdates () =
        { callCount; detailed; allowTriggeredUpdates }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Profiler.startPreciseCoverage"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
coverage may be incomplete. Enabling prevents running optimized code and resets execution
counters. |desc}]

  module Stop = struct
    module Response : sig
      type result = {
        profile : Types.Profiler.Profile.t;
            [@key "profile"] [@ocaml.doc "Recorded profile."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        profile : Types.Profiler.Profile.t;
            [@key "profile"] [@ocaml.doc "Recorded profile."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.stop"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module StopPreciseCoverage = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.stopPreciseCoverage"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Disable precise code coverage. Disabling releases unnecessary execution count records and allows
executing optimized code. |desc}]

  module TakePreciseCoverage = struct
    module Response : sig
      type result = {
        result : Types.Profiler.ScriptCoverage.t list;
            [@key "result"]
            [@ocaml.doc "Coverage data for the current isolate."]
        timestamp : Types.number;
            [@key "timestamp"]
            [@ocaml.doc
              "Monotonically increasing time (in seconds) when the coverage \
               update was taken in the backend."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Profiler.ScriptCoverage.t list;
            [@key "result"]
            [@ocaml.doc "Coverage data for the current isolate."]
        timestamp : Types.number;
            [@key "timestamp"]
            [@ocaml.doc
              "Monotonically increasing time (in seconds) when the coverage \
               update was taken in the backend."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Profiler.takePreciseCoverage"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Collect coverage data for the current isolate, and resets execution counters. Precise code
coverage needs to have started. |desc}]
end

module Runtime = struct
  module AwaitPromise = struct
    module Response : sig
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"]
            [@ocaml.doc
              "Promise result. Will contain rejected value if promise was \
               rejected."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details if stack strace is available."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"]
            [@ocaml.doc
              "Promise result. Will contain rejected value if promise was \
               rejected."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details if stack strace is available."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        promiseObjectId : Types.Runtime.RemoteObjectId.t;
            [@key "promiseObjectId"] [@ocaml.doc "Identifier of the promise."]
        returnByValue : bool option;
            [@key "returnByValue"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the result is expected to be a JSON object that should \
               be sent by value."]
        generatePreview : bool option;
            [@key "generatePreview"]
            [@yojson.option]
            [@ocaml.doc "Whether preview should be generated for the result."]
      }
      [@@deriving yojson]

      let make ~promiseObjectId ?returnByValue ?generatePreview () =
        { promiseObjectId; returnByValue; generatePreview }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.awaitPromise"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Add handler to promise with given promise object id. |desc}]

  module CallFunctionOn = struct
    module Response : sig
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Call result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Call result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        functionDeclaration : string;
            [@key "functionDeclaration"]
            [@ocaml.doc "Declaration of the function to call."]
        objectId : Types.Runtime.RemoteObjectId.t option;
            [@key "objectId"]
            [@yojson.option]
            [@ocaml.doc
              "Identifier of the object to call function on. Either objectId \
               or executionContextId should\n\
               be specified."]
        arguments : Types.Runtime.CallArgument.t list option;
            [@key "arguments"]
            [@yojson.option]
            [@ocaml.doc
              "Call arguments. All call arguments must belong to the same \
               JavaScript world as the target\n\
               object."]
        silent : bool option;
            [@key "silent"]
            [@yojson.option]
            [@ocaml.doc
              "In silent mode exceptions thrown during evaluation are not \
               reported and do not pause\n\
               execution. Overrides `setPauseOnException` state."]
        returnByValue : bool option;
            [@key "returnByValue"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the result is expected to be a JSON object which should \
               be sent by value.\n\
               Can be overriden by `serializationOptions`."]
        generatePreview : bool option;
            [@key "generatePreview"]
            [@yojson.option]
            [@ocaml.doc "Whether preview should be generated for the result."]
        userGesture : bool option;
            [@key "userGesture"]
            [@yojson.option]
            [@ocaml.doc
              "Whether execution should be treated as initiated by user in the \
               UI."]
        awaitPromise : bool option;
            [@key "awaitPromise"]
            [@yojson.option]
            [@ocaml.doc
              "Whether execution should `await` for resulting value and return \
               once awaited promise is\n\
               resolved."]
        executionContextId : Types.Runtime.ExecutionContextId.t option;
            [@key "executionContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies execution context which global object will be used to \
               call function on. Either\n\
               executionContextId or objectId should be specified."]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "Symbolic group name that can be used to release multiple \
               objects. If objectGroup is not\n\
               specified and objectId is, objectGroup will be inherited from \
               object."]
        throwOnSideEffect : bool option;
            [@key "throwOnSideEffect"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to throw an exception if side effect cannot be ruled \
               out during evaluation."]
        uniqueContextId : string option;
            [@key "uniqueContextId"]
            [@yojson.option]
            [@ocaml.doc
              "An alternative way to specify the execution context to call \
               function on.\n\
               Compared to contextId that may be reused across processes, this \
               is guaranteed to be\n\
               system-unique, so it can be used to prevent accidental function \
               call\n\
               in context different than intended (e.g. as a result of \
               navigation across process\n\
               boundaries).\n\
               This is mutually exclusive with `executionContextId`."]
        serializationOptions : Types.Runtime.SerializationOptions.t option;
            [@key "serializationOptions"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies the result serialization. If provided, overrides\n\
               `generatePreview` and `returnByValue`."]
      }
      [@@deriving yojson]

      let make ~functionDeclaration ?objectId ?arguments ?silent ?returnByValue
          ?generatePreview ?userGesture ?awaitPromise ?executionContextId
          ?objectGroup ?throwOnSideEffect ?uniqueContextId ?serializationOptions
          () =
        {
          functionDeclaration;
          objectId;
          arguments;
          silent;
          returnByValue;
          generatePreview;
          userGesture;
          awaitPromise;
          executionContextId;
          objectGroup;
          throwOnSideEffect;
          uniqueContextId;
          serializationOptions;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.callFunctionOn"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Calls function with given declaration on the given object. Object group of the result is
inherited from the target object. |desc}]

  module CompileScript = struct
    module Response : sig
      type result = {
        scriptId : Types.Runtime.ScriptId.t option;
            [@key "scriptId"] [@yojson.option] [@ocaml.doc "Id of the script."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        scriptId : Types.Runtime.ScriptId.t option;
            [@key "scriptId"] [@yojson.option] [@ocaml.doc "Id of the script."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        expression : string;
            [@key "expression"] [@ocaml.doc "Expression to compile."]
        sourceURL : string;
            [@key "sourceURL"]
            [@ocaml.doc "Source url to be set for the script."]
        persistScript : bool;
            [@key "persistScript"]
            [@ocaml.doc
              "Specifies whether the compiled script should be persisted."]
        executionContextId : Types.Runtime.ExecutionContextId.t option;
            [@key "executionContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies in which execution context to perform script run. If \
               the parameter is omitted the\n\
               evaluation will be performed in the context of the inspected \
               page."]
      }
      [@@deriving yojson]

      let make ~expression ~sourceURL ~persistScript ?executionContextId () =
        { expression; sourceURL; persistScript; executionContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.compileScript"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Compiles expression. |desc}]

  module Disable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.disable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Disables reporting of execution contexts creation. |desc}]

  module DiscardConsoleEntries = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.discardConsoleEntries"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Discards collected exceptions and console API calls. |desc}]

  module Enable = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.enable"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Enables reporting of execution contexts creation by means of `executionContextCreated` event.
When the reporting gets enabled the event will be sent immediately for each existing execution
context. |desc}]

  module Evaluate = struct
    module Response : sig
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Evaluation result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Evaluation result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        expression : string;
            [@key "expression"] [@ocaml.doc "Expression to evaluate."]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "Symbolic group name that can be used to release multiple \
               objects."]
        includeCommandLineAPI : bool option;
            [@key "includeCommandLineAPI"]
            [@yojson.option]
            [@ocaml.doc
              "Determines whether Command Line API should be available during \
               the evaluation."]
        silent : bool option;
            [@key "silent"]
            [@yojson.option]
            [@ocaml.doc
              "In silent mode exceptions thrown during evaluation are not \
               reported and do not pause\n\
               execution. Overrides `setPauseOnException` state."]
        contextId : Types.Runtime.ExecutionContextId.t option;
            [@key "contextId"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies in which execution context to perform evaluation. If \
               the parameter is omitted the\n\
               evaluation will be performed in the context of the inspected \
               page.\n\
               This is mutually exclusive with `uniqueContextId`, which offers \
               an\n\
               alternative way to identify the execution context that is more \
               reliable\n\
               in a multi-process environment."]
        returnByValue : bool option;
            [@key "returnByValue"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the result is expected to be a JSON object that should \
               be sent by value."]
        generatePreview : bool option;
            [@key "generatePreview"]
            [@yojson.option]
            [@ocaml.doc "Whether preview should be generated for the result."]
        userGesture : bool option;
            [@key "userGesture"]
            [@yojson.option]
            [@ocaml.doc
              "Whether execution should be treated as initiated by user in the \
               UI."]
        awaitPromise : bool option;
            [@key "awaitPromise"]
            [@yojson.option]
            [@ocaml.doc
              "Whether execution should `await` for resulting value and return \
               once awaited promise is\n\
               resolved."]
        throwOnSideEffect : bool option;
            [@key "throwOnSideEffect"]
            [@yojson.option]
            [@ocaml.doc
              "Whether to throw an exception if side effect cannot be ruled \
               out during evaluation.\n\
               This implies `disableBreaks` below."]
        timeout : Types.Runtime.TimeDelta.t option;
            [@key "timeout"]
            [@yojson.option]
            [@ocaml.doc
              "Terminate execution after timing out (number of milliseconds)."]
        disableBreaks : bool option;
            [@key "disableBreaks"]
            [@yojson.option]
            [@ocaml.doc "Disable breakpoints during execution."]
        replMode : bool option;
            [@key "replMode"]
            [@yojson.option]
            [@ocaml.doc
              "Setting this flag to true enables `let` re-declaration and \
               top-level `await`.\n\
               Note that `let` variables can only be re-declared if they \
               originate from\n\
               `replMode` themselves."]
        allowUnsafeEvalBlockedByCSP : bool option;
            [@key "allowUnsafeEvalBlockedByCSP"]
            [@yojson.option]
            [@ocaml.doc
              "The Content Security Policy (CSP) for the target might block \
               'unsafe-eval'\n\
               which includes eval(), Function(), setTimeout() and setInterval()\n\
               when called with non-callable arguments. This flag bypasses CSP \
               for this\n\
               evaluation and allows unsafe-eval. Defaults to true."]
        uniqueContextId : string option;
            [@key "uniqueContextId"]
            [@yojson.option]
            [@ocaml.doc
              "An alternative way to specify the execution context to evaluate \
               in.\n\
               Compared to contextId that may be reused across processes, this \
               is guaranteed to be\n\
               system-unique, so it can be used to prevent accidental \
               evaluation of the expression\n\
               in context different than intended (e.g. as a result of \
               navigation across process\n\
               boundaries).\n\
               This is mutually exclusive with `contextId`."]
        serializationOptions : Types.Runtime.SerializationOptions.t option;
            [@key "serializationOptions"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies the result serialization. If provided, overrides\n\
               `generatePreview` and `returnByValue`."]
      }
      [@@deriving yojson]

      let make ~expression ?objectGroup ?includeCommandLineAPI ?silent
          ?contextId ?returnByValue ?generatePreview ?userGesture ?awaitPromise
          ?throwOnSideEffect ?timeout ?disableBreaks ?replMode
          ?allowUnsafeEvalBlockedByCSP ?uniqueContextId ?serializationOptions ()
          =
        {
          expression;
          objectGroup;
          includeCommandLineAPI;
          silent;
          contextId;
          returnByValue;
          generatePreview;
          userGesture;
          awaitPromise;
          throwOnSideEffect;
          timeout;
          disableBreaks;
          replMode;
          allowUnsafeEvalBlockedByCSP;
          uniqueContextId;
          serializationOptions;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.evaluate"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Evaluates expression on global object. |desc}]

  module GetIsolateId = struct
    module Response : sig
      type result = { id : string [@key "id"] [@ocaml.doc "The isolate id."] }
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = { id : string [@key "id"] [@ocaml.doc "The isolate id."] }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.getIsolateId"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns the isolate id. |desc}]

  module GetHeapUsage = struct
    module Response : sig
      type result = {
        usedSize : Types.number;
            [@key "usedSize"] [@ocaml.doc "Used JavaScript heap size in bytes."]
        totalSize : Types.number;
            [@key "totalSize"]
            [@ocaml.doc "Allocated JavaScript heap size in bytes."]
        embedderHeapUsedSize : Types.number;
            [@key "embedderHeapUsedSize"]
            [@ocaml.doc
              "Used size in bytes in the embedder's garbage-collected heap."]
        backingStorageSize : Types.number;
            [@key "backingStorageSize"]
            [@ocaml.doc
              "Size in bytes of backing storage for array buffers and external \
               strings."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        usedSize : Types.number;
            [@key "usedSize"] [@ocaml.doc "Used JavaScript heap size in bytes."]
        totalSize : Types.number;
            [@key "totalSize"]
            [@ocaml.doc "Allocated JavaScript heap size in bytes."]
        embedderHeapUsedSize : Types.number;
            [@key "embedderHeapUsedSize"]
            [@ocaml.doc
              "Used size in bytes in the embedder's garbage-collected heap."]
        backingStorageSize : Types.number;
            [@key "backingStorageSize"]
            [@ocaml.doc
              "Size in bytes of backing storage for array buffers and external \
               strings."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.getHeapUsage"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns the JavaScript heap usage.
It is the total usage of the corresponding isolate not scoped to a particular Runtime. |desc}]

  module GetProperties = struct
    module Response : sig
      type result = {
        result : Types.Runtime.PropertyDescriptor.t list;
            [@key "result"] [@ocaml.doc "Object properties."]
        internalProperties :
          Types.Runtime.InternalPropertyDescriptor.t list option;
            [@key "internalProperties"]
            [@yojson.option]
            [@ocaml.doc
              "Internal object properties (only of the element itself)."]
        privateProperties :
          Types.Runtime.PrivatePropertyDescriptor.t list option;
            [@key "privateProperties"]
            [@yojson.option]
            [@ocaml.doc "Object private properties."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.PropertyDescriptor.t list;
            [@key "result"] [@ocaml.doc "Object properties."]
        internalProperties :
          Types.Runtime.InternalPropertyDescriptor.t list option;
            [@key "internalProperties"]
            [@yojson.option]
            [@ocaml.doc
              "Internal object properties (only of the element itself)."]
        privateProperties :
          Types.Runtime.PrivatePropertyDescriptor.t list option;
            [@key "privateProperties"]
            [@yojson.option]
            [@ocaml.doc "Object private properties."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"]
            [@ocaml.doc "Identifier of the object to return properties for."]
        ownProperties : bool option;
            [@key "ownProperties"]
            [@yojson.option]
            [@ocaml.doc
              "If true, returns properties belonging only to the element \
               itself, not to its prototype\n\
               chain."]
        accessorPropertiesOnly : bool option;
            [@key "accessorPropertiesOnly"]
            [@yojson.option]
            [@ocaml.doc
              "If true, returns accessor properties (with getter/setter) only; \
               internal properties are not\n\
               returned either."]
        generatePreview : bool option;
            [@key "generatePreview"]
            [@yojson.option]
            [@ocaml.doc "Whether preview should be generated for the results."]
        nonIndexedPropertiesOnly : bool option;
            [@key "nonIndexedPropertiesOnly"]
            [@yojson.option]
            [@ocaml.doc "If true, returns non-indexed properties only."]
      }
      [@@deriving yojson]

      let make ~objectId ?ownProperties ?accessorPropertiesOnly ?generatePreview
          ?nonIndexedPropertiesOnly () =
        {
          objectId;
          ownProperties;
          accessorPropertiesOnly;
          generatePreview;
          nonIndexedPropertiesOnly;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.getProperties"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns properties of a given object. Object group of the result is inherited from the target
object. |desc}]

  module GlobalLexicalScopeNames = struct
    module Response : sig
      type result = {
        names : string list;
            [@key "names"] [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        names : string list;
            [@key "names"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        executionContextId : Types.Runtime.ExecutionContextId.t option;
            [@key "executionContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies in which execution context to lookup global scope \
               variables."]
      }
      [@@deriving yojson]

      let make ?executionContextId () = { executionContextId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.globalLexicalScopeNames"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Returns all let, const and class variables from global scope. |desc}]

  module QueryObjects = struct
    module Response : sig
      type result = {
        objects : Types.Runtime.RemoteObject.t;
            [@key "objects"] [@ocaml.doc "Array with objects."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        objects : Types.Runtime.RemoteObject.t;
            [@key "objects"] [@ocaml.doc "Array with objects."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        prototypeObjectId : Types.Runtime.RemoteObjectId.t;
            [@key "prototypeObjectId"]
            [@ocaml.doc "Identifier of the prototype to return objects for."]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "Symbolic group name that can be used to release the results."]
      }
      [@@deriving yojson]

      let make ~prototypeObjectId ?objectGroup () =
        { prototypeObjectId; objectGroup }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.queryObjects"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module ReleaseObject = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectId : Types.Runtime.RemoteObjectId.t;
            [@key "objectId"]
            [@ocaml.doc "Identifier of the object to release."]
      }
      [@@deriving yojson]

      let make ~objectId () = { objectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.releaseObject"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Releases remote object with given id. |desc}]

  module ReleaseObjectGroup = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        objectGroup : string;
            [@key "objectGroup"] [@ocaml.doc "Symbolic object group name."]
      }
      [@@deriving yojson]

      let make ~objectGroup () = { objectGroup }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.releaseObjectGroup"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Releases all remote objects that belong to a given group. |desc}]

  module RunIfWaitingForDebugger = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.runIfWaitingForDebugger"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Tells inspected instance to run if it was waiting for debugger to attach. |desc}]

  module RunScript = struct
    module Response : sig
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Run result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        result : Types.Runtime.RemoteObject.t;
            [@key "result"] [@ocaml.doc "Run result."]
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "Exception details."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        scriptId : Types.Runtime.ScriptId.t;
            [@key "scriptId"] [@ocaml.doc "Id of the script to run."]
        executionContextId : Types.Runtime.ExecutionContextId.t option;
            [@key "executionContextId"]
            [@yojson.option]
            [@ocaml.doc
              "Specifies in which execution context to perform script run. If \
               the parameter is omitted the\n\
               evaluation will be performed in the context of the inspected \
               page."]
        objectGroup : string option;
            [@key "objectGroup"]
            [@yojson.option]
            [@ocaml.doc
              "Symbolic group name that can be used to release multiple \
               objects."]
        silent : bool option;
            [@key "silent"]
            [@yojson.option]
            [@ocaml.doc
              "In silent mode exceptions thrown during evaluation are not \
               reported and do not pause\n\
               execution. Overrides `setPauseOnException` state."]
        includeCommandLineAPI : bool option;
            [@key "includeCommandLineAPI"]
            [@yojson.option]
            [@ocaml.doc
              "Determines whether Command Line API should be available during \
               the evaluation."]
        returnByValue : bool option;
            [@key "returnByValue"]
            [@yojson.option]
            [@ocaml.doc
              "Whether the result is expected to be a JSON object which should \
               be sent by value."]
        generatePreview : bool option;
            [@key "generatePreview"]
            [@yojson.option]
            [@ocaml.doc "Whether preview should be generated for the result."]
        awaitPromise : bool option;
            [@key "awaitPromise"]
            [@yojson.option]
            [@ocaml.doc
              "Whether execution should `await` for resulting value and return \
               once awaited promise is\n\
               resolved."]
      }
      [@@deriving yojson]

      let make ~scriptId ?executionContextId ?objectGroup ?silent
          ?includeCommandLineAPI ?returnByValue ?generatePreview ?awaitPromise
          () =
        {
          scriptId;
          executionContextId;
          objectGroup;
          silent;
          includeCommandLineAPI;
          returnByValue;
          generatePreview;
          awaitPromise;
        }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.runScript"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Runs script with given id in a given context. |desc}]

  module SetAsyncCallStackDepth = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        maxDepth : Types.number;
            [@key "maxDepth"]
            [@ocaml.doc
              "Maximum depth of async call stacks. Setting to `0` will \
               effectively disable collecting async\n\
               call stacks (default)."]
      }
      [@@deriving yojson]

      let make ~maxDepth () = { maxDepth }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.setAsyncCallStackDepth"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Enables or disables async call stacks tracking. |desc}]

  module SetCustomObjectFormatterEnabled = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        enabled : bool; [@key "enabled"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~enabled () = { enabled }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Runtime.setCustomObjectFormatterEnabled";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module SetMaxCallStackSizeToCapture = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        size : Types.number; [@key "size"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~size () = { size }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        {
          id;
          method_ = "Runtime.setMaxCallStackSizeToCapture";
          sessionId;
          params;
        }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|No description provided |desc}]

  module TerminateExecution = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Runtime.terminateExecution"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|Terminate current or next JavaScript execution.
Will cancel the termination when the outer-most script execution ends. |desc}]

  module AddBinding = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        name : string; [@key "name"] [@ocaml.doc "No description provided"]
        executionContextId : Types.Runtime.ExecutionContextId.t option;
            [@key "executionContextId"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, the binding would only be exposed to the specified\n\
               execution context. If omitted and `executionContextName` is not \
               set,\n\
               the binding is exposed to all execution contexts of the target.\n\
               This parameter is mutually exclusive with `executionContextName`.\n\
               Deprecated in favor of `executionContextName` due to an unclear \
               use case\n\
               and bugs in implementation (crbug.com/1169639). \
               `executionContextId` will be\n\
               removed in the future."]
        executionContextName : string option;
            [@key "executionContextName"]
            [@yojson.option]
            [@ocaml.doc
              "If specified, the binding is exposed to the executionContext with\n\
               matching name, even for contexts created after the binding is \
               added.\n\
               See also `ExecutionContext.name` and `worldName` parameter to\n\
               `Page.addScriptToEvaluateOnNewDocument`.\n\
               This parameter is mutually exclusive with `executionContextId`."]
      }
      [@@deriving yojson]

      let make ~name ?executionContextId ?executionContextName () =
        { name; executionContextId; executionContextName }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.addBinding"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|If executionContextId is empty, adds binding with the given name on the
global objects of all inspected contexts, including those created later,
bindings survive reloads.
Binding function takes exactly one argument, this argument should be string,
in case of any other input, function throws an exception.
Each binding function call produces Runtime.bindingCalled notification. |desc}]

  module RemoveBinding = struct
    module Response : sig
      type result = Types.assoc
      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = Types.assoc [@@deriving yojson]
      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        name : string; [@key "name"] [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      let make ~name () = { name }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.removeBinding"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|This method does not remove binding function from global object but
unsubscribes current runtime agent from Runtime.bindingCalled notifications. |desc}]

  module GetExceptionDetails = struct
    module Response : sig
      type result = {
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        exceptionDetails : Types.Runtime.ExceptionDetails.t option;
            [@key "exceptionDetails"]
            [@yojson.option]
            [@ocaml.doc "No description provided"]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Params = struct
      type t = {
        errorObjectId : Types.Runtime.RemoteObjectId.t;
            [@key "errorObjectId"]
            [@ocaml.doc
              "The error object for which to resolve the exception details."]
      }
      [@@deriving yojson]

      let make ~errorObjectId () = { errorObjectId }
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
        params : Params.t;
      }
      [@@deriving yojson]

      let make ?sessionId ~params id =
        { id; method_ = "Runtime.getExceptionDetails"; sessionId; params }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc
    {desc|This method tries to lookup and populate exception details for a
JavaScript Error object.
Note that the stackTrace portion of the resulting exceptionDetails will
only be populated if the Runtime domain was enabled at the time when the
Error was thrown. |desc}]
end

module Schema = struct
  module GetDomains = struct
    module Response : sig
      type result = {
        domains : Types.Schema.Domain.t list;
            [@key "domains"] [@ocaml.doc "List of supported domains."]
      }

      type error = { code : int; message : string }

      type t = {
        id : int;
        error : error option;
        sessionId : Types.Target.SessionID.t option;
        result : result option;
      }

      val parse : string -> t
    end = struct
      type result = {
        domains : Types.Schema.Domain.t list;
            [@key "domains"] [@ocaml.doc "List of supported domains."]
      }
      [@@deriving yojson]

      type error = { code : int; message : string } [@@deriving yojson]

      type t = {
        id : int;
        error : error option; [@yojson.option]
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        result : result option; [@yojson.option]
      }
      [@@deriving yojson]

      let parse response = response |> Yojson.Safe.from_string |> t_of_yojson
    end

    module Request = struct
      type t = {
        id : int;
        sessionId : Types.Target.SessionID.t option; [@yojson.option]
        method_ : string; [@key "method"]
      }
      [@@deriving yojson]

      let make ?sessionId id =
        { id; method_ = "Schema.getDomains"; sessionId }
        |> yojson_of_t |> Yojson.Safe.to_string
    end
  end
  [@@ocaml.doc {desc|Returns supported domains. |desc}]
end
